Pluggable TOAST

I. What is Pluggable TOAST

TOAST is slicing and storing an oversized value externally to Tuple.
Currently TOAST is a part of Heap AM (Core). Not extensible, has
same strategy for all datatypes, and not effective for structured
data (json) or data required special workflow (bytea).

Pluggable TOAST propose storing a value outside Tuple, with means
and storage depending on a specific entity incapsulating all storage
mechanics and hiding it from Table AM which calls it - thi entity we
are calling Toaster. Advantages over standard standard TOAST - detached
from Heap AM, has extensible TOAST API allowing plugging in custom
Toasters.

In short:
How TOAST Works
- When tuple size exceeds some internal limit Heap decides to TOAST
  large attributes
- Attribute stored in TOAST relation and replaced with Toast Pointer
- 4 strategies depending on storage type
- TOAST does not know anything about data being TOASTed

How Pluggable TOAST Works
- Attribute is replaced with Custom Toast Pointer created by specific
  Toaster
- TOAST and storage details are hidden from AM behind the Toaster
- Toaster can use any knowledge of data structure and workflow
- Same data could be TOASTed with different Toasters

II. Pluggable TOAST API
Pluggable TOAST proposes and open API allowing to develop and plug in
custom Toasters for table column and data types. Toaster could process
TOASTed data using knowledge about internal data structure and workflow.

Toasters could use any storage, advanced compression, encryption, and
other functionality internally, without awaring TAM that calls Toaster.

Any custom Toaster should have a handler and pre-defined method set.
Toaster header must defined according to toastapi.h and several mandatory
methods must be implemented to be able to toast and detoast data.

Also, TOAST API has one very important and powerful method - "get_vtable".
This method is responsible for API extensibility - it allows passing
outside Toaster any specific functions a developer wants to be available
to outer interfaces, like "append" function for bytea datatype which
appends bytea value without creating an intermediate copy, JSON
container-specific functions, compression algorythms, etc.

Toaster method description:
1) toast_init   - function responsible for initializing TOAST,
        i.e. create TOAST table and other preventive actions;
2) toast 		    - (!) mandatory function, TOASTs incoming value -
        actual external storage is done here. Toast pointer is returned
        instead of untoasted data. Is impemented in Generic (default)
        Toaster;
3) update_toast - update existing TOASTed value. Generic (default) TOAST
        does not implement Update, it can only do full detoast, mark old
        TOAST tuple as dead, and toast and store an updated value;
4) copy_toast 	- create copy of the TOASTed value;
5) detoast 	    - (!) mandatory function, recovers toasted data from
        external storage into original data (regular varlena);
6) deltoast 	  - delete TOASTed value from TOAST table;
7) get_vtable 	- returns virtual functions table - structure
        containing pointers to functions extending pre-defined
        function set;
8) toastervalidate - (!) mandatory function, validates Toaster
        for given data or data type;

Please note: functions highlighted with "(!)" are mandatory and
must be implemented. Other functions are optional.

An example of get_vtable extended method set:
static void *
bytea_toaster_vtable(Datum toast_ptr)
{
	ByteaToastRoutine *routine = palloc0(sizeof(*routine));

	routine->magic = BYTEA_TOASTER_MAGIC;
	routine->append = bytea_toaster_append;

	return routine;
}



III. SQL Syntax and System Catalog

Pluggable TOAST introduces new entity into system catalog - PG_TOASTER
table where all Toasters reside:

select * from PG_TOASTER;
  oid  |    tsrname    |       tsrhandler
-------+---------------+-------------------------
  9864 | deftoaster    | default_toaster_handler
(1 rows)

Where tsrname is the name of the Toaster used in SQL queries and
tsrhandler is Toaster handler function defined by developer.

Pluggable TOAST extends SQL syntax:
1) For CREATE TABLE -
CREATE TABLE t ( c <type> STORAGE external TOASTER <t1> );
2) ALTER TABLE ALTER COLUMN
ALTER TABLE t ALTER COLUMN c SET TOASTER <t1>;
where <t1> is toaster name registered in PG_TOASTER table.
Please note that for custom Toasters STORAGE must be explicitly stated
as EXTERNAL.
Default toaster has toaster name "deftoaster", and it is applied
implicitly if not stated otherwise. But if you want to use it
explicitly it is done as with custom Toasters:

ALTER TABLE t ALTER COLUMN c SET TOASTER deftoaster;

IV. SQL Syntax Example

SQL definition of new Toaster Extension:

CREATE FUNCTION custom_toaster_handler(internal)
RETURNS toaster_handler
AS 'MODULE_PATHNAME'
LANGUAGE C;

CREATE TOASTER custom_toaster HANDLER custom_toaster_handler;

SQL â€“  install custom Toaster:

CREATE EXTENSION custom_toaster;
select * from pg_toaster;
  oid  |    tsrname     |       tsrhandler
-------+----------------+-------------------------
  9864 | deftoaster     | default_toaster_handler
 32772 | custom_toaster | custom_toaster_handler

Usage example:

CREATE TABLE tst1 (
    c1 text STORAGE plain,
    c2 text STORAGE external TOASTER custom_toaster,
    id int4
);
ALTER TABLE tst1 ALTER COLUMN c1 SET TOASTER custom_toaster;
=# \d+ tst1
 Column |  Type   | Collation | Nullable | Default | Storage  |  Toaster       |...
--------+---------+-----------+----------+---------+----------+----------------+...
 c1     | text    |           |          |         | plain    | deftoaster     |...
 c2     | text    |           |          |         | external | custom_toaster |...
 id     | integer |           |          |         | plain    |                |...
Access method: heap

=# \d pg_attribute
               Table "pg_catalog.pg_attribute"
     Column     |   Type    | Collation | Nullable | Default
----------------+-----------+-----------+----------+---------
 attrelid       | oid       |           | not null |
 attname        | name      |           | not null |
...
 attstorage     | "char"    |           | not null |
 atttoaster     | oid       |           | not null |
 attcompression | "char"    |           | not null |
...


V. Dummy Toaster

For the sake of developers eager to develop their own Custom
Toasters we provide DUMMY TOASTER extension which is simple
Toaster that does nothing with the data passed to it except
checking data length and emitting error message if data size
exceeds hardcoded limit of 1024 bytes.

Usage example:

CREATE EXTENSION dummy_toaster;

select * from PG_TOASTER;
  oid  |    tsrname    |       tsrhandler
-------+---------------+-------------------------
  9864 | deftoaster    | default_toaster_handler
 16386 | dummy_toaster | dummy_toaster_handler
(2 rows)

CREATE TABLE tst_failed (
	t text TOASTER dummy_toaster TOASTER dummy_toaster
);
ERROR:  multiple TOASTER clauses not allowed
CREATE TABLE tst1 (
	f text STORAGE plain,
	t text STORAGE external TOASTER dummy_toaster,
	l int
);
SELECT  setseed(0);
 setseed
---------

(1 row)

INSERT INTO tst1
	SELECT repeat('a', 2000)::text as f, t.t as t, length(t.t) as l FROM
		(SELECT
			repeat(random()::text, (20+30*random())::int) as t
		 FROM
			generate_series(1, 32) as  i) as t;
SELECT length(t), l, length(t) = l FROM tst1 ORDER BY 1, 3;
 length |  l  | ?column?
--------+-----+----------
    391 | 391 | t
    414 | 414 | t
    437 | 437 | t
    442 | 442 | t
    448 | 448 | t
    450 | 450 | t
    540 | 540 | t
    540 | 540 | t
    551 | 551 | t
    558 | 558 | t
    594 | 594 | t
    612 | 612 | t
    630 | 630 | t
    646 | 646 | t
    648 | 648 | t
    648 | 648 | t
    665 | 665 | t
    666 | 666 | t
    684 | 684 | t
    702 | 702 | t
    738 | 738 | t
    738 | 738 | t
    741 | 741 | t
    756 | 756 | t
    756 | 756 | t
    774 | 774 | t
    792 | 792 | t
    798 | 798 | t
    833 | 833 | t
    836 | 836 | t
    855 | 855 | t
    882 | 882 | t
(32 rows)

SELECT attnum, attname, atttypid, attstorage, tsrname
	FROM pg_attribute, pg_toaster t
	WHERE attrelid = 'tst1'::regclass and attnum>0 and t.oid = atttoaster
	ORDER BY attnum;
 attnum | attname | atttypid | attstorage |    tsrname
--------+---------+----------+------------+---------------
      1 | f       |       25 | p          | deftoaster
      2 | t       |       25 | e          | dummy_toaster
(2 rows)

CREATE TABLE tst2 (
	t text
);
SELECT attnum, attname, atttypid, attstorage, tsrname
	FROM pg_attribute, pg_toaster t
	WHERE attrelid = 'tst2'::regclass and attnum>0 and t.oid = atttoaster
	ORDER BY attnum;
 attnum | attname | atttypid | attstorage |  tsrname
--------+---------+----------+------------+------------
      1 | t       |       25 | x          | deftoaster
(1 row)


VI. Source Changes

Changed sources:
src/include/access/toasterapi.h
src/backend/access/index/toasterapi.c
src/include/catalog/pg_toaster.h
src/include/access/detoast.h
src/backend/access/common/detoast.c
src/include/postgres.h
src/backend/access/common/toast_internals.c
src/backend/access/heap/heaptoast.c

contrib/dummy_toaster/dummy_toaster.c

1) src/include/access/toasterapi.h
Definition of TOAST API macros, set of methods to implement and
TsrRoutine (analogous to Table AM Routine) structure, to pass
Toaster's methods to caller.
Method set consists of:
	toast_init 	- function used to initialize TOAST,
        i.e. create TOAST table and other preventive actions;
	toast 		- (!) mandatory function, TOAST incoming value
        (Datum) implementation;
	update_toast 	- update existing TOASTed value. Generic
        (default) TOAST does not implement Update, it can only
        do full detoast, mark old TOAST tuple as dead, and toast
        and store an updated value;
	copy_toast 	- create copy of the TOASTed value;
	detoast 	- (!) mandatory function, detoast value or it's
        slice of given length;
	deltoast 	- delete TOASTed value from TOAST table;
	get_vtable 	- returns virtual functions table - structure
        containing pointers to functions extending pre-defined
        function set;
	toastervalidate - (!) mandatory function, validates Toaster
        for given data;

Please note: functions highlighted with "(!)" are mandatory and
must be implemented. Other functions are optional.

Toaster search methods used for lookup also defined here
GetTsrRoutine - calls Toaster handler and returs it for further use
GetTsrRoutineByOid - used in search and validate methods
SearchTsrCache - searches cached Toaster routines by Toaster OID
    and returns one if found (fast lookup)
validateToaster - used in tablecmds.c to validate Toaster OID
Implemented in
2) src/backend/access/index/toasterapi.c

3) src/include/catalog/pg_toaster.h
Definition of system catalog pg_toaster table. All TOASTers reside here.
TOASTers are available via Toaster OID (from C) or Toaster name (from SQL).

4) src/include/access/detoast.h
Headers for higher-lever Detoast functions used in Heap AM, from where
Toaster methods are called. Specific to internals of Heap AM, not affected
by TOAST API.
Implemented in
5) src/backend/access/common/detoast.c

6) src/include/postgres.h
Here resides definition of TOAST Pointer structures, old (External)
and new (Custom).
Custom TOAST Pointer uses 16 bit alignment, and contains fields mandatory
for Toaster lookup (Toaster OID), Executor checks (va_rawsize), and tail with
variable length for custom data (va_toasterdata) with it's length
(va_toasterdatalen). Variable part of Custom TOAST pointer could contain any
other data, structures and so on, required by Toaster implementation.

New structure definition:
typedef struct varatt_custom
{
	uint16			va_toasterdatalen;/* total size of toast pointer, < BLCKSZ */
	uint32align16	va_rawsize;		/* Original data size (includes header) */
	uint32align16	va_toasterid;	/* Toaster ID, actually Oid */
	char		va_toasterdata[FLEXIBLE_ARRAY_MEMBER];	/* Custom toaster data */
}			varatt_custom;

For comparision, old (External) TOAST Pointer:
typedef struct varatt_external
{
	int32		va_rawsize;		/* Original data size (includes header) */
	uint32		va_extinfo;		/* External saved size (without header) and
								 * compression method */
	Oid			va_valueid;		/* Unique ID of value within TOAST table */
	Oid			va_toastrelid;	/* RelID of TOAST table containing it */
}			varatt_external;
is not aligned.

TOAST pointer is a sub-structure of varlena with Vartag byte (varattrib_1b_e):

/* TOAST pointers are a subset of varattrib_1b with an identifying tag byte */
typedef struct
{
	uint8		va_header;		/* Always 0x80 or 0x01 */
	uint8		va_tag;			/* Type of datum */
	char		va_data[FLEXIBLE_ARRAY_MEMBER]; /* Type-specific data */
} varattrib_1b_e;

When casting from varlena structure Custom TOAST pointer is recognized from
External by value of field "va_tag":

typedef enum vartag_external
{
	VARTAG_INDIRECT = 1,
	VARTAG_EXPANDED_RO = 2,
	VARTAG_EXPANDED_RW = 3,
	VARTAG_CUSTOM = 4, /* New tag for CUSTOM pointers */
	VARTAG_ONDISK = 18,
} vartag_external;

So, like External TOAST pointers Custom ones have the same set of macros
to use in development:

#define VARHDRSZ_EXTERNAL		offsetof(varattrib_1b_e, va_data)
#define VARHDRSZ_CUSTOM			offsetof(varattrib_1b_e, va_data)
#define VARATT_CUSTOM_GET_TOASTPOINTER(PTR) \
	((varatt_custom *) VARDATA_EXTERNAL(PTR))

#define VARATT_CUSTOM_GET_TOASTERID(PTR) \
	(get_uint32align16(&VARATT_CUSTOM_GET_TOASTPOINTER(PTR)->va_toasterid))

#define VARATT_CUSTOM_SET_TOASTERID(PTR, V) \
	(set_uint32align16(&VARATT_CUSTOM_GET_TOASTPOINTER(PTR)->va_toasterid, (V)))

#define VARATT_CUSTOM_GET_DATA_RAW_SIZE(PTR) \
	(get_uint32align16(&VARATT_CUSTOM_GET_TOASTPOINTER(PTR)->va_rawsize))

#define VARATT_CUSTOM_SET_DATA_RAW_SIZE(PTR, V) \
	(set_uint32align16(&VARATT_CUSTOM_GET_TOASTPOINTER(PTR)->va_rawsize, (V)))

#define VARATT_CUSTOM_GET_DATA_SIZE(PTR) \
	((int32) VARATT_CUSTOM_GET_TOASTPOINTER(PTR)->va_toasterdatalen)

#define VARATT_CUSTOM_SET_DATA_SIZE(PTR, V) \
	(VARATT_CUSTOM_GET_TOASTPOINTER(PTR)->va_toasterdatalen = (V))

#define VARATT_CUSTOM_GET_DATA(PTR) \
	(VARATT_CUSTOM_GET_TOASTPOINTER(PTR)->va_toasterdata)

#define VARATT_CUSTOM_SIZE(datalen) \
	((Size) VARHDRSZ_EXTERNAL + offsetof(varatt_custom, va_toasterdata) + (datalen))

#define VARSIZE_CUSTOM(PTR)	VARATT_CUSTOM_SIZE(VARATT_CUSTOM_GET_DATA_SIZE(PTR))


5) src/backend/access/common/toast_internals.c
Here are internal functions currently used by Toasters, implementing storing
and fetching data. Current Toasters implementations use Heap AM, but due to
all storage mechanics is hidden from TAM that calls Toaster any Toaster could
implement different storage techniques, with different AMs, and could even
implement independent storage. The examples of different storage implementations
within existing AM are Default Toaster implementation without usage of indexes
and large objects toaster to store LOBs without limitations of pg_largeobject
functionality.

7) src/backend/access/heap/heaptoast.c
Heap-specific definitions for external and compressed storage of variable size
attributes. Insert, update and fetch. heap_toast_insert_or_update method contains
Heap AM TOAST data storage strategies, deciding if TOAST will be used to store
external and extended data according to overall Tuple size.
Strategies explanation (from comments):
>>>
 Compress and/or save external until data fits into target length

	1: Inline compress attributes with attstorage EXTENDED, and store very
	   large attributes with attstorage EXTENDED or EXTERNAL external
	   immediately
	2: Store attributes with attstorage EXTENDED or EXTERNAL external
	3: Inline compress attributes with attstorage MAIN
	4: Store attributes with attstorage MAIN external

 Look for attributes with attstorage EXTENDED to compress.  Also find
 large attributes with attstorage EXTENDED or EXTERNAL, and store them
 external.

 Attempt to compress it inline, if it has attstorage EXTENDED
 otherwise has attstorage EXTERNAL, ignore on subsequent compression
 passes

 If this value is by itself more than maxDataLen (after compression
 if any), push it out to the toast table immediately, if possible.
 This avoids uselessly compressing other fields in the common case
 where we have one long field and several short ones.

 Second we look for attributes of attstorage EXTENDED or EXTERNAL that
 are still inline, and make them external.  But skip this if there's no
 toast table to push them to.

 Round 3 - this time we take attributes with storage MAIN into
 compression

 Finally we store attributes of type MAIN externally.  At this point we
 increase the target tuple size, so that MAIN attributes aren't stored
 externally unless really necessary.

VI. Tests

Functional Tests

Regular regression tests are fully suitable for testing Default (Generic)
Toaster, no special tests are needed because it replaces standard TOAST mechanics.

Performance Tests

To test TOAST API overhead over master (current) TOAST implementation the
following test was used:

        /* CREATE TABLE test_toast_p (id int, jb jsonb); */
        select pg_column_size(jb ) into t_size FROM test_toast_p WHERE id = k;
		StartTime := clock_timestamp();
        /* One of the three following queries was ised in separate cycle, to
         * test INSERT, UPDATE and SELECT operations execution time, on master
         * and patched versions */
        INSERT into test_toast_p values (k,  repeat('a', i*j));
        UPDATE test_toast_p set jb = repeat('b', pg_column_size(jb)+1) where id=k;
        PERFORM jb from test_toast_p where id=k;

        EndTime := clock_timestamp();
        Delta := 1000 * ( extract(epoch from EndTime) - extract(epoch from StartTime) );

Tests shew that TOAST API does not have any overhead in means of performance over
standard implementation.