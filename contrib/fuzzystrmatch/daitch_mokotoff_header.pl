#!/bin/perl
#
# Generation of types and lookup tables for Daitch-Mokotoff soundex.
#
# Copyright (c) 2021 Finance Norway
# Author: Dag Lem <dag@nimrod.no>
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose, without fee, and without a written agreement
# is hereby granted, provided that the above copyright notice and this
# paragraph and the following two paragraphs appear in all copies.
#
# IN NO EVENT SHALL THE AUTHOR OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
# DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
# LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
# DOCUMENTATION, EVEN IF THE AUTHOR OR DISTRIBUTORS HAVE BEEN ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# THE AUTHOR AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
# ON AN "AS IS" BASIS, AND THE AUTHOR AND DISTRIBUTORS HAS NO OBLIGATIONS TO
# PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
#

use strict;
use warnings;
use utf8;
use open IO => ':utf8', ':std';
use Data::Dumper;

# Parse code table and generate tree for letter transitions.
my %codes;
my %alternates;
my $table = [{}, [["","",""]]];
while (<DATA>) {
	chomp;
	my ($letters, $codes) = split(/\s+/);
	my @codes = map { [ split(/,/) ] } split(/\|/, $codes);

	# Find alternate code transitions for calculation of storage.
	# The first character can never yield more than two alternate codes, and is not considered here.
	if (@codes > 1) {
		for my $j (1..2) {
			for my $i (0..1) {
				my ($a, $b) = (substr($codes[$i][$j], -1, 1), substr($codes[($i + 1)%2][$j], 0, 1));
				$alternates{$a}{$b} = 1 if $a ne $b;
			}
		}
	}
	my $key = "codes_" . join("_or_", map { join("_", @$_) } @codes);
	my $val = join(",\n", map { "\t{\n\t\t" . join(", ", map { "\"$_\"" } @$_) . "\n\t}" } @codes);
	$codes{$key} = $val;

	for my $letter (split(/,/, $letters)) {
		my $ref = $table->[0];
		# Link each character to the next in the letter combination.
		my @c = split(//, $letter);
		my $last_c = pop(@c);
		for my $c (@c) {
			$ref->{$c} //= [ {}, undef ];
			$ref->{$c}[0] //= {};
			$ref = $ref->{$c}[0];
		}
		# The sound code for the letter combination is stored at the last character.
		$ref->{$last_c}[1] = $key;
	}
}
close(DATA);

# Find the maximum number of alternate codes in one position.
my $alt_x = $alternates{"X"};
while (my ($k, $v) = each %alternates) {
	if (defined delete $v->{"X"}) {
		for my $x (keys %$alt_x) {
			$v->{$x} = 1;
		}
	}
}
my $max_alt = (reverse sort (2, map { scalar keys %$_ } values %alternates))[0];

# The maximum number of nodes and leaves in the soundex tree.
# These are safe estimates, but in practice somewhat higher than the actual maximums.
# Note that the first character can never yield more than two alternate codes,
# hence the calculations are performed as sums of two subtrees.
my $digits = 6;
# Number of nodes (sum of geometric progression).
my $max_nodes = 2 + 2*(1 - $max_alt**($digits - 1))/(1 - $max_alt);
# Number of leaves (exponential of base number).
my $max_leaves = 2*$max_alt**($digits - 2);

print <<EOF;
/*
 * Types and lookup tables for Daitch-Mokotoff Soundex
 *
 * Copyright (c) 2021 Finance Norway
 * Author: Dag Lem <dag\@nimrod.no>
 *
 * This file is generated by daitch_mokotoff_header.pl
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE AUTHOR OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE AUTHOR OR DISTRIBUTORS HAVE BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHOR AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE AUTHOR AND DISTRIBUTORS HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */

#include <stdlib.h>

#define DM_MAX_CODE_DIGITS $digits
#define DM_MAX_ALTERNATE_CODES $max_alt
#define DM_MAX_NODES $max_nodes
#define DM_MAX_LEAVES $max_leaves
#define DM_MAX_SOUNDEX_CHARS (DM_MAX_NODES*(DM_MAX_CODE_DIGITS + 1))

typedef char dm_code[2 + 1];	/* One or two sequential code digits + NUL */
typedef dm_code dm_codes[3];	/* Start of name, before a vowel, any other */

/* Letter in input sequence */
struct dm_letter
{
	char		letter;			/* Present letter in sequence */
	struct dm_letter *letters;	/* List of possible successive letters */
	dm_codes   *codes;			/* Code sequence(s) for complete sequence */
};

/* Node in soundex code tree */
struct dm_node
{
	int			soundex_length; /* Length of generated soundex code */
	char		soundex[DM_MAX_CODE_DIGITS + 1];	/* Soundex code */
	int			is_leaf;		/* Candidate for complete soundex code */
	int			last_update;	/* Letter number for last update of node */
	char		code_digit;		/* Last code digit, 0 - 9 */

	/*
	 * One or two alternate code digits leading to this node. If there are two
	 * digits, one of them is always an 'X'. Repeated code digits and 'X' lead
	 * back to the same node.
	 */
	char		prev_code_digits[2];
	/* One or two alternate code digits moving forward. */
	char		next_code_digits[2];
	/* ORed together code index(es) used to reach current node. */
	int			prev_code_index;
	int			next_code_index;
	/* Nodes branching out from this node. */
	struct dm_node *next_nodes[DM_MAX_ALTERNATE_CODES + 1];
};

typedef struct dm_letter dm_letter;
typedef struct dm_node dm_node;

/* Codes for letter sequence at start of name, before a vowel, and any other. */
EOF

for my $key (sort keys %codes) {
	print "static dm_codes $key\[2\] =\n{\n" . $codes{$key} . "\n};\n";
}

print <<EOF;

/* Coding for alternative following letters in sequence. */
EOF

sub hash2code {
	my ($ref, $letter) = @_;

	my @letters = ();

	my $h = $ref->[0];
	for my $key (sort keys %$h) {
		$ref = $h->{$key};
		my $children = "NULL";
		if (defined $ref->[0]) {
			$children = "letter_$letter$key";
			hash2code($ref, "$letter$key");
		}
		my $codes = $ref->[1] // "NULL";
		push(@letters, "\t{\n\t\t'$key', $children, $codes\n\t}");
	}

	print "static dm_letter letter_$letter\[\] =\n{\n";
	for (@letters) {
		print "$_,\n";
	}
	print "\t{\n\t\t'\\0'\n\t}\n";
	print "};\n";
}

hash2code($table, '');


# Table adapted from https://www.jewishgen.org/InfoFiles/Soundex.html
#
# X = NC (not coded)
#
# Note that the following letters are coded with substitute letters
#
# Ą => a (use '[' for table lookup)
# Ę => e (use '\\' for table lookup)
# Ţ => t (use ']' for table lookup)
#
# The rule for "UE" below does not correspond to the table referred to above,
# however it is used by all other known implementations, including the one at
# https://www.jewishgen.org/jos/jossound.htm (try e.g. "bouey").

__DATA__
AI,AJ,AY				0,1,X
AU						0,7,X
a						X,X,6|X,X,X
A						0,X,X
B						7,7,7
CHS						5,54,54
CH						5,5,5|4,4,4
CK						5,5,5|45,45,45
CZ,CS,CSZ,CZS			4,4,4
C						5,5,5|4,4,4
DRZ,DRS					4,4,4
DS,DSH,DSZ				4,4,4
DZ,DZH,DZS				4,4,4
D,DT					3,3,3
EI,EJ,EY				0,1,X
EU						1,1,X
e						X,X,6|X,X,X
E						0,X,X
FB						7,7,7
F						7,7,7
G						5,5,5
H						5,5,X
IA,IE,IO,IU				1,X,X
I						0,X,X
J						1,X,X|4,4,4
KS						5,54,54
KH						5,5,5
K						5,5,5
L						8,8,8
MN						66,66,66
M						6,6,6
NM						66,66,66
N						6,6,6
OI,OJ,OY				0,1,X
O						0,X,X
P,PF,PH					7,7,7
Q						5,5,5
RZ,RS					94,94,94|4,4,4
R						9,9,9
SCHTSCH,SCHTSH,SCHTCH	2,4,4
SCH						4,4,4
SHTCH,SHCH,SHTSH		2,4,4
SHT,SCHT,SCHD			2,43,43
SH						4,4,4
STCH,STSCH,SC			2,4,4
STRZ,STRS,STSH			2,4,4
ST						2,43,43
SZCZ,SZCS				2,4,4
SZT,SHD,SZD,SD			2,43,43
SZ						4,4,4
S						4,4,4
TCH,TTCH,TTSCH			4,4,4
TH						3,3,3
TRZ,TRS					4,4,4
TSCH,TSH				4,4,4
TS,TTS,TTSZ,TC			4,4,4
TZ,TTZ,TZS,TSZ			4,4,4
t						3,3,3|4,4,4
T						3,3,3
UI,UJ,UY,UE				0,1,X
U						0,X,X
V						7,7,7
W						7,7,7
X						5,54,54
Y						1,X,X
ZDZ,ZDZH,ZHDZH			2,4,4
ZD,ZHD					2,43,43
ZH,ZS,ZSCH,ZSH			4,4,4
Z						4,4,4
