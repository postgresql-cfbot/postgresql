--
-- SUBSELECT
--
SELECT 1 AS one WHERE 1 IN (SELECT 1);
 one 
-----
   1
(1 row)

SELECT 1 AS zero WHERE 1 NOT IN (SELECT 1);
 zero 
------
(0 rows)

SELECT 1 AS zero WHERE 1 IN (SELECT 2);
 zero 
------
(0 rows)

-- Check grammar's handling of extra parens in assorted contexts
SELECT * FROM (SELECT 1 AS x) ss;
 x 
---
 1
(1 row)

SELECT * FROM ((SELECT 1 AS x)) ss;
 x 
---
 1
(1 row)

(SELECT 2) UNION SELECT 2;
 ?column? 
----------
        2
(1 row)

((SELECT 2)) UNION SELECT 2;
 ?column? 
----------
        2
(1 row)

SELECT ((SELECT 2) UNION SELECT 2);
 ?column? 
----------
        2
(1 row)

SELECT (((SELECT 2)) UNION SELECT 2);
 ?column? 
----------
        2
(1 row)

SELECT (SELECT ARRAY[1,2,3])[1];
 array 
-------
     1
(1 row)

SELECT ((SELECT ARRAY[1,2,3]))[2];
 array 
-------
     2
(1 row)

SELECT (((SELECT ARRAY[1,2,3])))[3];
 array 
-------
     3
(1 row)

-- Set up some simple test tables
CREATE TABLE SUBSELECT_TBL (
  f1 integer,
  f2 integer,
  f3 float
);
INSERT INTO SUBSELECT_TBL VALUES (1, 2, 3);
INSERT INTO SUBSELECT_TBL VALUES (2, 3, 4);
INSERT INTO SUBSELECT_TBL VALUES (3, 4, 5);
INSERT INTO SUBSELECT_TBL VALUES (1, 1, 1);
INSERT INTO SUBSELECT_TBL VALUES (2, 2, 2);
INSERT INTO SUBSELECT_TBL VALUES (3, 3, 3);
INSERT INTO SUBSELECT_TBL VALUES (6, 7, 8);
INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
SELECT '' AS eight, * FROM SUBSELECT_TBL;
 eight | f1 | f2 | f3 
-------+----+----+----
       |  1 |  2 |  3
       |  2 |  3 |  4
       |  3 |  4 |  5
       |  1 |  1 |  1
       |  2 |  2 |  2
       |  3 |  3 |  3
       |  6 |  7 |  8
       |  8 |  9 |   
(8 rows)

-- Uncorrelated subselects
SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT 1);
 two | Constant Select 
-----+-----------------
     |               1
     |               1
(2 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL);
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  2
     |                  3
     |                  1
     |                  2
     |                  3
(6 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
    f2 IN (SELECT f1 FROM SUBSELECT_TBL));
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  2
     |                  3
     |                  1
     |                  2
     |                  3
(6 rows)

SELECT '' AS three, f1, f2
  FROM SUBSELECT_TBL
  WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                         WHERE f3 IS NOT NULL);
 three | f1 | f2 
-------+----+----
       |  1 |  2
       |  6 |  7
       |  8 |  9
(3 rows)

-- Correlated subselects
SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1);
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            2
     |                2 |            3
     |                3 |            4
     |                1 |            1
     |                2 |            2
     |                3 |            3
(6 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN
    (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3);
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                2 |            4
     |                3 |            5
     |                1 |            1
     |                2 |            2
     |                3 |            3
(5 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
               WHERE f2 = CAST(f3 AS integer));
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            3
     |                2 |            4
     |                3 |            5
     |                6 |            8
(4 rows)

SELECT '' AS five, f1 AS "Correlated Field"
  FROM SUBSELECT_TBL
  WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                     WHERE f3 IS NOT NULL);
 five | Correlated Field 
------+------------------
      |                2
      |                3
      |                1
      |                2
      |                3
(5 rows)

--
-- Use some existing tables in the regression test
--
SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
  FROM SUBSELECT_TBL ss
  WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
                   WHERE f1 != ss.f1 AND f1 < 2147483647);
 eight | Correlated Field | Second Field 
-------+------------------+--------------
       |                2 |            4
       |                3 |            5
       |                2 |            2
       |                3 |            3
       |                6 |            8
       |                8 |             
(6 rows)

select q1, float8(count(*)) / (select count(*) from int8_tbl)
from int8_tbl group by q1 order by q1;
        q1        | ?column? 
------------------+----------
              123 |      0.4
 4567890123456789 |      0.6
(2 rows)

-- Unspecified-type literals in output columns should resolve as text
SELECT *, pg_typeof(f1) FROM
  (SELECT 'foo' AS f1 FROM generate_series(1,3)) ss ORDER BY 1;
 f1  | pg_typeof 
-----+-----------
 foo | text
 foo | text
 foo | text
(3 rows)

-- ... unless there's context to suggest differently
explain (verbose, costs off) select '42' union all select '43';
         QUERY PLAN         
----------------------------
 Append
   ->  Result
         Output: '42'::text
   ->  Result
         Output: '43'::text
(5 rows)

explain (verbose, costs off) select '42' union all select 43;
     QUERY PLAN     
--------------------
 Append
   ->  Result
         Output: 42
   ->  Result
         Output: 43
(5 rows)

-- check materialization of an initplan reference (bug #14524)
explain (verbose, costs off)
select 1 = all (select (select 1));
            QUERY PLAN             
-----------------------------------
 Result
   Output: (SubPlan 2)
   SubPlan 2
     ->  Materialize
           Output: ($0)
           InitPlan 1 (returns $0)
             ->  Result
                   Output: 1
           ->  Result
                 Output: $0
(10 rows)

select 1 = all (select (select 1));
 ?column? 
----------
 t
(1 row)

--
-- Check EXISTS simplification with LIMIT
--
explain (costs off)
select * from int4_tbl o where exists
  (select 1 from int4_tbl i where i.f1=o.f1 limit null);
             QUERY PLAN             
------------------------------------
 Hash Semi Join
   Hash Cond: (o.f1 = i.f1)
   ->  Seq Scan on int4_tbl o
   ->  Hash
         ->  Seq Scan on int4_tbl i
(5 rows)

explain (costs off)
select * from int4_tbl o where not exists
  (select 1 from int4_tbl i where i.f1=o.f1 limit 1);
             QUERY PLAN             
------------------------------------
 Hash Anti Join
   Hash Cond: (o.f1 = i.f1)
   ->  Seq Scan on int4_tbl o
   ->  Hash
         ->  Seq Scan on int4_tbl i
(5 rows)

explain (costs off)
select * from int4_tbl o where exists
  (select 1 from int4_tbl i where i.f1=o.f1 limit 0);
              QUERY PLAN              
--------------------------------------
 Seq Scan on int4_tbl o
   Filter: (SubPlan 1)
   SubPlan 1
     ->  Limit
           ->  Seq Scan on int4_tbl i
                 Filter: (f1 = o.f1)
(6 rows)

--
-- Test cases to catch unpleasant interactions between IN-join processing
-- and subquery pullup.
--
select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
 count 
-------
   100
(1 row)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
   100
(1 row)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

--
-- Test cases to check for overenthusiastic optimization of
-- "IN (SELECT DISTINCT ...)" and related cases.  Per example from
-- Luca Pireddu and Michael Fuhr.
--
CREATE TEMP TABLE foo (id integer);
CREATE TEMP TABLE bar (id1 integer, id2 integer);
INSERT INTO foo VALUES (1);
INSERT INTO bar VALUES (1, 1);
INSERT INTO bar VALUES (2, 2);
INSERT INTO bar VALUES (3, 1);
-- These cases require an extra level of distinct-ing above subquery s
SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM bar) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id1,id2 FROM bar GROUP BY id1,id2) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id1, id2 FROM bar UNION
                      SELECT id1, id2 FROM bar) AS s);
 id 
----
  1
(1 row)

-- These cases do not
SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM bar) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM bar GROUP BY id2) AS s);
 id 
----
  1
(1 row)

SELECT * FROM foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM bar UNION
                      SELECT id2 FROM bar) AS s);
 id 
----
  1
(1 row)

--
-- Test case to catch problems with multiply nested sub-SELECTs not getting
-- recalculated properly.  Per bug report from Didier Moens.
--
CREATE TABLE orderstest (
    approver_ref integer,
    po_ref integer,
    ordercanceled boolean
);
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 5, false);
INSERT INTO orderstest VALUES (66, 6, false);
INSERT INTO orderstest VALUES (66, 7, false);
INSERT INTO orderstest VALUES (66, 1, true);
INSERT INTO orderstest VALUES (66, 8, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (77, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
CREATE VIEW orders_view AS
SELECT *,
(SELECT CASE
   WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved'
 END) AS "Approved",
(SELECT CASE
 WHEN ord.ordercanceled
 THEN 'Canceled'
 ELSE
  (SELECT CASE
		WHEN ord.po_ref=1
		THEN
		 (SELECT CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END)
END) AS "Status",
(CASE
 WHEN ord.ordercanceled
 THEN 'Canceled'
 ELSE
  (CASE
		WHEN ord.po_ref=1
		THEN
		 (CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END)
END) AS "Status_OK"
FROM orderstest ord;
SELECT * FROM orders_view;
 approver_ref | po_ref | ordercanceled | Approved |  Status  | Status_OK 
--------------+--------+---------------+----------+----------+-----------
            1 |      1 | f             | ---      | ---      | ---
           66 |      5 | f             | Approved | PO       | PO
           66 |      6 | f             | Approved | PO       | PO
           66 |      7 | f             | Approved | PO       | PO
           66 |      1 | t             | Approved | Canceled | Canceled
           66 |      8 | f             | Approved | PO       | PO
           66 |      1 | f             | Approved | Approved | Approved
           77 |      1 | f             | Approved | Approved | Approved
            1 |      1 | f             | ---      | ---      | ---
           66 |      1 | f             | Approved | Approved | Approved
            1 |      1 | f             | ---      | ---      | ---
(11 rows)

DROP TABLE orderstest cascade;
NOTICE:  drop cascades to view orders_view
--
-- Test cases to catch situations where rule rewriter fails to propagate
-- hasSubLinks flag correctly.  Per example from Kyle Bateman.
--
create temp table parts (
    partnum     text,
    cost        float8
);
create temp table shipped (
    ttype       char(2),
    ordnum      int4,
    partnum     text,
    value       float8
);
create temp view shipped_view as
    select * from shipped where ttype = 'wt';
create rule shipped_view_insert as on insert to shipped_view do instead
    insert into shipped values('wt', new.ordnum, new.partnum, new.value);
insert into parts (partnum, cost) values (1, 1234.56);
insert into shipped_view (ordnum, partnum, value)
    values (0, 1, (select cost from parts where partnum = '1'));
select * from shipped_view;
 ttype | ordnum | partnum |  value  
-------+--------+---------+---------
 wt    |      0 | 1       | 1234.56
(1 row)

create rule shipped_view_update as on update to shipped_view do instead
    update shipped set partnum = new.partnum, value = new.value
        where ttype = new.ttype and ordnum = new.ordnum;
update shipped_view set value = 11
    from int4_tbl a join int4_tbl b
      on (a.f1 = (select f1 from int4_tbl c where c.f1=b.f1))
    where ordnum = a.f1;
select * from shipped_view;
 ttype | ordnum | partnum | value 
-------+--------+---------+-------
 wt    |      0 | 1       |    11
(1 row)

select f1, ss1 as relabel from
    (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
     from int4_tbl a) ss;
     f1      |  relabel   
-------------+------------
           0 | 2147607103
      123456 | 2147607103
     -123456 | 2147483647
  2147483647 | 2147483647
 -2147483647 |          0
(5 rows)

--
-- Test cases involving PARAM_EXEC parameters and min/max index optimizations.
-- Per bug report from David Sanchez i Gregori.
--
select * from (
  select max(unique1) from tenk1 as a
  where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
) ss;
 max  
------
 9997
(1 row)

select * from (
  select min(unique1) from tenk1 as a
  where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
) ss;
 min 
-----
   0
(1 row)

--
-- Test that an IN implemented using a UniquePath does unique-ification
-- with the right semantics, as per bug #4113.  (Unfortunately we have
-- no simple way to ensure that this test case actually chooses that type
-- of plan, but it does in releases 7.4-8.3.  Note that an ordering difference
-- here might mean that some other plan type is being used, rendering the test
-- pointless.)
--
create temp table numeric_table (num_col numeric);
insert into numeric_table values (1), (1.000000000000000000001), (2), (3);
create temp table float_table (float_col float8);
insert into float_table values (1), (2), (3);
select * from float_table
  where float_col in (select num_col from numeric_table);
 float_col 
-----------
         1
         2
         3
(3 rows)

select * from numeric_table
  where num_col in (select float_col from float_table);
         num_col         
-------------------------
                       1
 1.000000000000000000001
                       2
                       3
(4 rows)

--
-- Test case for bug #4290: bogus calculation of subplan param sets
--
create temp table ta (id int primary key, val int);
insert into ta values(1,1);
insert into ta values(2,2);
create temp table tb (id int primary key, aval int);
insert into tb values(1,1);
insert into tb values(2,1);
insert into tb values(3,2);
insert into tb values(4,2);
create temp table tc (id int primary key, aid int);
insert into tc values(1,1);
insert into tc values(2,2);
select
  ( select min(tb.id) from tb
    where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_id
from tc;
 min_tb_id 
-----------
         1
         3
(2 rows)

--
-- Test case for 8.3 "failed to locate grouping columns" bug
--
create temp table t1 (f1 numeric(14,0), f2 varchar(30));
select * from
  (select distinct f1, f2, (select f2 from t1 x where x.f1 = up.f1) as fs
   from t1 up) ss
group by f1,f2,fs;
 f1 | f2 | fs 
----+----+----
(0 rows)

--
-- Test case for bug #5514 (mishandling of whole-row Vars in subselects)
--
create temp table table_a(id integer);
insert into table_a values (42);
create temp view view_a as select * from table_a;
select view_a from view_a;
 view_a 
--------
 (42)
(1 row)

select (select view_a) from view_a;
 view_a 
--------
 (42)
(1 row)

select (select (select view_a)) from view_a;
 view_a 
--------
 (42)
(1 row)

select (select (a.*)::text) from view_a a;
  a   
------
 (42)
(1 row)

--
-- Check that whole-row Vars reading the result of a subselect don't include
-- any junk columns therein
--
select q from (select max(f1) from int4_tbl group by f1 order by f1) q;
       q       
---------------
 (-2147483647)
 (-123456)
 (0)
 (123456)
 (2147483647)
(5 rows)

with q as (select max(f1) from int4_tbl group by f1 order by f1)
  select q from q;
       q       
---------------
 (-2147483647)
 (-123456)
 (0)
 (123456)
 (2147483647)
(5 rows)

--
-- Test case for sublinks pulled up into joinaliasvars lists in an
-- inherited update/delete query
--
begin;  --  this shouldn't delete anything, but be safe
delete from road
where exists (
  select 1
  from
    int4_tbl cross join
    ( select f1, array(select q1 from int8_tbl) as arr
      from text_tbl ) ss
  where road.name = ss.f1 );
rollback;
--
-- Test case for sublinks pushed down into subselects via join alias expansion
--
select
  (select sq1) as qq1
from
  (select exists(select 1 from int4_tbl where f1 = q2) as sq1, 42 as dummy
   from int8_tbl) sq0
  join
  int4_tbl i4 on dummy = i4.f1;
 qq1 
-----
(0 rows)

--
-- Test case for subselect within UPDATE of INSERT...ON CONFLICT DO UPDATE
--
create temp table upsert(key int4 primary key, val text);
insert into upsert values(1, 'val') on conflict (key) do update set val = 'not seen';
insert into upsert values(1, 'val') on conflict (key) do update set val = 'seen with subselect ' || (select f1 from int4_tbl where f1 != 0 limit 1)::text;
select * from upsert;
 key |            val             
-----+----------------------------
   1 | seen with subselect 123456
(1 row)

with aa as (select 'int4_tbl' u from int4_tbl limit 1)
insert into upsert values (1, 'x'), (999, 'y')
on conflict (key) do update set val = (select u from aa)
returning *;
 key |   val    
-----+----------
   1 | int4_tbl
 999 | y
(2 rows)

--
-- Test case for cross-type partial matching in hashed subplan (bug #7597)
--
create temp table outer_7597 (f1 int4, f2 int4);
insert into outer_7597 values (0, 0);
insert into outer_7597 values (1, 0);
insert into outer_7597 values (0, null);
insert into outer_7597 values (1, null);
create temp table inner_7597(c1 int8, c2 int8);
insert into inner_7597 values(0, null);
select * from outer_7597 where (f1, f2) not in (select * from inner_7597);
 f1 | f2 
----+----
  1 |  0
  1 |   
(2 rows)

--
-- Similar test case using text that verifies that collation
-- information is passed through by execTuplesEqual() in nodeSubplan.c
-- (otherwise it would error in texteq())
--
create temp table outer_text (f1 text, f2 text);
insert into outer_text values ('a', 'a');
insert into outer_text values ('b', 'a');
insert into outer_text values ('a', null);
insert into outer_text values ('b', null);
create temp table inner_text (c1 text, c2 text);
insert into inner_text values ('a', null);
select * from outer_text where (f1, f2) not in (select * from inner_text);
 f1 | f2 
----+----
 b  | a
 b  | 
(2 rows)

--
-- Test case for premature memory release during hashing of subplan output
--
select '1'::text in (select '1'::name union all select '1'::name);
 ?column? 
----------
 t
(1 row)

--
-- Test case for planner bug with nested EXISTS handling
--
select a.thousand from tenk1 a, tenk1 b
where a.thousand = b.thousand
  and exists ( select 1 from tenk1 c where b.hundred = c.hundred
                   and not exists ( select 1 from tenk1 d
                                    where a.thousand = d.thousand ) );
 thousand 
----------
(0 rows)

--
-- Check that nested sub-selects are not pulled up if they contain volatiles
--
explain (verbose, costs off)
  select x, x from
    (select (select now()) as x from (values(1),(2)) v(y)) ss;
        QUERY PLAN         
---------------------------
 Values Scan on "*VALUES*"
   Output: $0, $1
   InitPlan 1 (returns $0)
     ->  Result
           Output: now()
   InitPlan 2 (returns $1)
     ->  Result
           Output: now()
(8 rows)

explain (verbose, costs off)
  select x, x from
    (select (select random()) as x from (values(1),(2)) v(y)) ss;
            QUERY PLAN            
----------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.x
   ->  Values Scan on "*VALUES*"
         Output: $0
         InitPlan 1 (returns $0)
           ->  Result
                 Output: random()
(7 rows)

explain (verbose, costs off)
  select x, x from
    (select (select now() where y=y) as x from (values(1),(2)) v(y)) ss;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Values Scan on "*VALUES*"
   Output: (SubPlan 1), (SubPlan 2)
   SubPlan 1
     ->  Result
           Output: now()
           One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
   SubPlan 2
     ->  Result
           Output: now()
           One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
(10 rows)

explain (verbose, costs off)
  select x, x from
    (select (select random() where y=y) as x from (values(1),(2)) v(y)) ss;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.x
   ->  Values Scan on "*VALUES*"
         Output: (SubPlan 1)
         SubPlan 1
           ->  Result
                 Output: random()
                 One-Time Filter: ("*VALUES*".column1 = "*VALUES*".column1)
(8 rows)

--
-- Check we don't misoptimize a NOT IN where the subquery returns no rows.
--
create temp table notinouter (a int);
create temp table notininner (b int not null);
insert into notinouter values (null), (1);
select * from notinouter where a not in (select b from notininner);
 a 
---
  
 1
(2 rows)

--
-- Check we behave sanely in corner case of empty SELECT list (bug #8648)
--
create temp table nocolumns();
select exists(select * from nocolumns);
 exists 
--------
 f
(1 row)

--
-- Check behavior with a SubPlan in VALUES (bug #14924)
--
select val.x
  from generate_series(1,10) as s(i),
  lateral (
    values ((select s.i + 1)), (s.i + 101)
  ) as val(x)
where s.i < 10 and (select val.x) < 110;
  x  
-----
   2
 102
   3
 103
   4
 104
   5
 105
   6
 106
   7
 107
   8
 108
   9
 109
  10
(17 rows)

--
-- Check sane behavior with nested IN SubLinks
--
explain (verbose, costs off)
select * from int4_tbl where
  (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
  (select ten from tenk1 b);
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop Semi Join
   Output: int4_tbl.f1
   Join Filter: (CASE WHEN (hashed SubPlan 1) THEN int4_tbl.f1 ELSE NULL::integer END = b.ten)
   ->  Seq Scan on public.int4_tbl
         Output: int4_tbl.f1
   ->  Seq Scan on public.tenk1 b
         Output: b.unique1, b.unique2, b.two, b.four, b.ten, b.twenty, b.hundred, b.thousand, b.twothousand, b.fivethous, b.tenthous, b.odd, b.even, b.stringu1, b.stringu2, b.string4
   SubPlan 1
     ->  Index Only Scan using tenk1_unique1 on public.tenk1 a
           Output: a.unique1
(10 rows)

select * from int4_tbl where
  (case when f1 in (select unique1 from tenk1 a) then f1 else null end) in
  (select ten from tenk1 b);
 f1 
----
  0
(1 row)

--
-- Check for incorrect optimization when IN subquery contains a SRF
--
explain (verbose, costs off)
select * from int4_tbl o where (f1, f1) in
  (select f1, generate_series(1,50) / 10 g from int4_tbl i group by f1);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Nested Loop Semi Join
   Output: o.f1
   Join Filter: (o.f1 = "ANY_subquery".f1)
   ->  Seq Scan on public.int4_tbl o
         Output: o.f1
   ->  Materialize
         Output: "ANY_subquery".f1, "ANY_subquery".g
         ->  Subquery Scan on "ANY_subquery"
               Output: "ANY_subquery".f1, "ANY_subquery".g
               Filter: ("ANY_subquery".f1 = "ANY_subquery".g)
               ->  Result
                     Output: i.f1, ((generate_series(1, 50)) / 10)
                     ->  ProjectSet
                           Output: generate_series(1, 50), i.f1
                           ->  HashAggregate
                                 Output: i.f1
                                 Group Key: i.f1
                                 ->  Seq Scan on public.int4_tbl i
                                       Output: i.f1
(19 rows)

select * from int4_tbl o where (f1, f1) in
  (select f1, generate_series(1,50) / 10 g from int4_tbl i group by f1);
 f1 
----
  0
(1 row)

--
-- check for over-optimization of whole-row Var referencing an Append plan
--
select (select q from
         (select 1,2,3 where f1 > 0
          union all
          select 4,5,6.0 where f1 <= 0
         ) q )
from int4_tbl;
     q     
-----------
 (4,5,6.0)
 (1,2,3)
 (4,5,6.0)
 (1,2,3)
 (4,5,6.0)
(5 rows)

--
-- Check that volatile quals aren't pushed down past a DISTINCT:
-- nextval() should not be called more than the nominal number of times
--
create temp sequence ts1;
select * from
  (select distinct ten from tenk1) ss
  where ten < 10 + nextval('ts1')
  order by 1;
 ten 
-----
   0
   1
   2
   3
   4
   5
   6
   7
   8
   9
(10 rows)

select nextval('ts1');
 nextval 
---------
      11
(1 row)

--
-- Check that volatile quals aren't pushed down past a set-returning function;
-- while a nonvolatile qual can be, if it doesn't reference the SRF.
--
create function tattle(x int, y int) returns bool
volatile language plpgsql as $$
begin
  raise notice 'x = %, y = %', x, y;
  return x > y;
end$$;
explain (verbose, costs off)
select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
                        QUERY PLAN                        
----------------------------------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.u
   Filter: tattle(ss.x, 8)
   ->  ProjectSet
         Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
         ->  Result
(6 rows)

select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
NOTICE:  x = 9, y = 8
 x | u  
---+----
 9 |  1
 9 |  2
 9 |  3
 9 | 11
 9 | 12
 9 | 13
(6 rows)

-- if we pretend it's stable, we get different results:
alter function tattle(x int, y int) stable;
explain (verbose, costs off)
select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
                     QUERY PLAN                     
----------------------------------------------------
 ProjectSet
   Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
   ->  Result
         One-Time Filter: tattle(9, 8)
(4 rows)

select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, 8);
NOTICE:  x = 9, y = 8
 x | u  
---+----
 9 |  1
 9 |  2
 9 |  3
 9 | 11
 9 | 12
 9 | 13
(6 rows)

-- although even a stable qual should not be pushed down if it references SRF
explain (verbose, costs off)
select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, u);
                        QUERY PLAN                        
----------------------------------------------------------
 Subquery Scan on ss
   Output: ss.x, ss.u
   Filter: tattle(ss.x, ss.u)
   ->  ProjectSet
         Output: 9, unnest('{1,2,3,11,12,13}'::integer[])
         ->  Result
(6 rows)

select * from
  (select 9 as x, unnest(array[1,2,3,11,12,13]) as u) ss
  where tattle(x, u);
NOTICE:  x = 9, y = 1
NOTICE:  x = 9, y = 2
NOTICE:  x = 9, y = 3
NOTICE:  x = 9, y = 11
NOTICE:  x = 9, y = 12
NOTICE:  x = 9, y = 13
 x | u 
---+---
 9 | 1
 9 | 2
 9 | 3
(3 rows)

drop function tattle(x int, y int);
--
-- Test that LIMIT can be pushed to SORT through a subquery that just projects
-- columns.  We check for that having happened by looking to see if EXPLAIN
-- ANALYZE shows that a top-N sort was used.  We must suppress or filter away
-- all the non-invariant parts of the EXPLAIN ANALYZE output.
--
create table sq_limit (pk int primary key, c1 int, c2 int);
insert into sq_limit values
    (1, 1, 1),
    (2, 2, 2),
    (3, 3, 3),
    (4, 4, 4),
    (5, 1, 1),
    (6, 2, 2),
    (7, 3, 3),
    (8, 4, 4);
create function explain_sq_limit() returns setof text language plpgsql as
$$
declare ln text;
begin
    for ln in
        explain (analyze, summary off, timing off, costs off)
        select * from (select pk,c2 from sq_limit order by c1,pk) as x limit 3
    loop
        ln := regexp_replace(ln, 'Memory: \S*',  'Memory: xxx');
        -- this case might occur if force_parallel_mode is on:
        ln := regexp_replace(ln, 'Worker 0:  Sort Method',  'Sort Method');
        return next ln;
    end loop;
end;
$$;
select * from explain_sq_limit();
                        explain_sq_limit                        
----------------------------------------------------------------
 Limit (actual rows=3 loops=1)
   ->  Subquery Scan on x (actual rows=3 loops=1)
         ->  Sort (actual rows=3 loops=1)
               Sort Key: sq_limit.c1, sq_limit.pk
               Sort Method: top-N heapsort  Memory: xxx
               ->  Seq Scan on sq_limit (actual rows=8 loops=1)
(6 rows)

select * from (select pk,c2 from sq_limit order by c1,pk) as x limit 3;
 pk | c2 
----+----
  1 |  1
  5 |  1
  2 |  2
(3 rows)

drop function explain_sq_limit();
drop table sq_limit;
--
-- Ensure that backward scan direction isn't propagated into
-- expression subqueries (bug #15336)
--
begin;
declare c1 scroll cursor for
 select * from generate_series(1,4) i
  where i <> all (values (2),(3));
move forward all in c1;
fetch backward all in c1;
 i 
---
 4
 1
(2 rows)

commit;
--
-- Tests for CTE inlining behavior
--
-- Basic subquery that can be inlined
explain (verbose, costs off)
with x as (select * from (select f1 from subselect_tbl) ss)
select * from x where f1 = 1;
            QUERY PLAN            
----------------------------------
 Seq Scan on public.subselect_tbl
   Output: subselect_tbl.f1
   Filter: (subselect_tbl.f1 = 1)
(3 rows)

-- Explicitly request materialization
explain (verbose, costs off)
with x as materialized (select * from (select f1 from subselect_tbl) ss)
select * from x where f1 = 1;
                QUERY PLAN                
------------------------------------------
 CTE Scan on x
   Output: x.f1
   Filter: (x.f1 = 1)
   CTE x
     ->  Seq Scan on public.subselect_tbl
           Output: subselect_tbl.f1
(6 rows)

-- Stable functions are safe to inline
explain (verbose, costs off)
with x as (select * from (select f1, now() from subselect_tbl) ss)
select * from x where f1 = 1;
            QUERY PLAN             
-----------------------------------
 Seq Scan on public.subselect_tbl
   Output: subselect_tbl.f1, now()
   Filter: (subselect_tbl.f1 = 1)
(3 rows)

-- Volatile functions prevent inlining
explain (verbose, costs off)
with x as (select * from (select f1, random() from subselect_tbl) ss)
select * from x where f1 = 1;
                  QUERY PLAN                  
----------------------------------------------
 CTE Scan on x
   Output: x.f1, x.random
   Filter: (x.f1 = 1)
   CTE x
     ->  Seq Scan on public.subselect_tbl
           Output: subselect_tbl.f1, random()
(6 rows)

-- SELECT FOR UPDATE cannot be inlined
explain (verbose, costs off)
with x as (select * from (select f1 from subselect_tbl for update) ss)
select * from x where f1 = 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 CTE Scan on x
   Output: x.f1
   Filter: (x.f1 = 1)
   CTE x
     ->  Subquery Scan on ss
           Output: ss.f1
           ->  LockRows
                 Output: subselect_tbl.f1, subselect_tbl.ctid
                 ->  Seq Scan on public.subselect_tbl
                       Output: subselect_tbl.f1, subselect_tbl.ctid
(10 rows)

-- Multiply-referenced CTEs are inlined only when requested
explain (verbose, costs off)
with x as (select * from (select f1, now() as n from subselect_tbl) ss)
select * from x, x x2 where x.n = x2.n;
                QUERY PLAN                 
-------------------------------------------
 Merge Join
   Output: x.f1, x.n, x2.f1, x2.n
   Merge Cond: (x.n = x2.n)
   CTE x
     ->  Seq Scan on public.subselect_tbl
           Output: subselect_tbl.f1, now()
   ->  Sort
         Output: x.f1, x.n
         Sort Key: x.n
         ->  CTE Scan on x
               Output: x.f1, x.n
   ->  Sort
         Output: x2.f1, x2.n
         Sort Key: x2.n
         ->  CTE Scan on x x2
               Output: x2.f1, x2.n
(16 rows)

explain (verbose, costs off)
with x as not materialized (select * from (select f1, now() as n from subselect_tbl) ss)
select * from x, x x2 where x.n = x2.n;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Result
   Output: subselect_tbl.f1, now(), subselect_tbl_1.f1, now()
   One-Time Filter: (now() = now())
   ->  Nested Loop
         Output: subselect_tbl.f1, subselect_tbl_1.f1
         ->  Seq Scan on public.subselect_tbl
               Output: subselect_tbl.f1, subselect_tbl.f2, subselect_tbl.f3
         ->  Materialize
               Output: subselect_tbl_1.f1
               ->  Seq Scan on public.subselect_tbl subselect_tbl_1
                     Output: subselect_tbl_1.f1
(11 rows)

-- Check handling of outer references
explain (verbose, costs off)
with x as (select * from int4_tbl)
select * from (with y as (select * from x) select * from y) ss;
         QUERY PLAN          
-----------------------------
 Seq Scan on public.int4_tbl
   Output: int4_tbl.f1
(2 rows)

explain (verbose, costs off)
with x as materialized (select * from int4_tbl)
select * from (with y as (select * from x) select * from y) ss;
             QUERY PLAN              
-------------------------------------
 CTE Scan on x
   Output: x.f1
   CTE x
     ->  Seq Scan on public.int4_tbl
           Output: int4_tbl.f1
(5 rows)

-- Ensure that we inline the currect CTE when there are
-- multiple CTEs with the same name
explain (verbose, costs off)
with x as (select 1 as y)
select * from (with x as (select 2 as y) select * from x) ss;
 QUERY PLAN  
-------------
 Result
   Output: 2
(2 rows)

-- Row marks are not pushed into CTEs
explain (verbose, costs off)
with x as (select * from subselect_tbl)
select * from x for update;
                           QUERY PLAN                           
----------------------------------------------------------------
 Seq Scan on public.subselect_tbl
   Output: subselect_tbl.f1, subselect_tbl.f2, subselect_tbl.f3
(2 rows)

-- test NON IN to ANTI JOIN conversion
CREATE TABLE s (u INTEGER NOT NULL, n INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
insert into s (u, n, nn, p)
    select
    generate_series(1,3) as u,
	generate_series(1,3) as n,
	generate_series(1,3) as nn,
	'foo' as p;
insert into s values(1000002, 1000002, 1000002, 'foofoo');
UPDATE s set n = NULL WHERE n = 3;
analyze s;
CREATE TABLE l (u INTEGER NOT NULL, n INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
insert into l (u, n, nn, p)
	select
    generate_series(1,10000 ) as u,
	generate_series(1,10000 ) as n,
	generate_series(1,10000 ) as nn,
	'bar' as p;
UPDATE l set n = NULL WHERE n = 7;
CREATE UNIQUE INDEX l_u ON l (u);
CREATE INDEX l_n ON l (n);
CREATE INDEX l_nn ON l (nn);
analyze l;
CREATE TABLE s1 (u INTEGER NOT NULL, n INTEGER NULL, n1 INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
insert into s1 (u, n, n1, nn, p)
    select
    generate_series(1,3) as u,
	generate_series(1,3) as n,
	generate_series(1,3) as n1,
	generate_series(1,3) as nn,
	'foo' as p;
insert into s1 values(1000003, 1000003, 1000003, 1000003, 'foofoo');
insert into s1 values(1003, 1003, 1003, 1003, 'foofoo');
UPDATE s1 set n = NULL WHERE n = 3;
UPDATE s1 set n1 = NULL WHERE n = 2;
UPDATE s1 set n1 = NULL WHERE n1 = 3;
analyze s1;
CREATE TABLE empty (u INTEGER NOT NULL, n INTEGER NULL, nn INTEGER NOT NULL, p VARCHAR(128) NULL);
analyze empty;
-- set work_mem to 64KB so that NOT IN to ANTI JOIN optimization will kick in
set work_mem = 64;
-- correctness test 1: inner empty, return every thing from outer including NULL
explain (costs false) select * from s where n not in (select n from empty);
             QUERY PLAN             
------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Seq Scan on empty
(4 rows)

select * from s where n not in (select n from empty);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

-- correctness test 2: inner has NULL, return empty result
explain (costs false) select * from s where n not in (select n from l);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where n not in (select n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

-- correctness test 3: inner non-null, result has no NULL
explain (costs false) select * from s where n not in (select u from l);
                  QUERY PLAN                   
-----------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Index Only Scan using l_u on l
         Index Cond: (u = s.n)
(7 rows)

select * from s where n not in (select u from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

-- correctness test 4: inner has predicate
explain (costs false) select * from s where n not in (select n from l where u > 7);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (u > 7)
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 7)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(14 rows)

select * from s where n not in (select n from l where u > 7);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
(3 rows)

-- correctness test 5: multi-expression, (2, 2, null, 2, foo) should be in the result
explain (costs false) select * from s1 where (n,n1) not in (select u,nn from l where u >= 3);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s1.n = l.u) AND (s1.n1 = l.nn)) IS NOT FALSE)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Seq Scan on l
               Filter: (u >= 3)
(6 rows)

select * from s1 where (n,n1) not in (select u,nn from l where u >= 3);
    u    |    n    |   n1    |   nn    |   p    
---------+---------+---------+---------+--------
       1 |       1 |       1 |       1 | foo
 1000003 | 1000003 | 1000003 | 1000003 | foofoo
       2 |       2 |         |       2 | foo
(3 rows)

-- correctness test 6: multi-expression, (3, null, null, 3, foo) should not be in the result
explain (costs false) select * from s1 where (n,n1) not in (select u,nn from l where u > 0);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s1.n = l.u) AND (s1.n1 = l.nn)) IS NOT FALSE)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Seq Scan on l
               Filter: (u > 0)
(6 rows)

select * from s1 where (n,n1) not in (select u,nn from l where u > 0);
    u    |    n    |   n1    |   nn    |   p    
---------+---------+---------+---------+--------
 1000003 | 1000003 | 1000003 | 1000003 | foofoo
(1 row)

-- correctness test 6: multi-expression, (3, null, null, 3, foo) should be in the result
explain (costs false) select * from s1 where (n,n1) not in (select u,nn from l where u < 0);
             QUERY PLAN             
------------------------------------
 Seq Scan on s1
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Index Scan using l_u on l
           Index Cond: (u < 0)
(5 rows)

select * from s1 where (n,n1) not in (select u,nn from l where u < 0);
    u    |    n    |   n1    |   nn    |   p    
---------+---------+---------+---------+--------
       1 |       1 |       1 |       1 | foo
 1000003 | 1000003 | 1000003 | 1000003 | foofoo
    1003 |    1003 |    1003 |    1003 | foofoo
       2 |       2 |         |       2 | foo
       3 |         |         |       3 | foo
(5 rows)

-- test using hashed subplan when inner fits in work_mem
explain (costs false) select * from l where n not in (select n from s);
             QUERY PLAN             
------------------------------------
 Seq Scan on l
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Seq Scan on s
(4 rows)

select * from l where n not in (select n from s);
 u | n | nn | p 
---+---+----+---
(0 rows)

-- test single expression
explain (costs false) select * from s where n not in (select n from l);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where n not in (select n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where u not in (select u from l);
              QUERY PLAN              
--------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Only Scan using l_u on l
         Index Cond: (u = s.u)
(4 rows)

select * from s where u not in (select u from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where 3*n not in (select n from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: (((3 * n) IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: (((3 * s.n) = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = (3 * s.n))
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where 3*n not in (select n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select 3*n from l);
                        QUERY PLAN                         
-----------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((s.n = (3 * l.n)) OR ((3 * l.n) IS NULL))
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Materialize
         ->  Seq Scan on l
(8 rows)

select * from s where n not in (select 3*n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

-- test single expression with predicates
explain (costs false) select * from s where n not in (select n from l where u > 0);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (u > 0)
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 0)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(14 rows)

select * from s where n not in (select n from l where u > 0);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l where u > 100);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (u > 100)
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 100)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(14 rows)

select * from s where n not in (select n from l where u > 100);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
(3 rows)

-- test multi expression
explain (costs false) select * from s where (n,u) not in (select n,u from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_u on l
         Index Cond: (u = s.u)
         Filter: ((s.n = n) OR (n IS NULL) OR (s.n IS NULL))
(5 rows)

select * from s where (n,u) not in (select n,u from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (u, nn) not in (select u, nn from l);
            QUERY PLAN            
----------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: (s.u = u)
(5 rows)

select * from s where (u, nn) not in (select u, nn from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u) not in (select u,n from l);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.u = n) OR (n IS NULL))
         Filter: ((s.n = u) OR (s.n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.u)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where (n,u) not in (select u,n from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: (((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1000);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((u > 1000) AND ((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1000);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l where u > 0);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((u > 0) AND ((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l where u > 0);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1);
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((u > 1) AND ((s.n = u) OR (s.n IS NULL)) AND ((s.u = n) OR (n IS NULL)))
(5 rows)

select * from s where (n,u,nn) not in (select u,n,nn from l where u > 1);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
 1000002 | 1000002 | 1000002 | foofoo
(2 rows)

-- test multi-table
explain (costs false) select count(*) from s, l where s.n not in (select n from l);
                          QUERY PLAN                          
--------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
                     Filter: ((n IS NOT NULL) OR (NOT $0))
               ->  Bitmap Heap Scan on l l_1
                     Recheck Cond: ((s.n = n) OR (n IS NULL))
                     ->  BitmapOr
                           ->  Bitmap Index Scan on l_n
                                 Index Cond: (n = s.n)
                           ->  Bitmap Index Scan on l_n
                                 Index Cond: (n IS NULL)
         ->  Seq Scan on l
(15 rows)

select count(*) from s, l where s.n not in (select n from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s, l where s.nn not in (select nn from l);
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
               ->  Index Only Scan using l_nn on l l_1
                     Index Cond: (nn = s.nn)
         ->  Seq Scan on l
(7 rows)

select count(*) from s, l where s.nn not in (select nn from l);
 count 
-------
 10000
(1 row)

-- test null padded results from outer join
explain (costs false) select * from s where n not in (select s.nn from l left join s on l.nn = s.nn);
                     QUERY PLAN                      
-----------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((s.n = s_1.nn) OR (s_1.nn IS NULL))
   InitPlan 1 (returns $0)
     ->  Nested Loop Left Join
           Join Filter: (l_1.nn = s_2.nn)
           ->  Seq Scan on l l_1
           ->  Materialize
                 ->  Seq Scan on s s_2
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Hash Left Join
         Hash Cond: (l.nn = s_1.nn)
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s s_1
(15 rows)

select * from s where n not in (select s.nn from l left join s on l.nn = s.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select s.nn from s right join l on s.nn = l.nn);
                     QUERY PLAN                      
-----------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((s.n = s_1.nn) OR (s_1.nn IS NULL))
   InitPlan 1 (returns $0)
     ->  Nested Loop Left Join
           Join Filter: (s_2.nn = l_1.nn)
           ->  Seq Scan on l l_1
           ->  Materialize
                 ->  Seq Scan on s s_2
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Hash Left Join
         Hash Cond: (l.nn = s_1.nn)
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s s_1
(15 rows)

select * from s where n not in (select s.nn from s right join l on s.nn = l.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where l.nn not in (select nn from s);
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         ->  Seq Scan on l
               Filter: (NOT (hashed SubPlan 1))
               SubPlan 1
                 ->  Seq Scan on s s_1
         ->  Hash
               ->  Seq Scan on s
(9 rows)

select count(*) from s right join l on s.nn = l.nn where l.nn not in (select nn from s);
 count 
-------
  9997
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from s);
                QUERY PLAN                
------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         Filter: (NOT (hashed SubPlan 1))
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s
         SubPlan 1
           ->  Seq Scan on s s_1
(9 rows)

select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from s);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn=l.nn where l.nn not in (select l.nn from l left join s on l.nn = s.nn);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: (s.nn = l.nn)
         ->  Hash Anti Join
               Hash Cond: (l.nn = l_1.nn)
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Left Join
                           Hash Cond: (l_1.nn = s_1.nn)
                           ->  Seq Scan on l l_1
                           ->  Hash
                                 ->  Seq Scan on s s_1
         ->  Seq Scan on s
(13 rows)

select count(*) from s right join l on s.nn=l.nn where l.nn not in (select l.nn from l left join s on l.nn = s.nn);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn=l.nn where s.nn not in (select s.nn from l left join s on l.nn = s.nn);
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Nested Loop Left Join
           Join Filter: (l_2.nn = s_2.nn)
           ->  Seq Scan on l l_2
           ->  Materialize
                 ->  Seq Scan on s s_2
   ->  Nested Loop Anti Join
         Join Filter: ((s.nn = s_1.nn) OR (s_1.nn IS NULL))
         ->  Hash Left Join
               Hash Cond: (l.nn = s.nn)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Seq Scan on s
         ->  Materialize
               ->  Hash Left Join
                     Hash Cond: (l_1.nn = s_1.nn)
                     ->  Seq Scan on l l_1
                     ->  Hash
                           ->  Seq Scan on s s_1
(21 rows)

select count(*) from s right join l on s.nn=l.nn where s.nn not in (select s.nn from l left join s on l.nn = s.nn);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s left join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Seq Scan on s1
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(11 rows)

select count(*) from s left join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s left join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Left Join
               Hash Cond: (l.u = s.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Right Join
                           Hash Cond: (s1.u = s.u)
                           ->  Seq Scan on s1
                           ->  Hash
                                 ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(17 rows)

select count(*) from s left join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s left join s1 on s.u=s1.u left join l on s.u=l.u where s.nn not in (select nn from l);
                    QUERY PLAN                     
---------------------------------------------------
 Aggregate
   ->  Nested Loop Left Join
         Join Filter: (s.u = s1.u)
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
               ->  Index Only Scan using l_nn on l
                     Index Cond: (nn = s.nn)
         ->  Seq Scan on s1
(8 rows)

select count(*) from s left join s1 on s.u=s1.u left join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     1
(1 row)

explain (costs false) select count(*) from s right join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop
               Join Filter: (s.u = s1.u)
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Seq Scan on s1
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(11 rows)

select count(*) from s right join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Left Join
               Hash Cond: (l.u = s.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (s1.u = s.u)
                           ->  Seq Scan on s1
                           ->  Hash
                                 ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(17 rows)

select * from s join s1 on s.u=s1.u right join l on s.u=l.u where s.nn not in (select nn from l);
 u | n | nn | p | u | n | n1 | nn | p | u | n | nn | p 
---+---+----+---+---+---+----+----+---+---+---+----+---
(0 rows)

explain (costs false) select count(*) from s full join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Seq Scan on s1
         ->  Index Only Scan using l_u on l
               Index Cond: (u = s.u)
(11 rows)

select count(*) from s full join s1 on s.u=s1.u join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s join s1 on s.u=s1.u full join l on s.u=l.u where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Full Join
               Hash Cond: (l.u = s.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (s1.u = s.u)
                           ->  Seq Scan on s1
                           ->  Hash
                                 ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(17 rows)

select count(*) from s join s1 on s.u=s1.u full join l on s.u=l.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn left join s1 on l.nn=s1.nn);
                    QUERY PLAN                     
---------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Nested Loop Left Join
         Join Filter: (l.nn = s1.nn)
         ->  Nested Loop Left Join
               Join Filter: (l.nn = s_1.nn)
               ->  Index Only Scan using l_nn on l
                     Index Cond: (nn = s.nn)
               ->  Seq Scan on s s_1
         ->  Seq Scan on s1
(10 rows)

select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn left join s1 on l.nn=s1.nn);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn right join s1 on l.nn=s1.nn);
                     QUERY PLAN                      
-----------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.nn = s_1.nn)
           ->  Nested Loop Left Join
                 ->  Seq Scan on s1
                 ->  Index Only Scan using l_nn on l
                       Index Cond: (nn = s1.nn)
           ->  Materialize
                 ->  Seq Scan on s s_1
(11 rows)

select * from s where s.nn not in (select l.nn from l left join s on l.nn=s.nn right join s1 on l.nn=s1.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l left join s on l.nn = s.nn);
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Nested Loop Left Join
         Join Filter: (l.nn = s_1.nn)
         ->  Index Scan using l_nn on l
               Index Cond: (nn = s.nn)
               Filter: (((s.n = n) OR (n IS NULL) OR (s.n IS NULL)) AND (s.u = u))
         ->  Seq Scan on s s_1
(8 rows)

select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l left join s on l.nn = s.nn);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l right join s on l.nn = s.nn);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
           ->  Index Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
(7 rows)

select * from s where (n,u,nn) not in (select l.n,l.u,l.nn from l left join s on l.nn = s.nn);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

--test reduce outer joins from outer query
explain (costs false) select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.nn = l_1.nn)
         ->  Hash Left Join
               Hash Cond: (l.nn = s.nn)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Seq Scan on s
         ->  Hash
               ->  Seq Scan on l l_1
(13 rows)

select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l) and s.u>0;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop Anti Join
               ->  Seq Scan on s
                     Filter: (u > 0)
               ->  Index Only Scan using l_nn on l l_1
                     Index Cond: (nn = s.nn)
         ->  Index Only Scan using l_nn on l
               Index Cond: (nn = s.nn)
(9 rows)

select count(*) from s right join l on s.nn = l.nn where s.nn not in (select nn from l) and s.u>0;
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select nn from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (s.u = s1.u)
         ->  Nested Loop
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Index Only Scan using l_nn on l l_1
                           Index Cond: (nn = s.nn)
               ->  Index Only Scan using l_nn on l
                     Index Cond: (nn = s.nn)
         ->  Seq Scan on s1
(11 rows)

select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn right join s1 on s.u = s1.u where s.nn not in (select nn from l);
                          QUERY PLAN                           
---------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Anti Join
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               Filter: ((s.nn IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on s1
               ->  Materialize
                     ->  Nested Loop
                           ->  Seq Scan on s
                           ->  Index Only Scan using l_nn on l
                                 Index Cond: (nn = s.nn)
         ->  Index Only Scan using l_nn on l l_1
               Index Cond: (nn = s.nn)
(15 rows)

select count(*) from s right join l on s.nn = l.nn right join s1 on s.u = s1.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select nn from l);
                          QUERY PLAN                          
--------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Left Join
         Join Filter: (s.u = s1.u)
         ->  Hash Anti Join
               Hash Cond: (s.nn = l_1.nn)
               ->  Hash Left Join
                     Hash Cond: (l.nn = s.nn)
                     Filter: ((s.nn IS NOT NULL) OR (NOT $0))
                     ->  Seq Scan on l
                     ->  Hash
                           ->  Seq Scan on s
               ->  Hash
                     ->  Seq Scan on l l_1
         ->  Seq Scan on s1
(16 rows)

select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select nn from l);
 count 
-------
     0
(1 row)

--test reduce outer joins from subquery
explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn);
                  QUERY PLAN                   
-----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
(7 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where l.u > 9);
                QUERY PLAN                 
-------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
                 Filter: (u > 9)
(8 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where l.u > 9);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where s.u > 9);
                  QUERY PLAN                   
-----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
                 Filter: (u > 9)
           ->  Index Only Scan using l_nn on l
                 Index Cond: (nn = s_1.nn)
(8 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn where s.u > 9);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           Join Filter: (l.n = s1.n)
           ->  Seq Scan on s1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Scan using l_nn on l
                             Index Cond: (nn = s_1.nn)
(11 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn right join s1 on l.n = s1.n);
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.n = s1.n)
           ->  Seq Scan on s1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Scan using l_nn on l
                             Index Cond: (nn = s_1.nn)
(11 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn right join s1 on l.n = s1.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
                   QUERY PLAN                    
-------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.n = s1.n)
           ->  Nested Loop Left Join
                 ->  Seq Scan on s s_1
                 ->  Index Scan using l_nn on l
                       Index Cond: (nn = s_1.nn)
           ->  Materialize
                 ->  Seq Scan on s1
(11 rows)

select * from s where nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

--test reduce outer join on outer and sub-query
explain (costs false) select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (s.u = s1.u)
         ->  Seq Scan on s1
         ->  Materialize
               ->  Nested Loop
                     ->  Seq Scan on s
                           Filter: (NOT (hashed SubPlan 1))
                           SubPlan 1
                             ->  Nested Loop
                                   Join Filter: (l_1.n = s1_1.n)
                                   ->  Seq Scan on s1 s1_1
                                   ->  Materialize
                                         ->  Nested Loop
                                               ->  Seq Scan on s s_1
                                               ->  Index Scan using l_nn on l l_1
                                                     Index Cond: (nn = s_1.nn)
                     ->  Index Only Scan using l_nn on l
                           Index Cond: (nn = s.nn)
(19 rows)

select count(*) from s right join l on s.nn = l.nn join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn join s1 on l.n = s1.n);
 count 
-------
     1
(1 row)

explain (costs false) select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
                        QUERY PLAN                        
----------------------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         Filter: (NOT (hashed SubPlan 1))
         ->  Seq Scan on l
         ->  Hash
               ->  Hash Right Join
                     Hash Cond: (s1.u = s.u)
                     ->  Seq Scan on s1
                     ->  Hash
                           ->  Seq Scan on s
         SubPlan 1
           ->  Nested Loop Left Join
                 Join Filter: (l_1.n = s1_1.n)
                 ->  Nested Loop Left Join
                       ->  Seq Scan on s s_1
                       ->  Index Scan using l_nn on l l_1
                             Index Cond: (nn = s_1.nn)
                 ->  Materialize
                       ->  Seq Scan on s1 s1_1
(20 rows)

select count(*) from s right join l on s.nn = l.nn left join s1 on s.u = s1.u where s.nn not in (select l.nn from l right join s on l.nn = s.nn left join s1 on l.n = s1.n);
 count 
-------
     0
(1 row)

-- test union all
explain (costs false) select * from s as t where not exists
(select 1 from (select n as y from l union all
				select u as y from s union all
				select nn as y from s) as v where t.n=v.y or v.y is null) and n is not null;
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s t
         Filter: (n IS NOT NULL)
   ->  Append
         ->  Bitmap Heap Scan on l
               Recheck Cond: ((t.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = t.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
         ->  Seq Scan on s
               Filter: ((t.n = u) OR (u IS NULL))
         ->  Seq Scan on s s_1
               Filter: ((t.n = nn) OR (nn IS NULL))
(15 rows)

select * from s as t where not exists
(select 1 from (select n as y from l union all
				select u as y from s union all
				select nn as y from s) as v where t.n=v.y or v.y is null) and n is not null;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Result
           ->  Append
                 ->  Seq Scan on l l_1
                 ->  Seq Scan on s s_3
                 ->  Seq Scan on s s_4
   ->  Seq Scan on s
         Filter: ((n IS NOT NULL) OR (NOT $0))
   ->  Append
         ->  Bitmap Heap Scan on l
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
         ->  Seq Scan on s s_1
               Filter: ((s.n = u) OR (u IS NULL))
         ->  Seq Scan on s s_2
               Filter: ((s.n = nn) OR (nn IS NULL))
(21 rows)

select * from s where n not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select nn from l);
                        QUERY PLAN                         
-----------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Hash Anti Join
         Hash Cond: (s.n = l_1.nn)
         ->  Append
               ->  Seq Scan on s
                     Filter: ((n IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
                     Filter: ((u IS NOT NULL) OR (NOT $0))
         ->  Hash
               ->  Seq Scan on l l_1
(12 rows)

select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select nn from l);
 count 
-------
     1
(1 row)

explain (costs false) select count(*) from
(select n as x from s union all select n as x from l) t where t.x not in
(select nn from empty);
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Append
         ->  Seq Scan on s
               Filter: (NOT (hashed SubPlan 1))
               SubPlan 1
                 ->  Seq Scan on empty
         ->  Seq Scan on l
               Filter: (NOT (hashed SubPlan 1))
(8 rows)

select count(*) from
(select n as x from s union all select n as x from l) t where t.x not in
(select nn from empty);
 count 
-------
 10004
(1 row)

explain (costs false) select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Finalize Aggregate
   InitPlan 1 (returns $0)
     ->  Result
           ->  Append
                 ->  Seq Scan on l l_2
                 ->  Seq Scan on s s_3
                 ->  Seq Scan on s s_4
   ->  Gather
         Workers Planned: 2
         Params Evaluated: $0
         ->  Partial Aggregate
               ->  Nested Loop Anti Join
                     ->  Parallel Append
                           ->  Parallel Seq Scan on l
                                 Filter: ((u IS NOT NULL) OR (NOT $0))
                           ->  Parallel Seq Scan on s
                                 Filter: ((n IS NOT NULL) OR (NOT $0))
                     ->  Append
                           ->  Bitmap Heap Scan on l l_1
                                 Recheck Cond: ((l.u = n) OR (n IS NULL))
                                 ->  BitmapOr
                                       ->  Bitmap Index Scan on l_n
                                             Index Cond: (n = l.u)
                                       ->  Bitmap Index Scan on l_n
                                             Index Cond: (n IS NULL)
                           ->  Seq Scan on s s_1
                                 Filter: ((l.u = u) OR (u IS NULL))
                           ->  Seq Scan on s s_2
                                 Filter: ((l.u = nn) OR (nn IS NULL))
(29 rows)

select count(*) from
(select n as x from s union all select u as x from l) t where t.x not in
(select n as y from l union all
 select u as y from s union all
 select nn as y from s);
 count 
-------
     0
(1 row)

-- test multi-levels of NOT IN
explain (costs false) select * from s where n not in (select n from s where n not in (select n from l));
                         QUERY PLAN                         
------------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 3))
   SubPlan 3
     ->  Nested Loop Anti Join
           InitPlan 2 (returns $2)
             ->  Seq Scan on l
           ->  Seq Scan on s s_1
                 Filter: ((n IS NOT NULL) OR (NOT $2))
           ->  Bitmap Heap Scan on l l_1
                 Recheck Cond: ((s_1.n = n) OR (n IS NULL))
                 ->  BitmapOr
                       ->  Bitmap Index Scan on l_n
                             Index Cond: (n = s_1.n)
                       ->  Bitmap Index Scan on l_n
                             Index Cond: (n IS NULL)
(15 rows)

select * from s where n not in (select n from s where n not in (select n from l));
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
       1 |       1 |       1 | foo
       2 |       2 |       2 | foo
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(4 rows)

explain (costs false) select * from s where n not in (select n from s where n not in (select u from l));
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 3))
   SubPlan 3
     ->  Nested Loop Anti Join
           InitPlan 2 (returns $2)
             ->  Seq Scan on l
           ->  Seq Scan on s s_1
                 Filter: ((n IS NOT NULL) OR (NOT $2))
           ->  Index Only Scan using l_u on l l_1
                 Index Cond: (u = s_1.n)
(10 rows)

select * from s where n not in (select n from s where n not in (select u from l));
 u | n | nn |  p  
---+---+----+-----
 1 | 1 |  1 | foo
 2 | 2 |  2 | foo
(2 rows)

explain (costs false) select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Aggregate
   ->  Seq Scan on s
         Filter: (NOT (SubPlan 2))
         SubPlan 2
           ->  Result
                 One-Time Filter: (NOT $2)
                 InitPlan 1 (returns $2)
                   ->  Nested Loop Anti Join
                         ->  Seq Scan on s1
                               Filter: (n = s.n)
                         ->  Bitmap Heap Scan on l
                               Recheck Cond: ((s1.u = n) OR (n IS NULL))
                               ->  BitmapOr
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n = s1.u)
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n IS NULL)
                 ->  Seq Scan on s1 s1_1
(18 rows)

select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
 count 
-------
     0
(1 row)

explain (costs false) select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from s1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Seq Scan on s
   Filter: ((NOT (hashed SubPlan 1)) AND (NOT (hashed SubPlan 2)) AND (NOT (hashed SubPlan 3)))
   SubPlan 1
     ->  Seq Scan on s1
   SubPlan 2
     ->  Seq Scan on s1 s1_1
   SubPlan 3
     ->  Seq Scan on s1 s1_2
(8 rows)

select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from s1);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from l);
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: ((NOT (hashed SubPlan 1)) AND (NOT (hashed SubPlan 2)))
         SubPlan 1
           ->  Seq Scan on s1
         SubPlan 2
           ->  Seq Scan on s1 s1_1
   ->  Index Only Scan using l_nn on l
         Index Cond: (nn = s.nn)
(9 rows)

select * from s where n not in (select n from s1) and u not in (select u from s1) and nn not in (select nn from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n))
and nn not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Aggregate
   ->  Seq Scan on s
         Filter: ((NOT (SubPlan 2)) AND (NOT (SubPlan 4)))
         SubPlan 2
           ->  Result
                 One-Time Filter: (NOT $2)
                 InitPlan 1 (returns $2)
                   ->  Nested Loop Anti Join
                         ->  Seq Scan on s1
                               Filter: (n = s.n)
                         ->  Bitmap Heap Scan on l
                               Recheck Cond: ((s1.u = n) OR (n IS NULL))
                               ->  BitmapOr
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n = s1.u)
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n IS NULL)
                 ->  Seq Scan on s1 s1_1
         SubPlan 4
           ->  Result
                 One-Time Filter: (NOT $6)
                 InitPlan 3 (returns $6)
                   ->  Nested Loop Anti Join
                         ->  Seq Scan on s1 s1_2
                               Filter: (n = s.n)
                         ->  Bitmap Heap Scan on l l_1
                               Recheck Cond: ((s1_2.u = n) OR (n IS NULL))
                               ->  BitmapOr
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n = s1_2.u)
                                     ->  Bitmap Index Scan on l_n
                                           Index Cond: (n IS NULL)
                 ->  Seq Scan on s1 s1_3
(33 rows)

select count(*) from s where u not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n))
and nn not in
(select n from s1 where not exists
 (select 1 from (select n from s1 where u not in (select n from l)) t where t.n = s.n));
 count 
-------
     0
(1 row)

--test COALESCE
explain (costs false) select * from s where COALESCE(n, -1) not in (select COALESCE(n, -1) from l);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.n, '-1'::integer) = COALESCE(l.n, '-1'::integer))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(n, -1) not in (select COALESCE(n, -1) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where COALESCE(n, NULL, -1) not in (select COALESCE(n, NULL, -1) from l);
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.n, '-1'::integer) = COALESCE(l.n, '-1'::integer))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(n, NULL, -1) not in (select COALESCE(n, NULL, -1) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where COALESCE(n, NULL, NULL) not in (select COALESCE(n, NULL, NULL) from l);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: ((COALESCE(s.n) = COALESCE(l.n)) OR (COALESCE(l.n) IS NULL))
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: ((COALESCE(n) IS NOT NULL) OR (NOT $0))
   ->  Materialize
         ->  Seq Scan on l
(8 rows)

select * from s where COALESCE(n, NULL, NULL) not in (select COALESCE(n, NULL, NULL) from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where COALESCE(n, nn) not in (select COALESCE(n, nn) from l);
                        QUERY PLAN                        
----------------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.n, s.nn) = COALESCE(l.n, l.nn))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(n, nn) not in (select COALESCE(n, nn) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where COALESCE(nn, NULL) not in (select COALESCE(nn, NULL) from l);
                   QUERY PLAN                   
------------------------------------------------
 Hash Anti Join
   Hash Cond: (COALESCE(s.nn) = COALESCE(l.nn))
   ->  Seq Scan on s
   ->  Hash
         ->  Seq Scan on l
(5 rows)

select * from s where COALESCE(nn, NULL) not in (select COALESCE(nn, NULL) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where (COALESCE(n, -1), nn, COALESCE(n, u)) not in (select COALESCE(n, -1), nn, COALESCE(n, u) from l);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Scan using l_nn on l
         Index Cond: (nn = s.nn)
         Filter: ((COALESCE(s.n, '-1'::integer) = COALESCE(n, '-1'::integer)) AND (COALESCE(s.n, s.u) = COALESCE(n, u)))
(5 rows)

select * from s where (COALESCE(n, -1), nn, COALESCE(n, u)) not in (select COALESCE(n, -1), nn, COALESCE(n, u) from l);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

-- test miscellaneous outer nullable cases
explain (costs false) select * from s where (n,n) not in (select n,n from l);
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s.n = l.n) AND (s.n = l.n)) IS NOT FALSE)
   ->  Seq Scan on s
   ->  Materialize
         ->  Seq Scan on l
(5 rows)

select * from s where (n,n) not in (select n,n from l);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l);
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Nested Loop Anti Join
   Join Filter: (((s.n = l_1.n) AND (s.u = l_1.u) AND (s.nn = l_1.nn)) IS NOT FALSE)
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s
   ->  Materialize
         ->  Seq Scan on l l_1
(9 rows)

select * from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l);
 u | n | nn | p | u | n | nn | p 
---+---+----+---+---+---+----+---
(0 rows)

explain (costs false) select count(*) from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l where u < 0);
                 QUERY PLAN                  
---------------------------------------------
 Aggregate
   ->  Hash Left Join
         Hash Cond: (l.nn = s.nn)
         Filter: (NOT (hashed SubPlan 1))
         ->  Seq Scan on l
         ->  Hash
               ->  Seq Scan on s
         SubPlan 1
           ->  Index Scan using l_u on l l_1
                 Index Cond: (u < 0)
(10 rows)

select count(*) from s right join l on s.nn = l.nn where (s.n,s.u,s.nn) not in (select n,u,nn from l where u < 0);
 count 
-------
 10000
(1 row)

explain (costs false) select * from s where (n,n,n) not in (select distinct n,n,n from l where u > 0 limit 3) order by n;
                     QUERY PLAN                      
-----------------------------------------------------
 Sort
   Sort Key: s.n
   ->  Seq Scan on s
         Filter: (NOT (hashed SubPlan 1))
         SubPlan 1
           ->  Limit
                 ->  Unique
                       ->  Index Scan using l_n on l
                             Filter: (u > 0)
(9 rows)

select * from s where (n,n,n) not in (select distinct n,n,n from l where u > 0 limit 3) order by n;
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

--test outer has strict predicate or inner join
explain (costs false) select * from s where n not in (select n from l) and n > 0;
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n > 0)
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where n not in (select n from l) and n > 0;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l) and u > 0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
   ->  Seq Scan on s
         Filter: (((n IS NOT NULL) OR (NOT $0)) AND (u > 0))
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(12 rows)

select * from s where n not in (select n from l) and u > 0;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l) and n is not null;
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n IS NOT NULL)
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where n not in (select n from l) and n is not null;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s join l on s.n = l.n where s.n not in (select n from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Nested Loop
   ->  Nested Loop Anti Join
         ->  Seq Scan on s
         ->  Bitmap Heap Scan on l l_1
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
   ->  Index Scan using l_n on l
         Index Cond: (n = s.n)
(12 rows)

select * from s join l on s.n = l.n where s.n not in (select n from l);
 u | n | nn | p | u | n | nn | p 
---+---+----+---+---+---+----+---
(0 rows)

explain (costs false) select count(*) from s right join l on s.n = l.n where s.n not in (select n from l);
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Anti Join
         ->  Hash Left Join
               Hash Cond: (l.n = s.n)
               Filter: ((s.n IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on l
               ->  Hash
                     ->  Seq Scan on s
         ->  Bitmap Heap Scan on l l_1
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
(17 rows)

select count(*) from s right join l on s.n = l.n where s.n not in (select n from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select n from l);
                             QUERY PLAN                             
--------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         Join Filter: (s.u = s1.u)
         ->  Nested Loop
               ->  Nested Loop Anti Join
                     ->  Seq Scan on s
                     ->  Bitmap Heap Scan on l l_1
                           Recheck Cond: ((s.n = n) OR (n IS NULL))
                           ->  BitmapOr
                                 ->  Bitmap Index Scan on l_n
                                       Index Cond: (n = s.n)
                                 ->  Bitmap Index Scan on l_n
                                       Index Cond: (n IS NULL)
               ->  Index Only Scan using l_n on l
                     Index Cond: (n = s.n)
         ->  Seq Scan on s1
(16 rows)

select count(*) from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select n from l);
 count 
-------
     0
(1 row)

explain (costs false) select count(*) from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select n from l);
                          QUERY PLAN                          
--------------------------------------------------------------
 Aggregate
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_2
   ->  Nested Loop Anti Join
         ->  Nested Loop Left Join
               Join Filter: (s.u = s1.u)
               Filter: ((s.n IS NOT NULL) OR (NOT $0))
               ->  Seq Scan on s1
               ->  Materialize
                     ->  Nested Loop
                           ->  Seq Scan on s
                           ->  Index Only Scan using l_n on l
                                 Index Cond: (n = s.n)
         ->  Bitmap Heap Scan on l l_1
               Recheck Cond: ((s.n = n) OR (n IS NULL))
               ->  BitmapOr
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n = s.n)
                     ->  Bitmap Index Scan on l_n
                           Index Cond: (n IS NULL)
(20 rows)

select count(*) from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select n from l);
 count 
-------
     0
(1 row)

--test inner has strict predicate or inner join
explain (costs false) select * from s where u not in (select n from l where n > 0);
                 QUERY PLAN                  
---------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.u) AND (n > 0))
(4 rows)

select * from s where u not in (select n from l where n > 0);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where u not in (select n from l where u > 0);
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.u = n) OR (n IS NULL))
         Filter: (u > 0)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.u)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(10 rows)

select * from s where u not in (select n from l where u > 0);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where u not in (select n from l where n is not null);
                     QUERY PLAN                      
-----------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.u) AND (n IS NOT NULL))
(4 rows)

select * from s where u not in (select n from l where n is not null);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where u not in (select l.n from l join s on l.n=s.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(7 rows)

select * from s where u not in (select l.n from l join s on l.n=s.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where u not in (select l.n from l join s on l.u=s.u);
               QUERY PLAN                
-----------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Scan using l_u on l
                 Index Cond: (u = s_1.u)
(7 rows)

select * from s where u not in (select l.n from l join s on l.u=s.u);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where u not in (select l.n from l join s on l.n = s.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(7 rows)

select * from s where u not in (select l.n from l join s on l.n = s.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where u not in (select l.n from l right join s on l.n = s.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(7 rows)

select * from s where u not in (select l.n from l right join s on l.n = s.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where u not in (select l.n from l right join s on l.n=s.n join s1 on l.n=s1.n);
                  QUERY PLAN                  
----------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop
           ->  Nested Loop
                 Join Filter: (s_1.n = s1.n)
                 ->  Seq Scan on s1
                 ->  Materialize
                       ->  Seq Scan on s s_1
           ->  Index Only Scan using l_n on l
                 Index Cond: (n = s_1.n)
(11 rows)

select * from s where u not in (select l.n from l right join s on l.n=s.n join s1 on l.n=s1.n);
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
       3 |         |       3 | foo
(2 rows)

explain (costs false) select * from s where u not in (select l.n from l join s on l.n=s.n right join s1 on l.n=s1.n);
                        QUERY PLAN                        
----------------------------------------------------------
 Seq Scan on s
   Filter: (NOT (hashed SubPlan 1))
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l.n = s1.n)
           ->  Seq Scan on s1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Only Scan using l_n on l
                             Index Cond: (n = s_1.n)
(11 rows)

select * from s where u not in (select l.n from l join s on l.n=s.n right join s1 on l.n=s1.n);
 u | n | nn | p 
---+---+----+---
(0 rows)

--test both sides have strict predicate or inner join
explain (costs false) select * from s where n not in (select n from l where n > 0) and n > 0;
                 QUERY PLAN                  
---------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n > 0)
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.n) AND (n > 0))
(5 rows)

select * from s where n not in (select n from l where n > 0) and n > 0;
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s where n not in (select n from l where u > 0) and n > 0;
                    QUERY PLAN                    
--------------------------------------------------
 Nested Loop Anti Join
   ->  Seq Scan on s
         Filter: (n > 0)
   ->  Bitmap Heap Scan on l
         Recheck Cond: ((s.n = n) OR (n IS NULL))
         Filter: (u > 0)
         ->  BitmapOr
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n = s.n)
               ->  Bitmap Index Scan on l_n
                     Index Cond: (n IS NULL)
(11 rows)

select * from s where n not in (select n from l where u > 0) and n > 0;
 u | n | nn | p 
---+---+----+---
(0 rows)

explain (costs false) select * from s where n not in (select n from l where n > 0) and u > 0;
                         QUERY PLAN                          
-------------------------------------------------------------
 Nested Loop Anti Join
   InitPlan 1 (returns $0)
     ->  Seq Scan on l l_1
           Filter: (n > 0)
   ->  Seq Scan on s
         Filter: (((n IS NOT NULL) OR (NOT $0)) AND (u > 0))
   ->  Index Only Scan using l_n on l
         Index Cond: ((n = s.n) AND (n > 0))
(8 rows)

select * from s where n not in (select n from l where n > 0) and u > 0;
    u    |    n    |   nn    |   p    
---------+---------+---------+--------
 1000002 | 1000002 | 1000002 | foofoo
(1 row)

explain (costs false) select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l right join s on l.n=s.n join s s1 on l.n=s1.n);
                             QUERY PLAN                             
--------------------------------------------------------------------
 Nested Loop
   Join Filter: (s.u = s1.u)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Nested Loop
               ->  Seq Scan on s
                     Filter: (NOT (hashed SubPlan 1))
                     SubPlan 1
                       ->  Nested Loop
                             ->  Nested Loop
                                   Join Filter: (s_1.n = s1_1.n)
                                   ->  Seq Scan on s s_1
                                   ->  Materialize
                                         ->  Seq Scan on s s1_1
                             ->  Index Only Scan using l_n on l l_1
                                   Index Cond: (n = s_1.n)
               ->  Index Scan using l_n on l
                     Index Cond: (n = s.n)
(18 rows)

select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l right join s on l.n=s.n join s s1 on l.n=s1.n);
 u | n | nn | p | u | n | nn | p | u | n | n1 | nn | p 
---+---+----+---+---+---+----+---+---+---+----+----+---
(0 rows)

explain (costs false) select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Nested Loop
   Join Filter: (s.u = s1.u)
   ->  Seq Scan on s1
   ->  Materialize
         ->  Nested Loop
               ->  Seq Scan on s
                     Filter: (NOT (hashed SubPlan 1))
                     SubPlan 1
                       ->  Nested Loop Left Join
                             Join Filter: (l_1.n = s1_1.n)
                             ->  Seq Scan on s s1_1
                             ->  Materialize
                                   ->  Nested Loop
                                         ->  Seq Scan on s s_1
                                         ->  Index Only Scan using l_n on l l_1
                                               Index Cond: (n = s_1.n)
               ->  Index Scan using l_n on l
                     Index Cond: (n = s.n)
(18 rows)

select * from s right join l on s.n = l.n join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
 u | n | nn | p | u | n | nn | p | u | n | n1 | nn | p 
---+---+----+---+---+---+----+---+---+---+----+----+---
(0 rows)

explain (costs false) select * from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
                          QUERY PLAN                          
--------------------------------------------------------------
 Nested Loop Left Join
   Join Filter: (s.u = s1.u)
   Filter: (NOT (hashed SubPlan 1))
   ->  Seq Scan on s1
   ->  Materialize
         ->  Nested Loop
               ->  Seq Scan on s
               ->  Index Scan using l_n on l
                     Index Cond: (n = s.n)
   SubPlan 1
     ->  Nested Loop Left Join
           Join Filter: (l_1.n = s1_1.n)
           ->  Seq Scan on s s1_1
           ->  Materialize
                 ->  Nested Loop
                       ->  Seq Scan on s s_1
                       ->  Index Only Scan using l_n on l l_1
                             Index Cond: (n = s_1.n)
(18 rows)

select * from s join l on s.n = l.n right join s1 on s.u = s1.u where s.n not in (select l.n from l join s on l.n=s.n right join s s1 on l.n=s1.n);
 u | n | nn | p | u | n | nn | p | u | n | n1 | nn | p 
---+---+----+---+---+---+----+---+---+---+----+----+---
(0 rows)

-- clean up
set work_mem = 4000;
drop table s;
drop table s1;
drop table l;
drop table empty;
