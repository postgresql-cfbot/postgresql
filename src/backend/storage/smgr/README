src/backend/storage/smgr/README

Storage Managers
================

In the original Berkeley Postgres system, there were several storage managers,
of which only the "magnetic disk" manager remains.  (At Berkeley there were
also managers for the Sony WORM optical disk jukebox and persistent main
memory, but these were never supported in any externally released Postgres,
nor in any version of PostgreSQL.)  The "magnetic disk" manager is itself
seriously misnamed, because actually it supports any kind of device for
which the operating system provides standard filesystem operations; which
these days is pretty much everything of interest.  However, we retain the
notion of a storage manager switch in case anyone ever wants to reintroduce
other kinds of storage managers.  Removing the switch layer would save
nothing noticeable anyway, since storage-access operations are surely far
more expensive than one extra layer of C function calls.

In Berkeley Postgres each relation was tagged with the ID of the storage
manager to use for it.  This is gone.  It would be probably more reasonable
to associate storage managers with tablespaces, should we ever re-introduce
multiple storage managers into the system catalogs.

The files in this directory, and their contents, are

    smgr.c	The storage manager switch dispatch code.  The routines in
		this file call the appropriate storage manager to do storage
		accesses requested by higher-level code.  smgr.c also manages
		the file handle cache (SMgrRelation table).

    md.c	The "magnetic disk" storage manager, which is really just
		an interface to the kernel's filesystem operations.

Note that md.c in turn relies on src/backend/storage/file/fd.c.


Relation Forks
==============

Since 8.4, a single smgr relation can be comprised of multiple physical
files, called relation forks. This allows storing additional metadata like
Free Space information in additional forks, which can be grown and truncated
independently of the main data file, while still treating it all as a single
physical relation in system catalogs.

It is assumed that the main fork, fork number 0 or MAIN_FORKNUM, always
exists. Fork numbers are assigned in src/include/common/relpath.h.
Functions in smgr.c and md.c take an extra fork number argument, in addition
to relfilelocator and block number, to identify which relation fork you want to
access. Since most code wants to access the main fork, a shortcut version of
ReadBuffer that accesses MAIN_FORKNUM is provided in the buffer manager for
convenience.


Adjustments for Variable Block Sizes
====================================

Prior to 17, the disk block size (aka BLCKSZ) was set at compile-time. While
each database cluster still has a fixed block size, this is now selected at
`initdb` time, meaning that a single PostgreSQL binary installation can support
clusters of varying sizes.

As this is now a per-cluster setting, the block size is set in the pg_control
file. There are multiple computed settings which rely on the cluster block size,
so these also need to be initialized at cluster start.  This is managed via
BlockSizeInit() in src/common/blocksize.c.  This routine computes a table for
all values which would have been computed at compile time.

The expressions used to calculate the values in this table have been moved from
their original locations and parameterized based on blocksize; these are named
CalcXXXX(blocksize), and are stored in src/include/common/blocksize.h.

In order to minimize code changes, we have kept the names of former constants
(such as MaxHeapTuplesPerPage) and replaced their definitions with an
appropriate lookup in this table.  Since these lookups are now handled at
runtime, it is important to initialize these as early as possible so any code
usage of these constants uses the computed value after it has been initialized
instead of 0.  This applies to any piece of the code which needs to know about
the block size or uses any value which was based on it.

To ensure that any code that depended on the old behavior is properly adjusted,
we have removed BLCKSZ as a constant, which will ensure that external code will
fail to compile.  When writing new code which cases about the block size, you
should use one of the following values:

- CLUSTER_BLOCK_SIZE - evaluates to the cluster's block size as initialized by
  BlockSizeInit().

- DEFAULT_BLOCK_SIZE - the compiled-in default block size; 8k

- MIN_BLOCK_SIZE - the smallest supported block size; 1k

- MAX_BLOCK_SIZE - the largest supported block size; 32k

In general, you should use CLUSTER_BLOCK_SIZE unless you are allocating space on
the stack, and even then you should be careful to allocate based on
MAX_BLOCK_SIZE, but still limit accesses to these structs based on the /actual/
runtime cluster block size.  The core code has bene modified to follow these
standards.

Occasionally, we had been using BLCKSZ as a "big enough buffer" rather than
caring about any specific size correlated with the cluster.  In those cases, you
should just use DEFAULT_BLOCK_SIZE.

