-- Some utility functions
CREATE OR REPLACE FUNCTION get_span_start_ns(time_start timestamptz, start_ns smallint) RETURNS bigint AS
$BODY$
BEGIN
    RETURN extract(epoch from time_start) * 1000000000 + start_ns;
END;
$BODY$
LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION get_span_end_ns(time_start timestamptz, start_ns smallint, duration bigint) RETURNS bigint AS
$BODY$
BEGIN
    RETURN get_span_start_ns(time_start, start_ns) + duration;
END;
$BODY$
LANGUAGE plpgsql;
-- Create pg_tracing extension with sampling on
/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000001-0000000000000001-01'*/ CREATE EXTENSION pg_tracing;
-- This will create the following spans (non exhaustive list):
--
-- +-------------------------------------------------------------------------------------+
-- | A: Utility: Create Extension                                                        |
-- +-+-----------------------------------------------------------------------------------+
--   +----------------------------------------------------------------------------------+
--   |B: ProcessUtility: Create Extension                                               |
--   +---+-----------------------------------+---+--------------------------------------+
--       +-----------------------------------+   +-------------------------------------+
--       |C: Utility: Create Function1       |   |E: Utility: Create Function2         |
--       ++----------------------------------+   ++-----------------------------------++
--        +----------------------------------+    +-----------------------------------+
--        |D: ProcessUtility: Create Function|    |F: ProcessUtility: Create Function2|
--        +----------------------------------+    +-----------------------------------+
-- Extract span_ids, start and end of those spans
SELECT span_id AS span_a_id,
        get_span_start_ns(span_start, span_start_ns) as span_a_start,
        get_span_end_ns(span_start, span_start_ns, duration) as span_a_end
		from pg_tracing_peek_spans where parent_id=1 and name='Utility' \gset
SELECT span_id AS span_b_id,
        get_span_start_ns(span_start, span_start_ns) as span_b_start,
        get_span_end_ns(span_start, span_start_ns, duration) as span_b_end
		from pg_tracing_peek_spans where parent_id=:span_a_id and name='ProcessUtility' \gset
SELECT span_id AS span_c_id,
        get_span_start_ns(span_start, span_start_ns) as span_c_start,
        get_span_end_ns(span_start, span_start_ns, duration) as span_c_end
		from pg_tracing_peek_spans where parent_id=:span_b_id and name='Utility' limit 1 \gset
SELECT span_id AS span_d_id,
        get_span_start_ns(span_start, span_start_ns) as span_d_start,
        get_span_end_ns(span_start, span_start_ns, duration) as span_d_end
		from pg_tracing_peek_spans where parent_id=:span_c_id and name='ProcessUtility' \gset
SELECT span_id AS span_e_id,
        get_span_start_ns(span_start, span_start_ns) as span_e_start,
        get_span_end_ns(span_start, span_start_ns, duration) as span_e_end
		from pg_tracing_peek_spans where parent_id=:span_b_id and name='Utility' limit 1 offset 1 \gset
-- Check that the start and end of those spans are within expectation
SELECT :span_a_start < :span_b_start AS span_a_start_first,
		:span_a_end >= :span_b_end AS span_a_end_last,
		:span_d_end <= :span_c_end AS nested_span_ends_before_parent,
		:span_c_end <= :span_e_start AS next_utility_start_after;
 span_a_start_first | span_a_end_last | nested_span_ends_before_parent | next_utility_start_after 
--------------------+-----------------+--------------------------------+--------------------------
 t                  | t               | t                              | t
(1 row)

-- Clean current spans
select count(*) from pg_tracing_consume_spans;
 count 
-------
    49
(1 row)

--
-- Test that no utility is captured with track_utility off
--
-- Set utility off
SET pg_tracing.track_utility = off;
-- Prepare and execute a prepared statement
PREPARE test_prepared_one_param (integer) AS SELECT $1;
EXECUTE test_prepared_one_param(100);
 ?column? 
----------
      100
(1 row)

-- Nothing should be generated
select count(*) from pg_tracing_consume_spans;
 count 
-------
     0
(1 row)

-- Force a query to start from ExecutorRun
SET plan_cache_mode='force_generic_plan';
EXECUTE test_prepared_one_param(200);
 ?column? 
----------
      200
(1 row)

-- Again, nothing should be generated
select count(*) from pg_tracing_consume_spans;
 count 
-------
     0
(1 row)

--
-- Test that no utility is captured with track_utility off
--
-- Enable utility tracking and track everything
SET pg_tracing.track_utility = on;
SET pg_tracing.sample_rate = 1.0;
-- Prepare and execute a prepared statement
PREPARE test_prepared_one_param_2 (integer) AS SELECT $1;
EXECUTE test_prepared_one_param_2(100);
 ?column? 
----------
      100
(1 row)

-- Check the number of generated spans
select count(distinct(trace_id)) from pg_tracing_peek_spans;
 count 
-------
     2
(1 row)

-- Check that the spans are in correct order
select resource, parameters from pg_tracing_peek_spans order by span_start, span_start_ns;
                         resource                          | parameters 
-----------------------------------------------------------+------------
 PREPARE test_prepared_one_param_2 (integer) AS SELECT $1; | 
 Parse                                                     | 
 Post Parse                                                | 
 PREPARE test_prepared_one_param_2 (integer) AS SELECT $1; | 
 PREPARE test_prepared_one_param_2 (integer) AS SELECT $1; | 
 Parse                                                     | 
 Post Parse                                                | 
 EXECUTE test_prepared_one_param_2(100);                   | 
 Parse                                                     | 
 Post Parse                                                | 
 EXECUTE test_prepared_one_param_2(100);                   | 
 PREPARE test_prepared_one_param_2 (integer) AS SELECT $1; | 
 Planner                                                   | 
 Start                                                     | 
 Run                                                       | 
 Result                                                    | 
 Finish                                                    | 
 End                                                       | 
(18 rows)

-- Check the top span (standalone top span has trace_id=parent_id=span_id)
select resource, parameters from pg_tracing_consume_spans where trace_id = parent_id and parent_id = span_id order by span_start, span_start_ns;
                         resource                          | parameters 
-----------------------------------------------------------+------------
 PREPARE test_prepared_one_param_2 (integer) AS SELECT $1; | 
 EXECUTE test_prepared_one_param_2(100);                   | 
(2 rows)

-- Test prepared statement with generic plan
SET plan_cache_mode='force_generic_plan';
EXECUTE test_prepared_one_param(200);
 ?column? 
----------
      200
(1 row)

-- Check the number of generated spans
select count(distinct(trace_id)) from pg_tracing_peek_spans;
 count 
-------
     2
(1 row)

-- Check that the spans are in correct order
select resource, parameters from pg_tracing_peek_spans order by span_start, span_start_ns;
                        resource                         | parameters 
---------------------------------------------------------+------------
 SET plan_cache_mode='force_generic_plan';               | 
 Parse                                                   | 
 Post Parse                                              | 
 SET plan_cache_mode='force_generic_plan';               | 
 EXECUTE test_prepared_one_param(200);                   | 
 Parse                                                   | 
 Post Parse                                              | 
 EXECUTE test_prepared_one_param(200);                   | 
 PREPARE test_prepared_one_param (integer) AS SELECT $1; | 
 Start                                                   | 
 Run                                                     | 
 Result                                                  | 
 Finish                                                  | 
 End                                                     | 
(14 rows)

-- Check the top span (standalone top span has trace_id=parent_id=span_id)
select resource, parameters from pg_tracing_consume_spans where trace_id = parent_id and parent_id = span_id order by span_start, span_start_ns;
                 resource                  | parameters 
-------------------------------------------+------------
 SET plan_cache_mode='force_generic_plan'; | 
 EXECUTE test_prepared_one_param(200);     | 
(2 rows)

-- Second create extension should generate an error that is captured by span
/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000001-0000000000000001-01'*/ CREATE EXTENSION pg_tracing;
ERROR:  extension "pg_tracing" already exists
select resource, parameters, sql_error_code from pg_tracing_consume_spans order by span_start, span_start_ns;
           resource           | parameters | sql_error_code 
------------------------------+------------+----------------
 CREATE EXTENSION pg_tracing; |            | 42710
 Parse                        |            | 00000
 Post Parse                   |            | 00000
 CREATE EXTENSION pg_tracing; |            | 42710
(4 rows)

-- Cleanup
SET plan_cache_mode='auto';
