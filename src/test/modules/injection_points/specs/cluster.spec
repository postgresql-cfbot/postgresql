# Prefix the system columns with underscore as they are not allowed as column
# names.
setup
{
	CREATE EXTENSION injection_points;

	CREATE TABLE clstr_test(i int PRIMARY KEY, j int);
	INSERT INTO clstr_test(i, j) VALUES (1, 1), (2, 2), (3, 3), (4, 4);

	CREATE TABLE relfilenodes(node oid);

	CREATE TABLE data_s1(_xmin xid, _cmin cid, i int, j int);
	CREATE TABLE data_s2(_xmin xid, _cmin cid, i int, j int);
}

teardown
{
	DROP TABLE clstr_test;
	DROP EXTENSION injection_points;

	DROP TABLE relfilenodes;
	DROP TABLE data_s1;
	DROP TABLE data_s2;
}

session s1
setup
{
	SELECT injection_points_set_local();
	SELECT injection_points_attach('cluster-concurrently-before-lock', 'wait');
}
# Perform the initial load and wait for s2 to do some data changes.
step wait_before_lock
{
	CLUSTER (CONCURRENTLY) clstr_test USING clstr_test_pkey;
}
# Check the table from the perspective of s1.
#
# Besides the contents, we also check that relfilenode has changed.
#
# xmin and cmin columns are used to check that we do not change tuple
# visibility information. Since we do not expect xmin to stay unchanged across
# test runs, it cannot appear in the output text. Instead, have each session
# write the contents into a table and use FULL JOIN to check if the outputs
# are identical.
step check1
{
	INSERT INTO relfilenodes(node)
	SELECT relfilenode FROM pg_class WHERE relname='clstr_test';

	SELECT count(DISTINCT node) FROM relfilenodes;

	SELECT i, j FROM clstr_test ORDER BY i, j;

	INSERT INTO data_s1(_xmin, _cmin, i, j)
	SELECT xmin, cmin, i, j FROM clstr_test;

	SELECT count(*)
	FROM data_s1 d1 FULL JOIN data_s2 d2 USING (_xmin, _cmin, i, j)
	WHERE d1.i ISNULL OR d2.i ISNULL;
}
teardown
{
    SELECT injection_points_detach('cluster-concurrently-before-lock');
}

session s2
# Change the existing data. UPDATE changes both key and non-key columns. Also
# update one row twice to test whether tuple version generated by this session
# can be found.
step change_existing
{
	UPDATE clstr_test SET i=10 where i=1;
	UPDATE clstr_test SET j=20 where i=2;
	UPDATE clstr_test SET i=30 where i=3;
	UPDATE clstr_test SET i=40 where i=30;
	DELETE FROM clstr_test WHERE i=4;
}
# Insert new rows and UPDATE / DELETE some of them. Again, update both key and
# non-key column.
step change_new
{
	INSERT INTO clstr_test(i, j) VALUES (5, 5), (6, 6), (7, 7), (8, 8);
	UPDATE clstr_test SET i=50 where i=5;
	UPDATE clstr_test SET j=60 where i=6;
	DELETE FROM clstr_test WHERE i=7;
}

# When applying concurrent data changes, we should see the effects of an
# in-progress subtransaction.
step change_subxact1
{
	BEGIN;
	INSERT INTO clstr_test(i, j) VALUES (100, 100);
	SAVEPOINT s1;
	UPDATE clstr_test SET i=101 where i=100;
	SAVEPOINT s2;
	UPDATE clstr_test SET i=102 where i=101;
	COMMIT;
}

# When applying concurrent data changes, we should not see the effects of a
# rolled back subtransaction.
step change_subxact2
{
	BEGIN;
	SAVEPOINT s1;
	INSERT INTO clstr_test(i, j) VALUES (110, 110);
	ROLLBACK TO SAVEPOINT s1;
	INSERT INTO clstr_test(i, j) VALUES (110, 111);
	COMMIT;
}

# Check the table from the perspective of s2.
step check2
{
	INSERT INTO relfilenodes(node)
	SELECT relfilenode FROM pg_class WHERE relname='clstr_test';

	SELECT i, j FROM clstr_test ORDER BY i, j;

	INSERT INTO data_s2(_xmin, _cmin, i, j)
	SELECT xmin, cmin, i, j FROM clstr_test;
}
step wakeup_before_lock
{
	SELECT injection_points_wakeup('cluster-concurrently-before-lock');
}

# Test if data changes introduced while one session is performing CLUSTER
# (CONCURRENTLY) find their way into the table.
permutation
	wait_before_lock
	change_existing
	change_new
	change_subxact1
	change_subxact2
	check2
	wakeup_before_lock
	check1
