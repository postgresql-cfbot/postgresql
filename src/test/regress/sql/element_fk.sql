-- EACH-ELEMENT FK CONSTRAINTS

CREATE TABLE PKTABLEFORARRAY ( ptest1 int PRIMARY KEY, ptest2 text );

-- Insert test data into PKTABLEFORARRAY
INSERT INTO PKTABLEFORARRAY VALUES (1, 'Test1');
INSERT INTO PKTABLEFORARRAY VALUES (2, 'Test2');
INSERT INTO PKTABLEFORARRAY VALUES (3, 'Test3');
INSERT INTO PKTABLEFORARRAY VALUES (4, 'Test4');
INSERT INTO PKTABLEFORARRAY VALUES (5, 'Test5');

-- Check alter table
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], ftest2 int );
ALTER TABLE FKTABLEFORARRAY ADD CONSTRAINT FKARRAY FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY;
DROP TABLE FKTABLEFORARRAY;

-- Check alter table with rows
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], ftest2 int );
INSERT INTO FKTABLEFORARRAY VALUES ('{1}', 1);
ALTER TABLE FKTABLEFORARRAY ADD CONSTRAINT FKARRAY FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY;
DROP TABLE FKTABLEFORARRAY;

-- Check alter table with failing rows
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], ftest2 int );
INSERT INTO FKTABLEFORARRAY VALUES ('{10,1}', 2);
ALTER TABLE FKTABLEFORARRAY ADD CONSTRAINT FKARRAY FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY;
DROP TABLE FKTABLEFORARRAY;

-- Check create table
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY, ftest2 int );
CREATE TABLE FKTABLEFORARRAYMDIM ( ftest1 int[][], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY, ftest2 int );
CREATE TABLE FKTABLEFORARRAYNOTNULL ( ftest1 int[] NOT NULL, FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY, ftest2 int );

-- Insert successful rows into FK TABLE
INSERT INTO FKTABLEFORARRAY VALUES ('{1}', 3);
INSERT INTO FKTABLEFORARRAY VALUES ('{2}', 4);
INSERT INTO FKTABLEFORARRAY VALUES ('{1}', 5);
INSERT INTO FKTABLEFORARRAY VALUES ('{3}', 6);
INSERT INTO FKTABLEFORARRAY VALUES ('{1}', 7);
INSERT INTO FKTABLEFORARRAY VALUES ('{4,5}', 8);
INSERT INTO FKTABLEFORARRAY VALUES ('{4,4}', 9);
INSERT INTO FKTABLEFORARRAY VALUES (NULL, 10);
INSERT INTO FKTABLEFORARRAY VALUES ('{}', 11);
INSERT INTO FKTABLEFORARRAY VALUES ('{1,NULL}', 12);
INSERT INTO FKTABLEFORARRAY VALUES ('{NULL}', 13);
INSERT INTO FKTABLEFORARRAYMDIM VALUES ('{{4,5},{1,2},{1,3}}', 14);
INSERT INTO FKTABLEFORARRAYMDIM VALUES ('{{4,5},{NULL,2},{NULL,3}}', 15);

-- Insert failed rows into FK TABLE
INSERT INTO FKTABLEFORARRAY VALUES ('{6}', 16);
INSERT INTO FKTABLEFORARRAY VALUES ('{4,6}', 17);
INSERT INTO FKTABLEFORARRAY VALUES ('{6,NULL}', 18);
INSERT INTO FKTABLEFORARRAY VALUES ('{6,NULL,4,NULL}', 19);
INSERT INTO FKTABLEFORARRAYMDIM VALUES ('{{1,2},{6,NULL}}', 20);
INSERT INTO FKTABLEFORARRAYNOTNULL VALUES (NULL, 21);

-- Check FKTABLE
SELECT * FROM FKTABLEFORARRAY;

-- Delete a row from PK TABLE (must fail due to ON DELETE NO ACTION)
DELETE FROM PKTABLEFORARRAY WHERE ptest1=1;

-- Check FKTABLE for removal of matched row
SELECT * FROM FKTABLEFORARRAY;

-- Update a row from PK TABLE (must fail due to ON UPDATE NO ACTION)
UPDATE PKTABLEFORARRAY SET ptest1=7 WHERE ptest1=1;

-- Check FKTABLE for update of matched row
SELECT * FROM FKTABLEFORARRAY;

-- Check UPDATE on FKTABLE
UPDATE FKTABLEFORARRAY SET ftest1=ARRAY[1] WHERE ftest2=4;

-- Check FKTABLE for update of matched row
SELECT * FROM FKTABLEFORARRAY;

DROP TABLE FKTABLEFORARRAY;
DROP TABLE FKTABLEFORARRAYNOTNULL;
DROP TABLE FKTABLEFORARRAYMDIM;

-- Allowed references with actions (NO ACTION, RESTRICT)
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE NO ACTION ON UPDATE NO ACTION, ftest2 int );
DROP TABLE FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE NO ACTION ON UPDATE RESTRICT, ftest2 int );
DROP TABLE FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE RESTRICT ON UPDATE NO ACTION, ftest2 int );
DROP TABLE FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE RESTRICT ON UPDATE RESTRICT, ftest2 int );
DROP TABLE FKTABLEFORARRAY;
-- Not allowed references (SET NULL, SET DEFAULT, CASCADE)
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE NO ACTION ON UPDATE SET DEFAULT, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE NO ACTION ON UPDATE SET NULL, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE RESTRICT ON UPDATE SET DEFAULT, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE RESTRICT ON UPDATE SET NULL, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE CASCADE ON UPDATE NO ACTION, ftest2 int );
DROP TABLE FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE CASCADE ON UPDATE RESTRICT, ftest2 int );
DROP TABLE FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE CASCADE ON UPDATE SET DEFAULT, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE CASCADE ON UPDATE SET NULL, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET DEFAULT ON UPDATE NO ACTION, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET DEFAULT ON UPDATE RESTRICT, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET DEFAULT ON UPDATE SET DEFAULT, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET DEFAULT ON UPDATE SET NULL, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET NULL ON UPDATE NO ACTION, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET NULL ON UPDATE RESTRICT, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET NULL ON UPDATE SET DEFAULT, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET NULL ON UPDATE SET NULL, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE NO ACTION ON UPDATE CASCADE, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE RESTRICT ON UPDATE CASCADE, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE CASCADE ON UPDATE CASCADE, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET DEFAULT ON UPDATE CASCADE, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;
CREATE TABLE FKTABLEFORARRAY ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON DELETE SET NULL ON UPDATE CASCADE, ftest2 int );
DROP TABLE IF EXISTS FKTABLEFORARRAY;

-- Cleanup
DROP TABLE PKTABLEFORARRAY;

-- Check reference on empty table
CREATE TABLE PKTABLEFORARRAY (ptest1 int PRIMARY KEY);
CREATE TABLE FKTABLEFORARRAY  (ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY);
INSERT INTO FKTABLEFORARRAY VALUES ('{}');
DROP TABLE FKTABLEFORARRAY;
DROP TABLE PKTABLEFORARRAY;

-- Repeat a similar test using CHAR(1) keys rather than INTEGER
CREATE TABLE PKTABLEFORARRAY ( ptest1 CHAR(1) PRIMARY KEY, ptest2 text );

-- Populate the primary table
INSERT INTO PKTABLEFORARRAY VALUES ('A', 'Test A');
INSERT INTO PKTABLEFORARRAY VALUES ('B', 'Test B');
INSERT INTO PKTABLEFORARRAY VALUES ('C', 'Test C');

-- Create the referencing table
CREATE TABLE FKTABLEFORARRAY ( ftest1 char(1)[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAY ON UPDATE RESTRICT ON DELETE RESTRICT, ftest2 int );

-- Insert valid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY VALUES ('{"A"}', 1);
INSERT INTO FKTABLEFORARRAY VALUES ('{"B"}', 2);
INSERT INTO FKTABLEFORARRAY VALUES ('{"C"}', 3);
INSERT INTO FKTABLEFORARRAY VALUES ('{"A","B","C"}', 4);

-- Insert invalid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY VALUES ('{"D"}', 5);
INSERT INTO FKTABLEFORARRAY VALUES ('{"A","B","D"}', 6);

-- Check FKTABLE
SELECT * FROM FKTABLEFORARRAY;

-- Delete a row from PK TABLE (must fail due to ON DELETE RESTRICT)
DELETE FROM PKTABLEFORARRAY WHERE ptest1='A';

-- Check FKTABLE for removal of matched row
SELECT * FROM FKTABLEFORARRAY;

-- Update a row from PK TABLE (must fail due to ON UPDATE RESTRICT)
UPDATE PKTABLEFORARRAY SET ptest1='D' WHERE ptest1='B';

-- Check FKTABLE for update of matched row
SELECT * FROM FKTABLEFORARRAY;

-- Cleanup
DROP TABLE FKTABLEFORARRAY;
DROP TABLE PKTABLEFORARRAY;

-- Composite primary keys
CREATE TABLE PKTABLEFORARRAY ( id1 CHAR(1), id2 CHAR(1), ptest2 text, PRIMARY KEY (id1, id2) );

-- Populate the primary table
INSERT INTO PKTABLEFORARRAY VALUES ('A', 'A', 'Test A');
INSERT INTO PKTABLEFORARRAY VALUES ('A', 'B', 'Test B');
INSERT INTO PKTABLEFORARRAY VALUES ('B', 'C', 'Test B');

-- Create the referencing table
CREATE TABLE FKTABLEFORARRAY ( fid1 CHAR(1), fid2 CHAR(1)[], ftest2 text, FOREIGN KEY (fid1, EACH ELEMENT OF fid2) REFERENCES PKTABLEFORARRAY);

-- Insert valid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY VALUES ('A', ARRAY['A','B'], '1');
INSERT INTO FKTABLEFORARRAY VALUES ('B', ARRAY['C'], '2');

-- Insert invalid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY VALUES ('A', ARRAY['A','B', 'C'], '3');
INSERT INTO FKTABLEFORARRAY VALUES ('B', ARRAY['A'], '4');

-- Cleanup
DROP TABLE FKTABLEFORARRAY;
DROP TABLE PKTABLEFORARRAY;

-- Test Array Element Foreign Keys with composite type
CREATE TYPE INVOICEID AS (year_part INTEGER, progressive_part INTEGER);
CREATE TABLE PKTABLEFORARRAY ( id INVOICEID PRIMARY KEY,  ptest2 text);

-- Populate the primary table
INSERT INTO PKTABLEFORARRAY VALUES (ROW(2010, 99), 'Last invoice for 2010');
INSERT INTO PKTABLEFORARRAY VALUES (ROW(2011, 1), 'First invoice for 2011');
INSERT INTO PKTABLEFORARRAY VALUES (ROW(2011, 2), 'Second invoice for 2011');

-- Create the referencing table
CREATE TABLE FKTABLEFORARRAY ( id SERIAL PRIMARY KEY, invoice_ids INVOICEID[], FOREIGN KEY (EACH ELEMENT OF invoice_ids) REFERENCES PKTABLEFORARRAY, ftest2 TEXT );

-- Insert valid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY(invoice_ids, ftest2) VALUES (ARRAY['(2010,99)']::INVOICEID[], 'Product A');
INSERT INTO FKTABLEFORARRAY(invoice_ids, ftest2) VALUES (ARRAY['(2011,1)','(2011,2)']::INVOICEID[], 'Product B');
INSERT INTO FKTABLEFORARRAY(invoice_ids, ftest2) VALUES (ARRAY['(2011,2)']::INVOICEID[], 'Product C');

-- Insert invalid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY(invoice_ids, ftest2) VALUES (ARRAY['(2011,99)']::INVOICEID[], 'Product A');
INSERT INTO FKTABLEFORARRAY(invoice_ids, ftest2) VALUES (ARRAY['(2011,1)','(2010,1)']::INVOICEID[], 'Product B');

-- Check FKTABLE
SELECT * FROM FKTABLEFORARRAY;

-- Delete a row from PK TABLE
DELETE FROM PKTABLEFORARRAY WHERE id=ROW(2010,99);

-- Check FKTABLE for removal of matched row
SELECT * FROM FKTABLEFORARRAY;

-- Update a row from PK TABLE
UPDATE PKTABLEFORARRAY SET id=ROW(2011,99) WHERE id=ROW(2011,1);

-- Check FKTABLE for update of matched row
SELECT * FROM FKTABLEFORARRAY;

-- Cleanup
DROP TABLE FKTABLEFORARRAY;
DROP TABLE PKTABLEFORARRAY;
DROP TYPE INVOICEID;

-- Check for an array column referencing another array column (NOT ELEMENT FOREIGN KEY)
-- Create primary table with an array primary key
CREATE TABLE PKTABLEFORARRAY ( id INT[] PRIMARY KEY,  ptest2 text);

-- Create the referencing table
CREATE TABLE FKTABLEFORARRAY ( id SERIAL PRIMARY KEY, fids INT[] REFERENCES PKTABLEFORARRAY, ftest2 TEXT );

-- Populate the primary table
INSERT INTO PKTABLEFORARRAY VALUES ('{1,1}', 'A');
INSERT INTO PKTABLEFORARRAY VALUES ('{1,2}', 'B');

-- Insert valid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY (fids, ftest2) VALUES ('{1,1}', 'Product A');
INSERT INTO FKTABLEFORARRAY (fids, ftest2) VALUES ('{1,2}', 'Product B');

-- Insert invalid rows into FK TABLE
INSERT INTO FKTABLEFORARRAY (fids, ftest2) VALUES ('{0,1}', 'Product C');
INSERT INTO FKTABLEFORARRAY (fids, ftest2) VALUES ('{2,1}', 'Product D');

-- Cleanup
DROP TABLE FKTABLEFORARRAY;
DROP TABLE PKTABLEFORARRAY;

-- ---------------------------------------
-- Multi-column "ELEMENT" foreign key tests
-- ---------------------------------------

-- Create DIM1 table with two-column primary key
CREATE TABLE DIM1 (X INTEGER NOT NULL, Y INTEGER NOT NULL, PRIMARY KEY (X, Y));
-- Populate DIM1 table pairs
INSERT INTO DIM1 SELECT x.t, x.t * y.t
	FROM (SELECT generate_series(1, 10) AS t) x,
	(SELECT generate_series(0, 10) AS t) y;


-- Test with TABLE declaration of an element foreign key constraint (NO ACTION)
CREATE TABLE F1 (
	x INTEGER PRIMARY KEY, y INTEGER[],
	FOREIGN KEY (x, EACH ELEMENT OF y) REFERENCES DIM1(x, y)
);
-- Insert facts
INSERT INTO F1 VALUES (1, '{0,1,2,3,4,5}'); -- OK
INSERT INTO F1 VALUES (2, '{0,2,4,6}'); -- OK
INSERT INTO F1 VALUES (3, '{0,3,6,9,0,3,6,9,0,0,0,0,9,9}'); -- OK (multiple occurrences)
INSERT INTO F1 VALUES (4, '{0,2,4}'); -- FAILS (2 is not present)
INSERT INTO F1 VALUES (4, '{0,NULL,4}'); -- OK
INSERT INTO F1 VALUES (5, '{0,NULL,5}'); -- OK
-- Try updates
UPDATE F1 SET y = '{0,2,4,6}' WHERE x = 2; -- OK
UPDATE F1 SET y = '{0,2,3,4,6}' WHERE x = 2; -- FAILS
UPDATE F1 SET x = 20, y = '{0,2,3,4,6}' WHERE x = 2; -- FAILS (20 does not exist)
UPDATE F1 SET y = '{0,4,8}' WHERE x = 4; -- OK
UPDATE F1 SET y = '{0,5,NULL,10}' WHERE x = 5; -- OK
DROP TABLE F1;


-- Test with FOREIGN KEY after TABLE population
CREATE TABLE F1 (
	x INTEGER PRIMARY KEY, y INTEGER[]
);
-- Insert facts
INSERT INTO F1 VALUES (1, '{0,1,2,3,4,5}'); -- OK
INSERT INTO F1 VALUES (2, '{0,2,4,6}'); -- OK
INSERT INTO F1 VALUES (3, '{0,3,6,9,0,3,6,9,0,0,0,0,9,9}'); -- OK (multiple occurrences)
INSERT INTO F1 VALUES (4, '{0,2,4}'); -- OK (2 is not present)
INSERT INTO F1 VALUES (5, '{0,NULL,5}'); -- OK
-- Add foreign key (FAILS)
ALTER TABLE F1 ADD FOREIGN KEY (x, EACH ELEMENT OF y) REFERENCES DIM1(x, y);
DROP TABLE F1;


-- Test with TABLE declaration of a two-dim ELEMENT foreign key constraint (FAILS)
CREATE TABLE F1 (
	x INTEGER[] PRIMARY KEY, y INTEGER[],
	FOREIGN KEY (EACH ELEMENT OF x, EACH ELEMENT OF y) REFERENCES DIM1(x, y)
);


-- Test with two-dim ELEMENT foreign key after TABLE population
CREATE TABLE F1 (
	x INTEGER[] PRIMARY KEY, y INTEGER[]
);
INSERT INTO F1 VALUES ('{1}', '{0,1,2,3,4,5}'); -- OK
INSERT INTO F1 VALUES ('{1,2}', '{0,2,4,6}'); -- OK
-- Add foreign key (FAILS)
ALTER TABLE F1 ADD FOREIGN KEY (EACH ELEMENT OF x, EACH ELEMENT OF y) REFERENCES DIM1(x, y);
DROP TABLE F1;

-- Cleanup
DROP TABLE DIM1;


-- Check for potential name conflicts (with internal integrity checks)
CREATE TABLE x1(x1 int, x2 int, PRIMARY KEY(x1,x2));
INSERT INTO x1 VALUES
       (1,4),
       (1,5),
       (2,4),
       (2,5),
       (3,6),
       (3,7)
;
CREATE TABLE x2(x1 int[], x2 int, FOREIGN KEY(EACH ELEMENT OF x1, x2) REFERENCES x1);
INSERT INTO x2 VALUES ('{1,2}',4);
INSERT INTO x2 VALUES ('{1,3}',6); -- FAILS
DROP TABLE x2;
CREATE TABLE x2(x1 int[], x2 int);
INSERT INTO x2 VALUES ('{1,2}',4);
INSERT INTO x2 VALUES ('{1,3}',6);
ALTER TABLE x2 ADD CONSTRAINT fk_const FOREIGN KEY(EACH ELEMENT OF x1, x2) REFERENCES x1;  -- FAILS
DROP TABLE x2;
DROP TABLE x1;


-- ---------------------------------------
-- Multi-dimensional "ELEMENT" foreign key tests
-- ---------------------------------------

-- Create DIM1 table with two-column primary key
CREATE TABLE DIM1 (X INTEGER NOT NULL PRIMARY KEY,
	CODE TEXT NOT NULL UNIQUE);
-- Populate DIM1 table pairs
INSERT INTO DIM1 SELECT t, 'DIM1-' || lpad(t::TEXT, 2, '0')
	FROM (SELECT generate_series(1, 10)) x(t);

-- Test with TABLE declaration of an element foreign key constraint (NO ACTION)
CREATE TABLE F1 (
	ID SERIAL PRIMARY KEY,
	SLOTS INTEGER[3][3], FOREIGN KEY (EACH ELEMENT OF SLOTS) REFERENCES DIM1
);
INSERT INTO F1(SLOTS) VALUES ('{{NULL, 1, NULL}, {NULL, NULL, 3}, {NULL, NULL, 6}}'); -- OK
INSERT INTO F1(SLOTS) VALUES ('{{NULL, 1, NULL}, {NULL, NULL, 11}, {NULL, NULL, 6}}'); -- FAILS
INSERT INTO F1(SLOTS) VALUES ('{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}'); -- OK
INSERT INTO F1(SLOTS) VALUES ('{1, 2, 3, 4, 5, 6, 7, 8, 9}'); -- OK
UPDATE F1 SET SLOTS = '{{NULL, 1, NULL}, {NULL, NULL, 3}, {7, 8, 10}}' WHERE ID = 1; -- OK
UPDATE F1 SET SLOTS = '{{100, 100, 100}, {NULL, NULL, 20}, {7, 8, 10}}' WHERE ID = 1; -- FAILS
DROP TABLE F1;

-- Test with postponed foreign key
CREATE TABLE F1 (
	ID SERIAL PRIMARY KEY,
	SLOTS INTEGER[3][3]
);
INSERT INTO F1(SLOTS) VALUES ('{{NULL, 1, NULL}, {NULL, NULL, 3}, {NULL, NULL, 6}}'); -- OK
INSERT INTO F1(SLOTS) VALUES ('{{NULL, 1, NULL}, {NULL, NULL, 11}, {NULL, NULL, 6}}'); -- OK
INSERT INTO F1(SLOTS) VALUES ('{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}'); -- OK
INSERT INTO F1(SLOTS) VALUES ('{1, 2, 3, 4, 5, 6, 7, 8, 9}'); -- OK
ALTER TABLE F1 ADD FOREIGN KEY (EACH ELEMENT OF SLOTS) REFERENCES DIM1; -- FAILS
DELETE FROM F1 WHERE ID = 2; -- REMOVE ISSUE
ALTER TABLE F1 ADD FOREIGN KEY (EACH ELEMENT OF SLOTS) REFERENCES DIM1; -- NOW OK
INSERT INTO F1(SLOTS) VALUES ('{{NULL, 1, NULL}, {NULL, NULL, 11}, {NULL, NULL, 6}}'); -- FAILS
DROP TABLE F1;

-- Leave tables in the database
CREATE TABLE PKTABLEFORELEMENTFK ( ptest1 int PRIMARY KEY, ptest2 text );
CREATE TABLE FKTABLEFORELEMENTFK ( ftest1 int[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORELEMENTFK, ftest2 int );

-- Check ALTER TABLE ALTER TYPE
ALTER TABLE FKTABLEFORELEMENTFK ALTER FTEST1 TYPE INT[];

-- Check GIN index
-- Define PKTABLEFORARRAYGIN
CREATE TABLE PKTABLEFORARRAYGIN ( ptest1 int PRIMARY KEY, ptest2 text );

-- Insert test data into PKTABLEFORARRAYGIN
INSERT INTO PKTABLEFORARRAYGIN VALUES (1, 'Test1');
INSERT INTO PKTABLEFORARRAYGIN VALUES (2, 'Test2');
INSERT INTO PKTABLEFORARRAYGIN VALUES (3, 'Test3');
INSERT INTO PKTABLEFORARRAYGIN VALUES (4, 'Test4');
INSERT INTO PKTABLEFORARRAYGIN VALUES (5, 'Test5');
INSERT INTO PKTABLEFORARRAYGIN VALUES (6, 'Test6');

-- Define FKTABLEFORARRAYGIN
CREATE TABLE FKTABLEFORARRAYGIN ( ftest1 int[],
    ftest2 int PRIMARY KEY,
    FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORARRAYGIN
    ON DELETE NO ACTION ON UPDATE NO ACTION);

-- -- Create index on FKTABLEFORARRAYGIN
CREATE INDEX ON FKTABLEFORARRAYGIN USING gin (ftest1 array_ops);

-- Populate Table
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{5}', 1);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{3,2}', 2);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{3,5,2,5}', 3);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{3,4,4}', 4);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{3,5,4,1,3}', 5);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{1}', 6);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{5,1}', 7);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{2,1,2,4,1}', 8);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{4,2}', 9);
INSERT INTO FKTABLEFORARRAYGIN VALUES ('{3,4,5,3}', 10);

-- Try UPDATE
UPDATE PKTABLEFORARRAYGIN SET ptest1=7 WHERE ptest1=6;

--- Try using the indexable operators
SELECT COUNT(*) FROM FKTABLEFORARRAYGIN;
SELECT COUNT(*) FROM FKTABLEFORARRAYGIN WHERE ftest1 @> ARRAY[5];
SELECT COUNT(*) FROM FKTABLEFORARRAYGIN WHERE ftest1 @>> 5;

-- Cleanup
DROP TABLE FKTABLEFORARRAYGIN;
DROP TABLE PKTABLEFORARRAYGIN;

-- ---------------------------------------
-- Invalid referencing key tests
-- ---------------------------------------
CREATE TABLE PKTABLEVIOLATING ( ptest1 int PRIMARY KEY, ptest2 text );

-- Attempt fk constraint between int <-> int
CREATE TABLE FKTABLEVIOLATING ( ftest1 int, FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORELEMENTFK, ftest2 int );

-- Attempt fk constraint between int <-> char[]
CREATE TABLE FKTABLEVIOLATING ( ftest1 char[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORELEMENTFK, ftest2 int );

-- Attempt fk constraint between int <-> char
CREATE TABLE FKTABLEVIOLATING ( ftest1 char, FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORELEMENTFK, ftest2 int );

-- Attempt fk constraint between int <-> smallint[]
CREATE TABLE FKTABLEVIOLATING ( ftest1 smallint[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORELEMENTFK, ftest2 int );

-- Attempt fk constraint between int <-> bigint[]
CREATE TABLE FKTABLEVIOLATING ( ftest1 bigint[], FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORELEMENTFK, ftest2 int );

-- Attempt fk constraint between int <-> int2vector
CREATE TABLE FKTABLEVIOLATING ( ftest1 int2vector, FOREIGN KEY (EACH ELEMENT OF ftest1) REFERENCES PKTABLEFORELEMENTFK, ftest2 int );
