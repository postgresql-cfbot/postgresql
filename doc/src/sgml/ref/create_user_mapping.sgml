<!--
doc/src/sgml/ref/create_user_mapping.sgml
PostgreSQL documentation
-->

<refentry id="sql-createusermapping">
 <indexterm zone="sql-createusermapping">
  <primary>CREATE USER MAPPING</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE USER MAPPING</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE USER MAPPING</refname>
  <refpurpose>define a new mapping of a user to a foreign server</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE USER MAPPING [ IF NOT EXISTS ] FOR { <replaceable class="parameter">user_name</replaceable> | USER | CURRENT_ROLE | CURRENT_USER | PUBLIC }
    SERVER <replaceable class="parameter">server_name</replaceable>
    [ OPTIONS ( <replaceable class="parameter">option</replaceable> '<replaceable class="parameter">value</replaceable>' [ , ... ] ) ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>

  <para>
   <command>CREATE USER MAPPING</command> defines a mapping of a user
   to a foreign server.  A user mapping typically encapsulates
   connection information that a foreign-data wrapper uses together
   with the information encapsulated by a foreign server to access an
   external data resource.
  </para>

  <para>
   The owner of a foreign server can create user mappings for that
   server for any user.  Also, a user can create a user mapping for
   their own user name if <literal>USAGE</literal> privilege on the server has
   been granted to the user.
  </para>
 </refsect1>

 <refsect1>
  <title>Parameters</title>

  <variablelist>
  <varlistentry>
    <term><literal>IF NOT EXISTS</literal></term>
    <listitem>
     <para>
      Do not throw an error if a mapping of the given user to the given foreign
      server already exists. A notice is issued in this case.  Note that there
      is no guarantee that the existing user mapping is anything like the one
      that would have been created.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">user_name</replaceable></term>
    <listitem>
     <para>
      The name of an existing user that is mapped to foreign server.
      <literal>CURRENT_ROLE</literal>, <literal>CURRENT_USER</literal>, and <literal>USER</literal> match the name of
      the current user.  When <literal>PUBLIC</literal> is specified, a
      so-called public mapping is created that is used when no
      user-specific mapping is applicable.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">server_name</replaceable></term>
    <listitem>
     <para>
      The name of an existing server for which the user mapping is
      to be created.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OPTIONS ( <replaceable class="parameter">option</replaceable> '<replaceable class="parameter">value</replaceable>' [, ... ] )</literal></term>
    <listitem>
     <para>
      This clause specifies the options of the user mapping.  The
      options typically define the actual user name and password of
      the mapping.  Option names must be unique.  The allowed option
      names and values are specific to the server's foreign-data wrapper.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Notes</title>

  <refsect2 id="usermapping-connection-only-options" xreflabel="FOR CONNECTION ONLY Options">
   <title><literal>FOR CONNECTION ONLY</literal> Options</title>

   <para>
    If <replaceable>servername</replaceable> is specified as <literal>FOR
    CONNECTION ONLY</literal>, the user mapping supports the following options:

    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>user</literal>, <literal>password</literal> and
       <literal>sslpassword</literal> - these options have the same meaning as
       described in <xref linkend="libpq-paramkeywords"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>sslkey</literal> and <literal>sslcert</literal> - these have
       the same meaning as described in as described in <xref
       linkend="libpq-paramkeywords"/>, and override any settings of the same
       name in <replaceable>servername</replaceable>.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>password_required</literal> means that this user mapping must
       specify the <literal>password</literal> option. The
       <literal>password_required</literal> option defaults to
       <literal>true</literal> and can only be set to <literal>false</literal>
       by a superuser.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Only superusers may create or modify user mappings with the
    <literal>sslcert</literal> or <literal>sslkey</literal> settings.
   </para>
   <para>
    Non-superusers may connect to foreign servers using password
    authentication or with GSSAPI delegated credentials, so specify the
    <literal>password</literal> option for user mappings belonging to
    non-superusers where password authentication is required.
   </para>
   <para>
    A superuser may override this check on a per-user-mapping basis by setting
    the user mapping option <literal>password_required 'false'</literal>, e.g.,
<programlisting>
ALTER USER MAPPING FOR some_non_superuser SERVER loopback_nopw
OPTIONS (ADD password_required 'false');
</programlisting>
    To prevent unprivileged users from exploiting the authentication rights
    of the unix user the postgres server is running as to escalate to superuser
    rights, only the superuser may set this option on a user mapping.
    </para>
    <para>
    Care is required to ensure that this does not allow the mapped
    user the ability to connect as superuser to the mapped database per
    CVE-2007-3278 and CVE-2007-6601. Don't set
    <literal>password_required=false</literal>
    on the <literal>public</literal> role. Keep in mind that the mapped
    user can potentially use any client certificates,
    <filename>.pgpass</filename>,
    <filename>.pg_service.conf</filename> etc. in the unix home directory of the
    system user the postgres server runs as. They can also use any trust
    relationship granted by authentication modes like <literal>peer</literal>
    or <literal>ident</literal> authentication.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>Examples</title>

  <para>
   Create a user mapping for user <literal>bob</literal>, server <literal>foo</literal>:
<programlisting>
CREATE USER MAPPING FOR bob SERVER foo OPTIONS (user 'bob', password 'secret');
</programlisting></para>

 </refsect1>

 <refsect1>
  <title>Compatibility</title>

  <para>
   <command>CREATE USER MAPPING</command> conforms to ISO/IEC 9075-9 (SQL/MED).
  </para>
 </refsect1>

 <refsect1>
  <title>See Also</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterusermapping"/></member>
   <member><xref linkend="sql-dropusermapping"/></member>
   <member><xref linkend="sql-createforeigndatawrapper"/></member>
   <member><xref linkend="sql-createserver"/></member>
  </simplelist>
 </refsect1>

</refentry>
