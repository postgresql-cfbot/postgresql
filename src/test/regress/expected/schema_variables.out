CREATE VARIABLE var1 AS integer;
CREATE TEMP VARIABLE var2 AS text;
DROP VARIABLE var1, var2;
-- functional interface
CREATE VARIABLE var1 AS numeric;
CREATE ROLE var_test_role;
SET ROLE TO var_test_role;
-- should to fail
SELECT var1;
ERROR:  permission denied for schema variable var1
SET ROLE TO DEFAULT;
GRANT READ ON VARIABLE var1 TO var_test_role;
SET ROLE TO var_test_role;
-- should to fail
LET var1 = 10;
ERROR:  permission denied for schema variable var1
-- should to work
SELECT var1;
 var1 
------
     
(1 row)

SET ROLE TO DEFAULT;
GRANT WRITE ON VARIABLE var1 TO var_test_role;
SET ROLE TO var_test_role;
-- should to work
LET var1 = 333;
SET ROLE TO DEFAULT;
REVOKE ALL ON VARIABLE var1 FROM var_test_role;
CREATE OR REPLACE FUNCTION secure_var()
RETURNS int AS $$
  SELECT public.var1::int;
$$ LANGUAGE sql SECURITY DEFINER;
SELECT secure_var();
 secure_var 
------------
        333
(1 row)

SET ROLE TO var_test_role;
-- should to fail
SELECT public.var1;
ERROR:  permission denied for schema variable var1
-- should to work;
SELECT secure_var();
 secure_var 
------------
        333
(1 row)

SET ROLE TO DEFAULT;
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM generate_series(1,100) g(v) WHERE v = var1;
                  QUERY PLAN                   
-----------------------------------------------
 Function Scan on pg_catalog.generate_series g
   Output: v
   Function Call: generate_series(1, 100)
   Filter: ((g.v)::numeric = var1)
(4 rows)

CREATE VIEW schema_var_view AS SELECT var1;
SELECT * FROM schema_var_view;
 var1 
------
  333
(1 row)

\c -
-- should to work still, but var will be empty
SELECT * FROM schema_var_view;
 var1 
------
     
(1 row)

LET var1 = pi();
SELECT var1;
       var1       
------------------
 3.14159265358979
(1 row)

-- we can look on execution plan
EXPLAIN (VERBOSE, COSTS OFF) LET var1 = pi();
         QUERY PLAN         
----------------------------
 Result
   Output: 3.14159265358979
(2 rows)

-- LET can be prepared
PREPARE var_pp(int, numeric) AS LET var1 = $1 + $2;
EXECUTE var_pp(100, 1.23456);
SELECT var1;
   var1    
-----------
 101.23456
(1 row)

CREATE VARIABLE var3 AS int;
CREATE OR REPLACE FUNCTION inc(int)
RETURNS int AS $$
BEGIN
  LET public.var3 = COALESCE(public.var3 + $1, $1);
  RETURN var3;
END;
$$ LANGUAGE plpgsql;
SELECT inc(1);
 inc 
-----
   1
(1 row)

SELECT inc(1);
 inc 
-----
   2
(1 row)

SELECT inc(1);
 inc 
-----
   3
(1 row)

SELECT inc(1) FROM generate_series(1,10);
 inc 
-----
   4
   5
   6
   7
   8
   9
  10
  11
  12
  13
(10 rows)

SET ROLE TO var_test_role;
-- should to fail
LET var3 = 0;
ERROR:  permission denied for schema variable var3
SET ROLE TO DEFAULT;
DROP VIEW schema_var_view;
DROP VARIABLE var1 CASCADE;
DROP VARIABLE var3 CASCADE;
-- composite variables
CREATE TYPE sv_xyz AS (x int, y int, z numeric(10,2));
CREATE VARIABLE v1 AS sv_xyz;
CREATE VARIABLE v2 AS sv_xyz;
\d v1
\d v2
LET v1 = (1,2,3.14);
LET v2 = (10,20,3.14*10);
-- should to work too - there are prepared casts
LET v1 = (1,2,3.14);
SELECT v1;
     v1     
------------
 (1,2,3.14)
(1 row)

SELECT v2;
      v2       
---------------
 (10,20,31.40)
(1 row)

SELECT (v1).*;
 x | y |  z   
---+---+------
 1 | 2 | 3.14
(1 row)

SELECT (v2).*;
 x  | y  |   z   
----+----+-------
 10 | 20 | 31.40
(1 row)

SELECT v1.x + v1.z;
 ?column? 
----------
     4.14
(1 row)

SELECT v2.x + v2.z;
 ?column? 
----------
    41.40
(1 row)

-- access to composite fields should be safe too
-- should to fail
SET ROLE TO var_test_role;
SELECT v2.x;
ERROR:  permission denied for schema variable v2
SET ROLE TO DEFAULT;
DROP VARIABLE v1;
DROP VARIABLE v2;
DROP ROLE var_test_role;
-- scalar variables should not be in conflict with qualified column
CREATE VARIABLE varx AS text;
SELECT varx.relname FROM pg_class varx WHERE varx.relname = 'pg_class';
 relname  
----------
 pg_class
(1 row)

-- should to fail
SELECT varx.xxx;
ERROR:  type text is not composite
-- variables can be updated under RO transaction
BEGIN;
SET TRANSACTION READ ONLY;
LET varx = 'hello';
COMMIT;
SELECT varx;
 varx  
-------
 hello
(1 row)

DROP VARIABLE varx;
CREATE TYPE t1 AS (a int, b numeric, c text);
CREATE VARIABLE v1 AS t1;
LET v1 = (1, pi(), 'hello');
SELECT v1;
             v1             
----------------------------
 (1,3.14159265358979,hello)
(1 row)

LET v1.b = 10.2222;
SELECT v1;
        v1         
-------------------
 (1,10.2222,hello)
(1 row)

-- should to fail
LET v1.x = 10;
ERROR:  cannot assign to field "x" of column "x" because there is no such column in data type t1
LINE 1: LET v1.x = 10;
            ^
DROP VARIABLE v1;
DROP TYPE t1;
-- arrays are supported
CREATE VARIABLE va1 AS numeric[];
LET va1 = ARRAY[1.1,2.1];
LET va1[1] = 10.1;
SELECT va1;
    va1     
------------
 {10.1,2.1}
(1 row)

CREATE TYPE ta2 AS (a numeric, b numeric[]);
CREATE VARIABLE va2 AS ta2;
LET va2 = (10.1, ARRAY[0.0, 0.0]);
LET va2.a = 10.2;
SELECT va2;
        va2         
--------------------
 (10.2,"{0.0,0.0}")
(1 row)

LET va2.b[1] = 10.3;
SELECT va2;
         va2         
---------------------
 (10.2,"{10.3,0.0}")
(1 row)

DROP VARIABLE va1;
DROP VARIABLE va2;
DROP TYPE ta2;
-- default values
CREATE VARIABLE v1 AS numeric DEFAULT pi();
LET v1 = v1 * 2;
SELECT v1;
        v1        
------------------
 6.28318530717958
(1 row)

CREATE TYPE t2 AS (a numeric, b text);
CREATE VARIABLE v2 AS t2 DEFAULT (NULL, 'Hello');
LET public.v2.a = pi();
SELECT v2;
            v2            
--------------------------
 (3.14159265358979,Hello)
(1 row)

-- shoudl fail due dependency
DROP TYPE t2;
ERROR:  cannot drop type t2 because other objects depend on it
DETAIL:  schema variable v2 depends on type t2
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-- should be ok
DROP VARIABLE v1;
DROP VARIABLE v2;
-- tests of alters
CREATE SCHEMA var_schema1;
CREATE SCHEMA var_schema2;
CREATE VARIABLE var_schema1.var1 AS integer;
LET var_schema1.var1 = 1000;
SELECT var_schema1.var1;
 var1 
------
 1000
(1 row)

ALTER VARIABLE var_schema1.var1 SET SCHEMA var_schema2;
SELECT var_schema2.var1;
 var1 
------
 1000
(1 row)

CREATE ROLE var_test_role;
ALTER VARIABLE var_schema2.var1 OWNER TO var_test_role;
SET ROLE TO var_test_role;
-- should fail, no access to schema var_schema2.var
SELECT var_schema2.var1;
ERROR:  permission denied for schema var_schema2
DROP VARIABLE var_schema2.var1;
ERROR:  permission denied for schema var_schema2
SET ROLE TO DEFAULT;
ALTER VARIABLE var_schema2.var1 SET SCHEMA public;
SET ROLE TO var_test_role;
SELECT public.var1;
 var1 
------
 1000
(1 row)

ALTER VARIABLE public.var1 RENAME TO var1_renamed;
SELECT public.var1_renamed;
 var1_renamed 
--------------
         1000
(1 row)

DROP VARIABLE public.var1_renamed;
SET ROLE TO DEFAULt;
DROP ROLE var_test_role;
CREATE VARIABLE xx AS text DEFAULT 'hello';
SELECT xx, upper(xx);
  xx   | upper 
-------+-------
 hello | HELLO
(1 row)

LET xx = 'Hi';
SELECT xx;
 xx 
----
 Hi
(1 row)

DROP VARIABLE xx;
-- ON TRANSACTION END RESET tests
CREATE VARIABLE t1 AS int DEFAULT -1 ON TRANSACTION END RESET;
BEGIN;
  SELECT t1;
 t1 
----
 -1
(1 row)

  LET t1 = 100;
  SELECT t1;
 t1  
-----
 100
(1 row)

COMMIT;
SELECT t1;
 t1 
----
 -1
(1 row)

BEGIN;
  SELECT t1;
 t1 
----
 -1
(1 row)

  LET t1 = 100;
  SELECT t1;
 t1  
-----
 100
(1 row)

ROLLBACK;
SELECT t1;
 t1 
----
 -1
(1 row)

DROP VARIABLE t1;
CREATE VARIABLE v1 AS int DEFAULT 0;
CREATE VARIABLE v2 AS text DEFAULT 'none';
LET v1 = 100;
LET v2 = 'Hello';
SELECT v1, v2;
 v1  |  v2   
-----+-------
 100 | Hello
(1 row)

LET v1 = DEFAULT;
LET v2 = DEFAULT;
SELECT v1, v2;
 v1 |  v2  
----+------
  0 | none
(1 row)

DROP VARIABLE v1;
DROP VARIABLE v2;
-- ON COMMIT DROP tests
-- should be 0 always
SELECT count(*) FROM pg_variable;
 count 
-------
     0
(1 row)

CREATE TEMP VARIABLE g AS int ON COMMIT DROP;
SELECT count(*) FROM pg_variable;
 count 
-------
     0
(1 row)

BEGIN;
  CREATE TEMP VARIABLE g AS int ON COMMIT DROP;
COMMIT;
SELECT count(*) FROM pg_variable;
 count 
-------
     0
(1 row)

BEGIN;
  CREATE TEMP VARIABLE g AS int ON COMMIT DROP;
ROLLBACK;
SELECT count(*) FROM pg_variable;
 count 
-------
     0
(1 row)

-- test on query with workers
CREATE TABLE svar_test(a int);
INSERT INTO svar_test SELECT * FROM generate_series(1,1000000);
ANALYZE svar_test;
CREATE VARIABLE zero int;
LET zero = 0;
-- parallel workers should be used
EXPLAIN (costs off) SELECT count(*) FROM svar_test WHERE a%10 = zero;
                    QUERY PLAN                    
--------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Parallel Seq Scan on svar_test
                     Filter: ((a % 10) = zero)
(6 rows)

-- result should be 100000
SELECT count(*) FROM svar_test WHERE a%10 = zero;
 count  
--------
 100000
(1 row)

DROP TABLE svar_test;
DROP VARIABLE zero;
-- using variables in views, prepared statements
CREATE VARIABLE v AS numeric;
LET v = 3.14;
PREPARE pv1(int) AS LET v = v + $1;
PREPARE pv2 AS SELECT v;
EXECUTE pv1(1000);
EXECUTE pv2;
    v    
---------
 1003.14
(1 row)

CREATE VIEW vv AS SELECT COALESCE(v, 0) + 1000 AS result;
SELECT * FROM vv;
 result  
---------
 2003.14
(1 row)

-- start new session
\c
SELECT * FROM vv;
 result 
--------
   1000
(1 row)

LET v = 3.14;
SELECT * FROM vv;
 result  
---------
 1003.14
(1 row)

-- should to fail, dependency
DROP VARIABLE v;
ERROR:  cannot drop schema variable v because other objects depend on it
DETAIL:  view vv depends on schema variable v
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-- should be ok
DROP VARIABLE v CASCADE;
NOTICE:  drop cascades to view vv
-- other features
CREATE VARIABLE dt AS integer DEFAULT 0;
LET dt = 100;
SELECT dt;
 dt  
-----
 100
(1 row)

DISCARD VARIABLES;
SELECT dt;
 dt 
----
  0
(1 row)

DROP VARIABLE dt;
-- NOT NULL
CREATE VARIABLE v1 AS int NOT NULL;
CREATE VARIABLE v2 AS int NOT NULL DEFAULT NULL;
-- should to fail
SELECT v1;
ERROR:  null value is not allowed for NOT NULL schema variable "v1"
DETAIL:  The schema variable was not initialized yet.
SELECT v2;
ERROR:  null value is not allowed for NOT NULL schema variable "v2"
LET v1 = NULL;
ERROR:  null value is not allowed for NOT NULL schema variable "v1"
LET v2 = NULL;
ERROR:  null value is not allowed for NOT NULL schema variable "v2"
LET v1 = DEFAULT;
ERROR:  null value is not allowed for NOT NULL schema variable "v1"
DETAIL:  The schema variable was not initialized yet.
LET v2 = DEFAULT;
ERROR:  null value is not allowed for NOT NULL schema variable "v2"
-- should be ok
LET v1 = 100;
LET v2 = 1000;
SELECT v1, v2;
 v1  |  v2  
-----+------
 100 | 1000
(1 row)

DROP VARIABLE v1;
DROP VARIABLE v2;
-- test transactional variables
CREATE TRANSACTION VARIABLE tv AS int DEFAULT 0;
BEGIN;
  LET tv = 100;
  SELECT tv;
 tv  
-----
 100
(1 row)

ROLLBACK;
SELECT tv;
 tv 
----
  0
(1 row)

LET tv = 100;
BEGIN;
  LET tv = 1000;
COMMIT;
SELECT tv;
  tv  
------
 1000
(1 row)

BEGIN;
  LET tv = DEFAULT;
  SELECT tv;
 tv 
----
  0
(1 row)

ROLLBACK;
SELECT tv;
  tv  
------
 1000
(1 row)

-- test subtransactions
BEGIN;
  LET tv = 1;
SAVEPOINT x1;
  LET tv = 2;
SAVEPOINT x2;
  LET tv = 3;
ROLLBACK TO x2;
  SELECT tv;
 tv 
----
  2
(1 row)

  LET tv = 10;
ROLLBACK TO x1;
  SELECT tv;
 tv 
----
  1
(1 row)

ROLLBACK;
SELECT tv;
  tv  
------
 1000
(1 row)

BEGIN;
  LET tv = 1;
SAVEPOINT x1;
  LET tv = 2;
SAVEPOINT x2;
  LET tv = 3;
ROLLBACK TO x2;
  SELECT tv;
 tv 
----
  2
(1 row)

  LET tv = 10;
ROLLBACK TO x1;
  SELECT tv;
 tv 
----
  1
(1 row)

COMMIT;
SELECT tv;
 tv 
----
  1
(1 row)

