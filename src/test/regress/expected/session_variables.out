CREATE ROLE regress_variable_owner;
-- should be ok
CREATE VARIABLE var1 AS int;
-- should fail, pseudotypes are not allowed
CREATE VARIABLE var2 AS anyelement;
ERROR:  session variable cannot be pseudo-type anyelement
-- should be ok, do nothing
DROP VARIABLE IF EXISTS var2;
NOTICE:  session variable "var2" does not exist, skipping
-- do nothing
CREATE VARIABLE IF NOT EXISTS var1 AS int;
NOTICE:  session variable "var1" already exists, skipping
-- should fail
CREATE VARIABLE var1 AS int;
ERROR:  session variable "var1" already exists
-- should be ok
DROP VARIABLE IF EXISTS var1;
-- check comment on variable
CREATE VARIABLE var1 AS int;
COMMENT ON VARIABLE var1 IS 'some variable comment';
SELECT pg_catalog.obj_description(oid, 'pg_variable') FROM pg_variable WHERE varname = 'var1';
    obj_description    
-----------------------
 some variable comment
(1 row)

DROP VARIABLE var1;
--- check access rights and supported ALTER
CREATE SCHEMA svartest;
GRANT ALL ON SCHEMA svartest TO regress_variable_owner;
CREATE VARIABLE svartest.var1 AS int;
CREATE ROLE regress_variable_reader;
GRANT SELECT ON VARIABLE svartest.var1 TO regress_variable_reader;
REVOKE ALL ON VARIABLE svartest.var1 FROM regress_variable_reader;
ALTER VARIABLE svartest.var1 OWNER TO regress_variable_owner;
ALTER VARIABLE svartest.var1 RENAME TO varxx;
ALTER VARIABLE svartest.varxx SET SCHEMA public;
DROP VARIABLE public.varxx;
ALTER DEFAULT PRIVILEGES
   FOR ROLE regress_variable_owner
   IN SCHEMA svartest
   GRANT SELECT ON VARIABLES TO regress_variable_reader;
-- creating variable with default privileges
SET ROLE TO regress_variable_owner;
CREATE VARIABLE svartest.var1 AS int;
SET ROLE TO DEFAULT;
\dV+ svartest.var1
                                                                                             List of variables
  Schema  | Name |  Type   | Collation |         Owner          | Nullable | Mutable | Transactional | Default | Transactional end action |                Access privileges                 | Description 
----------+------+---------+-----------+------------------------+----------+---------+---------------+---------+--------------------------+--------------------------------------------------+-------------
 svartest | var1 | integer |           | regress_variable_owner | t        | t       | f             |         |                          | regress_variable_owner=rw/regress_variable_owner+| 
          |      |         |           |                        |          |         |               |         |                          | regress_variable_reader=r/regress_variable_owner | 
(1 row)

DROP VARIABLE svartest.var1;
DROP SCHEMA svartest;
DROP ROLE regress_variable_owner;
-- check access rights
CREATE ROLE regress_noowner;
CREATE VARIABLE var1 AS int;
CREATE OR REPLACE FUNCTION sqlfx(int)
RETURNS int AS $$ SELECT $1 + var1 $$ LANGUAGE sql;
CREATE OR REPLACE FUNCTION sqlfx_sd(int)
RETURNS int AS $$ SELECT $1 + var1 $$ LANGUAGE sql SECURITY DEFINER;
CREATE OR REPLACE FUNCTION plpgsqlfx(int)
RETURNS int AS $$ BEGIN RETURN $1 + var1; END $$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION plpgsqlfx_sd(int)
RETURNS int AS $$ BEGIN RETURN $1 + var1; END $$ LANGUAGE plpgsql SECURITY DEFINER;
LET var1 = 10;
-- should be ok
SELECT var1;
 var1 
------
   10
(1 row)

SELECT sqlfx(20);
 sqlfx 
-------
    30
(1 row)

SELECT sqlfx_sd(20);
 sqlfx_sd 
----------
       30
(1 row)

SELECT plpgsqlfx(20);
 plpgsqlfx 
-----------
        30
(1 row)

SELECT plpgsqlfx_sd(20);
 plpgsqlfx_sd 
--------------
           30
(1 row)

-- should to fail
SET ROLE TO regress_noowner;
SELECT var1;
ERROR:  permission denied for session variable var1
SELECT sqlfx(20);
ERROR:  permission denied for session variable var1
SELECT plpgsqlfx(20);
ERROR:  permission denied for session variable var1
CONTEXT:  PL/pgSQL function plpgsqlfx(integer) line 1 at RETURN
-- should be ok
SELECT sqlfx_sd(20);
 sqlfx_sd 
----------
       30
(1 row)

SELECT plpgsqlfx_sd(20);
 plpgsqlfx_sd 
--------------
           30
(1 row)

SET ROLE TO DEFAULT;
GRANT SELECT ON VARIABLE var1 TO regress_noowner;
-- should be ok
SET ROLE TO regress_noowner;
SELECT var1;
 var1 
------
   10
(1 row)

SELECT sqlfx(20);
 sqlfx 
-------
    30
(1 row)

SELECT plpgsqlfx(20);
 plpgsqlfx 
-----------
        30
(1 row)

SET ROLE TO DEFAULT;
DROP VARIABLE var1;
DROP FUNCTION sqlfx(int);
DROP FUNCTION plpgsqlfx(int);
DROP FUNCTION sqlfx_sd(int);
DROP FUNCTION plpgsqlfx_sd(int);
DROP ROLE regress_noowner;
-- use variables inside views
CREATE VARIABLE var1 AS numeric;
-- use variables in views
CREATE VIEW test_view AS SELECT COALESCE(var1 + v, 0) AS result FROM generate_series(1,2) g(v);
SELECT * FROM test_view;
 result 
--------
      0
      0
(2 rows)

LET var1 = 3.14;
SELECT * FROM test_view;
 result 
--------
   4.14
   5.14
(2 rows)

-- start a new session
\c
SELECT * FROM test_view;
 result 
--------
      0
      0
(2 rows)

LET var1 = 3.14;
SELECT * FROM test_view;
 result 
--------
   4.14
   5.14
(2 rows)

-- should fail, dependency
DROP VARIABLE var1;
ERROR:  cannot drop session variable var1 because other objects depend on it
DETAIL:  view test_view depends on session variable var1
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-- should be ok
DROP VARIABLE var1 CASCADE;
NOTICE:  drop cascades to view test_view
CREATE VARIABLE var1 text;
CREATE VARIABLE var2 text;
-- use variables in SQL functions
CREATE OR REPLACE FUNCTION sqlfx1(varchar)
RETURNS varchar AS $$ SELECT var1 || ', ' || $1 $$ LANGUAGE sql;
CREATE OR REPLACE FUNCTION sqlfx2( varchar)
RETURNS varchar AS $$ SELECT var2 || ', ' || $1 $$ LANGUAGE sql;
LET var1 = 'str1';
LET var2 = 'str2';
SELECT sqlfx1(sqlfx2('Hello'));
      sqlfx1       
-------------------
 str1, str2, Hello
(1 row)

-- inlining is blocked
EXPLAIN (COSTS OFF, VERBOSE) SELECT sqlfx1(sqlfx2('Hello'));
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Result
   Output: ((var1 || ', '::text) || ((var2 || ', '::text) || 'Hello'::text))
(2 rows)

DROP FUNCTION sqlfx1(varchar);
DROP FUNCTION sqlfx2(varchar);
DROP VARIABLE var1;
DROP VARIABLE var2;
-- access from cached plans should to work
CREATE VARIABLE var1 AS numeric;
CREATE OR REPLACE FUNCTION plpgsqlfx()
RETURNS numeric AS $$ BEGIN RETURN var1; END $$ LANGUAGE plpgsql;
set plan_cache_mode TO force_generic_plan;
LET var1 = 3.14;
SELECT plpgsqlfx();
 plpgsqlfx 
-----------
      3.14
(1 row)

LET var1 = 3.14 * 2;
SELECT plpgsqlfx();
 plpgsqlfx 
-----------
      6.28
(1 row)

DROP VARIABLE var1;
-- dependency (plan invalidation) should to work
CREATE VARIABLE var1 AS numeric;
LET var1 = 3.14 * 3;
SELECT plpgsqlfx();
 plpgsqlfx 
-----------
      9.42
(1 row)

LET var1 = 3.14 * 4;
SELECT plpgsqlfx();
 plpgsqlfx 
-----------
     12.56
(1 row)

DROP VARIABLE var1;
DROP FUNCTION plpgsqlfx();
set plan_cache_mode TO DEFAULT;
-- usage LET statement in plpgsql should to work
CREATE VARIABLE var1 int;
CREATE VARIABLE var2 numeric[];
DO $$
BEGIN
  LET var2 = '{}'::int[];
  FOR i IN 1..10
  LOOP
    LET var1 = i;
    LET var2[var1] = i;
  END LOOP;
  RAISE NOTICE 'result array: %', var2;
END;
$$;
NOTICE:  result array: {1,2,3,4,5,6,7,8,9,10}
DROP VARIABLE var1;
DROP VARIABLE var2;
-- CALL statement is supported
CREATE VARIABLE v int;
LET v = 1;
CREATE PROCEDURE p(arg int) AS $$ BEGIN RAISE NOTICE '%', arg; END $$ LANGUAGE plpgsql;
-- should to work
CALL p(v);
NOTICE:  1
DO $$ BEGIN CALL p(v); END $$;
NOTICE:  1
DROP PROCEDURE p(int);
DROP VARIABLE v;
-- test search path
CREATE SCHEMA svartest;
CREATE VARIABLE svartest.var1 AS numeric;
-- should to fail
LET var1 = pi();
ERROR:  session variable "var1" doesn't exist
LINE 1: LET var1 = pi();
            ^
SELECT var1;
ERROR:  column or variable "var1" does not exist
LINE 1: SELECT var1;
               ^
-- should be ok
LET svartest.var1 = pi();
SELECT svartest.var1;
       var1       
------------------
 3.14159265358979
(1 row)

SET search_path TO svartest;
-- should be ok
LET var1 = pi() + 10;
SELECT var1;
       var1       
------------------
 13.1415926535898
(1 row)

RESET search_path;
DROP SCHEMA svartest CASCADE;
NOTICE:  drop cascades to session variable svartest.var1
CREATE VARIABLE var1 AS text;
-- variables can be updated under RO transaction
BEGIN;
SET TRANSACTION READ ONLY;
LET var1 = 'hello';
COMMIT;
SELECT var1;
 var1  
-------
 hello
(1 row)

DROP VARIABLE var1;
-- test of domains
CREATE DOMAIN int_domain AS int NOT NULL CHECK (VALUE > 100);
CREATE VARIABLE var1 AS int_domain;
-- should fail
SELECT var1;
ERROR:  domain int_domain does not allow null values
-- should be ok
LET var1 = 1000;
SELECT var1;
 var1 
------
 1000
(1 row)

-- should fail
LET var1 = 10;
ERROR:  value for domain int_domain violates check constraint "int_domain_check"
-- should fail
LET var1 = NULL;
-- note - domain defaults are not supported yet (like PLpgSQL)
DROP VARIABLE var1;
DROP DOMAIN int_domain;
CREATE SCHEMA svartest CREATE VARIABLE var1 AS int CREATE TABLE foo(a int);
LET svartest.var1 = 100;
SELECT svartest.var1;
 var1 
------
  100
(1 row)

SET search_path to public, svartest;
SELECT var1;
 var1 
------
  100
(1 row)

DROP SCHEMA svartest CASCADE;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table foo
drop cascades to session variable var1
CREATE VARIABLE var1 AS int;
CREATE VARIABLE var2 AS int[];
LET var1 = 2;
LET var2 = '{}'::int[];
LET var2[var1] = 0;
SELECT var2;
   var2    
-----------
 [2:2]={0}
(1 row)

DROP VARIABLE var1, var2;
CREATE VARIABLE var1 AS int;
CREATE VARIABLE var2 AS int[];
LET var1 = 2;
LET var2 = '{}'::int[];
SELECT var2;
 var2 
------
 {}
(1 row)

DROP VARIABLE var1, var2;
-- the LET statement should be disallowed in CTE
CREATE VARIABLE var1 AS int;
WITH x AS (LET var1 = 100) SELECT * FROM x;
ERROR:  LET not supported in WITH query
LINE 1: WITH x AS (LET var1 = 100) SELECT * FROM x;
             ^
-- should be ok
LET var1 = generate_series(1, 1);
-- should fail
LET var1 = generate_series(1, 2);
ERROR:  expression returned more than one row
LET var1 = generate_series(1, 0);
ERROR:  expression returned no rows
DROP VARIABLE var1;
-- composite variables
CREATE TYPE sv_xyz AS (x int, y int, z numeric(10,2));
CREATE VARIABLE v1 AS sv_xyz;
CREATE VARIABLE v2 AS sv_xyz;
LET v1 = (1, 2, 3.14);
LET v2 = (10, 20, 3.14 * 10);
-- should work too - there are prepared casts
LET v1 = (1, 2, 3);
SELECT v1;
     v1     
------------
 (1,2,3.00)
(1 row)

SELECT v2;
      v2       
---------------
 (10,20,31.40)
(1 row)

SELECT (v1).*;
 x | y |  z   
---+---+------
 1 | 2 | 3.00
(1 row)

SELECT (v2).*;
 x  | y  |   z   
----+----+-------
 10 | 20 | 31.40
(1 row)

SELECT v1.x + v1.z;
 ?column? 
----------
     4.00
(1 row)

SELECT v2.x + v2.z;
 ?column? 
----------
    41.40
(1 row)

-- access to composite fields should be safe too
CREATE ROLE regress_var_test_role;
SET ROLE TO regress_var_test_role;
-- should fail
SELECT v2.x;
ERROR:  permission denied for session variable v2
SET ROLE TO DEFAULT;
DROP VARIABLE v1;
DROP VARIABLE v2;
DROP ROLE regress_var_test_role;
CREATE TYPE t1 AS (a int, b numeric, c text);
CREATE VARIABLE v1 AS t1;
LET v1 = (1, pi(), 'hello');
SELECT v1;
             v1             
----------------------------
 (1,3.14159265358979,hello)
(1 row)

LET v1.b = 10.2222;
SELECT v1;
        v1         
-------------------
 (1,10.2222,hello)
(1 row)

-- should fail, attribute doesn't exist
LET v1.x = 10;
ERROR:  cannot assign to field "x" of column or variable "v1" because there is no such column in data type t1
LINE 1: LET v1.x = 10;
            ^
-- should fail, don't allow multi column query
LET v1 = (NULL::t1).*;
ERROR:  assignment expression returned 3 columns
LINE 1: LET v1 = (NULL::t1).*;
                  ^
-- allow DROP or ADD ATTRIBUTE on composite types
-- should be ok
ALTER TYPE t1 DROP ATTRIBUTE c;
SELECT v1;
     v1      
-------------
 (1,10.2222)
(1 row)

-- should be ok
ALTER TYPE t1 ADD ATTRIBUTE c int;
SELECT v1;
      v1      
--------------
 (1,10.2222,)
(1 row)

LET v1 = (10, 10.3, 20);
SELECT v1;
      v1      
--------------
 (10,10.3,20)
(1 row)

-- should be ok
ALTER TYPE t1 DROP ATTRIBUTE b;
SELECT v1;
   v1    
---------
 (10,20)
(1 row)

-- should fail, disallow data type change
ALTER TYPE t1 ALTER ATTRIBUTE c TYPE int;
ERROR:  cannot alter type "t1" because session variable "public.v1" uses it
DROP VARIABLE v1;
DROP TYPE t1;
-- the table type can be used as composite type too
CREATE TABLE svar_test(a int, b numeric, c date);
CREATE VARIABLE var1 AS svar_test;
LET var1 = (10, pi(), '2023-05-26');
SELECT var1;
               var1               
----------------------------------
 (10,3.14159265358979,05-26-2023)
(1 row)

-- should fail due dependency
ALTER TABLE svar_test ALTER COLUMN a TYPE text;
ERROR:  cannot alter table "svar_test" because session variable "public.var1" uses it
-- should fail
DROP TABLE svar_test;
ERROR:  cannot drop table svar_test because other objects depend on it
DETAIL:  session variable var1 depends on type svar_test
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
DROP VARIABLE var1;
DROP TABLE svar_test;
-- arrays are supported
CREATE VARIABLE var1 AS numeric[];
LET var1 = ARRAY[1.1,2.1];
LET var1[1] = 10.1;
SELECT var1;
    var1    
------------
 {10.1,2.1}
(1 row)

-- LET target doesn't allow srf, should fail
LET var1[generate_series(1,3)] = 100;
ERROR:  set-returning functions are not allowed in LET
LINE 1: LET var1[generate_series(1,3)] = 100;
                 ^
DROP VARIABLE var1;
-- arrays inside composite
CREATE TYPE t1 AS (a numeric, b numeric[]);
CREATE VARIABLE var1 AS t1;
LET var1 = (10.1, ARRAY[0.0, 0.0]);
LET var1.a = 10.2;
SELECT var1;
        var1        
--------------------
 (10.2,"{0.0,0.0}")
(1 row)

LET var1.b[1] = 10.3;
SELECT var1;
        var1         
---------------------
 (10.2,"{10.3,0.0}")
(1 row)

DROP VARIABLE var1;
DROP TYPE t1;
-- Encourage use of parallel plans
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
SET min_parallel_table_scan_size = 0;
SET max_parallel_workers_per_gather = 2;
-- test on query with workers
CREATE TABLE svar_test(a int);
INSERT INTO svar_test SELECT * FROM generate_series(1,1000);
ANALYZE svar_test;
CREATE VARIABLE zero int;
LET zero = 0;
-- result should be 100
SELECT count(*) FROM svar_test WHERE a%10 = zero;
 count 
-------
   100
(1 row)

-- parallel execution is not supported yet
EXPLAIN (COSTS OFF) SELECT count(*) FROM svar_test WHERE a%10 = zero;
                 QUERY PLAN                 
--------------------------------------------
 Aggregate
   ->  Gather
         Workers Planned: 2
         ->  Parallel Seq Scan on svar_test
               Filter: ((a % 10) = zero)
(5 rows)

LET zero = (SELECT count(*) FROM svar_test);
-- result should be 1000
SELECT zero;
 zero 
------
 1000
(1 row)

DROP VARIABLE zero;
DROP TABLE svar_test;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
RESET min_parallel_table_scan_size;
RESET max_parallel_workers_per_gather;
-- the result of view should be same in parallel mode too
CREATE VARIABLE var1 AS int;
LET var1 = 10;
CREATE VIEW var1view AS SELECT COALESCE(var1, 0) AS result;
SELECT * FROM var1view;
 result 
--------
     10
(1 row)

SET debug_parallel_query TO on;
SELECT * FROM var1view;
 result 
--------
     10
(1 row)

SET debug_parallel_query TO off;
DROP VIEW var1view;
DROP VARIABLE var1;
CREATE VARIABLE varid int;
CREATE TABLE svar_test(id int, v int);
LET varid = 1;
INSERT INTO svar_test VALUES(varid, 100);
SELECT * FROM svar_test;
 id |  v  
----+-----
  1 | 100
(1 row)

UPDATE svar_test SET v = 200 WHERE id = varid;
SELECT * FROM svar_test;
 id |  v  
----+-----
  1 | 200
(1 row)

DELETE FROM svar_test WHERE id = varid;
SELECT * FROM svar_test;
 id | v 
----+---
(0 rows)

DROP TABLE svar_test;
DROP VARIABLE varid;
-- visibility check
-- variables should be shadowed always
CREATE VARIABLE var1 AS text;
SELECT var1.relname FROM pg_class var1 WHERE var1.relname = 'pg_class';
 relname  
----------
 pg_class
(1 row)

DROP VARIABLE var1;
CREATE TABLE xxtab(avar int);
INSERT INTO xxtab VALUES(333);
CREATE TYPE xxtype AS (avar int);
CREATE VARIABLE xxtab AS xxtype;
INSERT INTO xxtab VALUES(10);
-- it is ambiguous, but columns are preferred
SELECT xxtab.avar FROM xxtab;
 avar 
------
  333
   10
(2 rows)

-- should be ok
SELECT avar FROM xxtab;
 avar 
------
  333
   10
(2 rows)

CREATE VARIABLE public.avar AS int;
-- should be ok, see the table
SELECT avar FROM xxtab;
 avar 
------
  333
   10
(2 rows)

-- should be ok
SELECT public.avar FROM xxtab;
 avar 
------
     
     
(2 rows)

DROP VARIABLE xxtab;
SELECT xxtab.avar FROM xxtab;
 avar 
------
  333
   10
(2 rows)

DROP VARIABLE public.avar;
DROP TYPE xxtype;
DROP TABLE xxtab;
-- The variable can be shadowed by table or by alias
CREATE TYPE public.svar_type AS (a int, b int, c int);
CREATE VARIABLE public.svar AS public.svar_type;
CREATE TABLE public.svar(a int, b int);
INSERT INTO public.svar VALUES(10, 20);
LET public.svar = (100, 200, 300);
-- should be ok
-- show table
SELECT * FROM public.svar;
 a  | b  
----+----
 10 | 20
(1 row)

SELECT svar.a FROM public.svar;
 a  
----
 10
(1 row)

SELECT svar.* FROM public.svar;
 a  | b  
----+----
 10 | 20
(1 row)

-- show variable
SELECT public.svar;
     svar      
---------------
 (100,200,300)
(1 row)

SELECT public.svar.c;
  c  
-----
 300
(1 row)

SELECT (public.svar).*;
  a  |  b  |  c  
-----+-----+-----
 100 | 200 | 300
(1 row)

-- the variable is shadowed, raise error
SELECT public.svar.c FROM public.svar;
ERROR:  column svar.c does not exist
LINE 1: SELECT public.svar.c FROM public.svar;
               ^
-- can be fixed by alias
SELECT public.svar.c FROM public.svar x;
  c  
-----
 300
(1 row)

SELECT svar.a FROM public.svar;
 a  
----
 10
(1 row)

SELECT svar.* FROM public.svar;
 a  | b  
----+----
 10 | 20
(1 row)

-- show variable
SELECT public.svar;
     svar      
---------------
 (100,200,300)
(1 row)

SELECT public.svar.c;
  c  
-----
 300
(1 row)

SELECT (public.svar).*;
  a  |  b  |  c  
-----+-----+-----
 100 | 200 | 300
(1 row)

-- the variable is shadowed, raise error
SELECT public.svar.c FROM public.svar;
ERROR:  column svar.c does not exist
LINE 1: SELECT public.svar.c FROM public.svar;
               ^
-- can be fixed by alias
SELECT public.svar.c FROM public.svar x;
  c  
-----
 300
(1 row)

DROP VARIABLE public.svar;
DROP TABLE public.svar;
DROP TYPE public.svar_type;
CREATE TYPE ab AS (a integer, b integer);
CREATE VARIABLE v_ab AS ab;
CREATE TABLE v_ab (a integer, b integer);
INSERT INTO v_ab VALUES(10,20);
-- we should to see table
SELECT v_ab.a FROM v_ab;
 a  
----
 10
(1 row)

CREATE SCHEMA v_ab;
CREATE VARIABLE v_ab.a AS integer;
-- we should to see table
SELECT v_ab.a FROM v_ab;
 a  
----
 10
(1 row)

DROP VARIABLE v_ab;
DROP TABLE v_ab;
DROP TYPE ab;
CREATE TYPE t_am_type AS (b int);
CREATE SCHEMA xxx_am;
SET search_path TO public;
CREATE VARIABLE xxx_am AS t_am_type;
LET xxx_am = ROW(10);
-- should be ok
SELECT xxx_am;
 xxx_am 
--------
 (10)
(1 row)

CREATE VARIABLE xxx_am.b AS int;
LET :"DBNAME".xxx_am.b = 20;
-- should be still ok
SELECT xxx_am;
 xxx_am 
--------
 (10)
(1 row)

-- should fail, the reference should be ambiguous
SELECT xxx_am.b;
ERROR:  session variable reference "xxx_am.b" is ambiguous
LINE 1: SELECT xxx_am.b;
               ^
-- enhanced references should be ok
SELECT public.xxx_am.b;
 b  
----
 10
(1 row)

SELECT :"DBNAME".xxx_am.b;
 b  
----
 20
(1 row)

CREATE TABLE xxx_am(b  int);
INSERT INTO xxx_am VALUES(10);
-- we should to see table
SELECT xxx_am.b FROM xxx_am;
 b  
----
 10
(1 row)

SELECT x.b FROM xxx_am x;
 b  
----
 10
(1 row)

DROP TABLE xxx_am;
DROP VARIABLE public.xxx_am;
DROP VARIABLE xxx_am.b;
DROP SCHEMA xxx_am;
CREATE SCHEMA :"DBNAME";
CREATE VARIABLE :"DBNAME".:"DBNAME".:"DBNAME" AS t_am_type;
CREATE VARIABLE :"DBNAME".:"DBNAME".b AS int;
SET search_path TO :"DBNAME";
-- should be ambiguous
SELECT :"DBNAME".b;
ERROR:  session variable reference "regression.b" is ambiguous
LINE 1: SELECT "regression".b;
               ^
-- should be ambiguous too
SELECT :"DBNAME".:"DBNAME".b;
ERROR:  session variable reference "regression.regression.b" is ambiguous
LINE 1: SELECT "regression"."regression".b;
               ^
CREATE TABLE :"DBNAME"(b int);
-- should be ok
SELECT :"DBNAME".b FROM :"DBNAME";
 b 
---
(0 rows)

DROP TABLE :"DBNAME";
DROP VARIABLE :"DBNAME".:"DBNAME".b;
DROP VARIABLE :"DBNAME".:"DBNAME".:"DBNAME";
DROP SCHEMA :"DBNAME";
RESET search_path;
-- memory cleaning by DISCARD command
CREATE VARIABLE var1 AS varchar;
LET var1 = 'Hello';
SELECT var1;
 var1  
-------
 Hello
(1 row)

DISCARD ALL;
SELECT var1;
 var1 
------
 
(1 row)

LET var1 = 'AHOJ';
SELECT var1;
 var1 
------
 AHOJ
(1 row)

DISCARD VARIABLES;
SELECT var1;
 var1 
------
 
(1 row)

DROP VARIABLE var1;
-- initial test of debug pg_session_variables function
-- should be zero now
DISCARD VARIABLES;
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

CREATE VARIABLE var1 AS varchar;
-- should be zero still
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

LET var1 = 'AHOJ';
SELECT name, typname, can_select, can_update FROM pg_session_variables();
 name |      typname      | can_select | can_update 
------+-------------------+------------+------------
 var1 | character varying | t          | t
(1 row)

DISCARD VARIABLES;
-- should be zero again
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

-- dropped variables should be removed from memory
-- at the end of transaction or before next usage
-- of any session variable in next transaction.
LET var1 = 'Ahoj';
SELECT name, typname, can_select, can_update FROM pg_session_variables();
 name |      typname      | can_select | can_update 
------+-------------------+------------+------------
 var1 | character varying | t          | t
(1 row)

DROP VARIABLE var1;
-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

-- the content of value should be preserved when variable is dropped
-- by aborted transaction
CREATE VARIABLE var1 AS varchar;
LET var1 = 'Ahoj';
BEGIN;
DROP VARIABLE var1;
-- should fail
SELECT var1;
ERROR:  column or variable "var1" does not exist
LINE 1: SELECT var1;
               ^
ROLLBACK;
-- should be ok
SELECT var1;
 var1 
------
 Ahoj
(1 row)

-- another test
BEGIN;
DROP VARIABLE var1;
CREATE VARIABLE var1 AS int;
LET var1 = 100;
-- should be ok, result 100
SELECT var1;
 var1 
------
  100
(1 row)

ROLLBACK;
-- should be ok, result 'Ahoj'
SELECT var1;
 var1 
------
 Ahoj
(1 row)

DROP VARIABLE var1;
-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

BEGIN;
  CREATE VARIABLE var1 AS int;
  LET var1 = 100;
  SELECT var1;
 var1 
------
  100
(1 row)

  SELECT name, typname, can_select, can_update FROM pg_session_variables();
 name | typname | can_select | can_update 
------+---------+------------+------------
 var1 | integer | t          | t
(1 row)

  DROP VARIABLE var1;
COMMIT;
-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

BEGIN;
  CREATE VARIABLE var1 AS int;
  LET var1 = 100;
  SELECT var1;
 var1 
------
  100
(1 row)

  SELECT name, typname, can_select, can_update FROM pg_session_variables();
 name | typname | can_select | can_update 
------+---------+------------+------------
 var1 | integer | t          | t
(1 row)

  DROP VARIABLE var1;
COMMIT;
-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

CREATE VARIABLE var1 AS int;
CREATE VARIABLE var2 AS int;
LET var1 = 10;
LET var2 = 0;
BEGIN;
  SAVEPOINT s1;
  DROP VARIABLE var1;
  -- force cleaning by touching another session variable
  SELECT var2;
 var2 
------
    0
(1 row)

  ROLLBACK TO s1;
  SAVEPOINT s2;
  DROP VARIABLE var1;
  SELECT var2;
 var2 
------
    0
(1 row)

  ROLLBACK TO s2;
COMMIT;
-- should be ok
SELECT var1;
 var1 
------
   10
(1 row)

BEGIN;
  SAVEPOINT s1;
  DROP VARIABLE var1;
  -- force cleaning by touching another session variable
  SELECT var2;
 var2 
------
    0
(1 row)

  ROLLBACK TO s1;
  SAVEPOINT s2;
  DROP VARIABLE var1;
  SELECT var2;
 var2 
------
    0
(1 row)

ROLLBACK;
-- should be ok
SELECT var1;
 var1 
------
   10
(1 row)

BEGIN;
  SAVEPOINT s1;
  DROP VARIABLE var1;
  -- force cleaning by touching another session variable
  SELECT var2;
 var2 
------
    0
(1 row)

  SAVEPOINT s2;
  -- force cleaning by touching another session variable
  SELECT var2;
 var2 
------
    0
(1 row)

  ROLLBACK TO s1;
  -- force cleaning by touching another session variable
  SELECT var2;
 var2 
------
    0
(1 row)

COMMIT;
-- should be ok
SELECT var1;
 var1 
------
   10
(1 row)

-- repeated aborted transaction
BEGIN; DROP VARIABLE var1; ROLLBACK;
BEGIN; DROP VARIABLE var1; ROLLBACK;
BEGIN; DROP VARIABLE var1; ROLLBACK;
-- should be ok
SELECT var1;
 var1 
------
   10
(1 row)

DROP VARIABLE var1, var2;
CREATE VARIABLE var1 bigint;
CREATE TABLE var_tab_test_table(a int);
INSERT INTO var_tab_test_table SELECT * FROM generate_series(1,10);
VACUUM ANALYZE var_tab_test_table;
EXPLAIN (COSTS OFF) LET var1 = (SELECT count(*) FROM var_tab_test_table);
                  QUERY PLAN                  
----------------------------------------------
 SET SESSION VARIABLE
 Result
   InitPlan 1
     ->  Aggregate
           ->  Seq Scan on var_tab_test_table
(5 rows)

-- should be NULL
SELECT var1;
 var1 
------
     
(1 row)

EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE, SUMMARY OFF) LET var1 = (SELECT count(*) FROM var_tab_test_table);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 SET SESSION VARIABLE
 Result (actual rows=1 loops=1)
   InitPlan 1
     ->  Aggregate (actual rows=1 loops=1)
           ->  Seq Scan on var_tab_test_table (actual rows=10 loops=1)
(5 rows)

-- should be 10
SELECT var1;
 var1 
------
   10
(1 row)

SET plan_cache_mode TO force_generic_plan;
PREPARE p1 AS LET var1 = (SELECT count(*) FROM var_tab_test_table);
LET var1 = NULL;
EXPLAIN (COSTS OFF) EXECUTE p1;
                  QUERY PLAN                  
----------------------------------------------
 SET SESSION VARIABLE
 Result
   InitPlan 1
     ->  Aggregate
           ->  Seq Scan on var_tab_test_table
(5 rows)

-- should be NULL
SELECT var1;
 var1 
------
     
(1 row)

EXPLAIN (COSTS OFF, TIMING OFF, ANALYZE, SUMMARY OFF) EXECUTE p1;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 SET SESSION VARIABLE
 Result (actual rows=1 loops=1)
   InitPlan 1
     ->  Aggregate (actual rows=1 loops=1)
           ->  Seq Scan on var_tab_test_table (actual rows=10 loops=1)
(5 rows)

-- should be 10
SELECT var1;
 var1 
------
   10
(1 row)

SET plan_cache_mode TO DEFAULT;
DEALLOCATE p1;
DROP VARIABLE var1;
DROP TABLE var_tab_test_table;
CREATE VARIABLE var1 numeric;
SET plan_cache_mode TO force_generic_plan;
PREPARE p1(numeric) AS LET var1 = $1;
PREPARE p2 AS SELECT var1;
EXECUTE p1(pi() + 100);
EXECUTE p2;
      var1       
-----------------
 103.14159265359
(1 row)

-- prepared plan cache invalidation test
DROP VARIABLE var1;
CREATE VARIABLE var1 numeric;
-- should be NULL
EXECUTE p2;
 var1 
------
     
(1 row)

DEALLOCATE p1;
DEALLOCATE p2;
DROP VARIABLE var1;
SET plan_cache_mode TO force_generic_plan;
CREATE VARIABLE var1 numeric[];
PREPARE p1(int, numeric) AS LET var1[$1] = $2;
LET var1 = '{}'::numeric[];
EXECUTE p1(1, 10.2);
EXECUTE p1(2, 10.3);
SELECT var1;
    var1     
-------------
 {10.2,10.3}
(1 row)

DEALLOCATE p1;
DROP VARIABLE var1;
-- temporary variables
CREATE TEMP VARIABLE var1 AS int;
-- this view should be temporary
CREATE VIEW var_test_view AS SELECT var1;
NOTICE:  view "var_test_view" will be a temporary view
DROP VARIABLE var1 CASCADE;
NOTICE:  drop cascades to view var_test_view
BEGIN;
  CREATE TEMP VARIABLE var1 AS int ON COMMIT DROP;
  LET var1 = 100;
  SELECT var1;
 var1 
------
  100
(1 row)

COMMIT;
-- should be zero
SELECT count(*) FROM pg_variable WHERE varname = 'var1';
 count 
-------
     0
(1 row)

-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

BEGIN;
  CREATE TEMP VARIABLE var1 AS int ON COMMIT DROP;
  LET var1 = 100;
  SELECT var1;
 var1 
------
  100
(1 row)

ROLLBACK;
-- should be zero
SELECT count(*) FROM pg_variable WHERE varname = 'var1';
 count 
-------
     0
(1 row)

-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

BEGIN;
  CREATE TEMP VARIABLE var1 AS int ON COMMIT DROP;
  LET var1 = 100;
  DROP VARIABLE var1;
COMMIT;
-- should be zero
SELECT count(*) FROM pg_variable WHERE varname = 'var1';
 count 
-------
     0
(1 row)

-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

BEGIN;
  CREATE TEMP VARIABLE var1 AS int ON COMMIT DROP;
  LET var1 = 100;
  DROP VARIABLE var1;
ROLLBACK;
-- should be zero
SELECT count(*) FROM pg_variable WHERE varname = 'var1';
 count 
-------
     0
(1 row)

-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

BEGIN;
  CREATE TEMP VARIABLE var1 AS int ON COMMIT DROP;
  LET var1 = 100;
  SAVEPOINT s1;
  DROP VARIABLE var1;
  ROLLBACK TO s1;
  SELECT var1;
 var1 
------
  100
(1 row)

COMMIT;
-- should be zero
SELECT count(*) FROM pg_variable WHERE varname = 'var1';
 count 
-------
     0
(1 row)

-- should be zero
SELECT count(*) FROM pg_session_variables();
 count 
-------
     0
(1 row)

CREATE VARIABLE var1 AS int ON TRANSACTION END RESET;
BEGIN;
  LET var1 = 100;
  SELECT var1;
 var1 
------
  100
(1 row)

COMMIT;
-- should be NULL;
SELECT var1 IS NULL;
 ?column? 
----------
 t
(1 row)

BEGIN;
  LET var1 = 100;
  SELECT var1;
 var1 
------
  100
(1 row)

ROLLBACK;
-- should be NULL
SELECT var1 IS NULL;
 ?column? 
----------
 t
(1 row)

DROP VARIABLE var1;
CREATE OR REPLACE FUNCTION vartest_fx()
RETURNS int AS $$
BEGIN
  RAISE NOTICE 'vartest_fx executed';
  RETURN 0;
END;
$$ LANGUAGE plpgsql;
CREATE VARIABLE var1 AS int DEFAULT vartest_fx();
-- vartest_fx should be protected by dep, should fail
DROP FUNCTION vartest_fx();
ERROR:  cannot drop function vartest_fx() because other objects depend on it
DETAIL:  session variable var1 depends on function vartest_fx()
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-- should be ok
SELECT var1;
NOTICE:  vartest_fx executed
 var1 
------
    0
(1 row)

-- the defexpr should be evaluated only once
SELECT var1;
 var1 
------
    0
(1 row)

DISCARD VARIABLES;
-- in this case, the defexpr should not be evaluated
LET var1 = 100;
SELECT var1;
 var1 
------
  100
(1 row)

DISCARD VARIABLES;
CREATE OR REPLACE FUNCTION vartest_fx()
RETURNS int AS $$
BEGIN
  RAISE EXCEPTION 'vartest_fx is executing';
  RETURN 0;
END;
$$ LANGUAGE plpgsql;
-- should to fail, but not to crash
SELECT var1;
ERROR:  vartest_fx is executing
CONTEXT:  PL/pgSQL function vartest_fx() line 3 at RAISE
-- again
SELECT var1;
ERROR:  vartest_fx is executing
CONTEXT:  PL/pgSQL function vartest_fx() line 3 at RAISE
-- but we can write
LET var1 = 100;
SELECT var1;
 var1 
------
  100
(1 row)

DROP VARIABLE var1;
DROP FUNCTION vartest_fx();
-- test NOT NULL
-- should be ok
CREATE VARIABLE var1 AS int NOT NULL;
-- should be ok
LET var1 = 10;
SELECT var1;
 var1 
------
   10
(1 row)

DISCARD VARIABLES;
-- should fail
SELECT var1;
ERROR:  null value is not allowed for NOT NULL session variable "public.var1"
DETAIL:  The session variable was not initialized yet.
-- should be ok
LET var1 = 10;
SELECT var1;
 var1 
------
   10
(1 row)

DROP VARIABLE var1;
-- should be ok
CREATE VARIABLE var1 AS int NOT NULL DEFAULT 0;
--should be ok
SELECT var1;
 var1 
------
    0
(1 row)

-- should be ok
LET var1 = 10;
SELECT var1;
 var1 
------
   10
(1 row)

DISCARD VARIABLES;
-- should to fail
LET var1 = NULL;
ERROR:  null value is not allowed for NOT NULL session variable "public.var1"
DROP VARIABLE var1;
-- test NOT NULL
CREATE OR REPLACE FUNCTION vartest_fx()
RETURNS int AS $$
BEGIN
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;
CREATE VARIABLE var1 AS int NOT NULL DEFAULT vartest_fx();
-- should to fail
SELECT var1;
ERROR:  null value is not allowed for NOT NULL session variable "public.var1"
DETAIL:  The result of DEFAULT expression is NULL.
DISCARD VARIABLES;
-- should be ok
LET var1 = 10;
SELECT var1;
 var1 
------
   10
(1 row)

CREATE OR REPLACE FUNCTION vartest_fx()
RETURNS int AS $$
BEGIN
  RETURN 0;
END;
$$ LANGUAGE plpgsql;
DISCARD VARIABLES;
-- should be ok
SELECT var1;
 var1 
------
    0
(1 row)

DROP VARIABLE var1;
DROP FUNCTION vartest_fx();
-- test IMMUTBLE
CREATE IMMUTABLE VARIABLE var1 AS int;
-- should be ok
SELECT var1;
 var1 
------
     
(1 row)

-- first write should ok
-- should be ok
LET var1 = 10;
-- should fail
LET var1 = 20;
ERROR:  session variable "public.var1" is declared IMMUTABLE
DISCARD VARIABLES;
-- should be ok
LET var1 = 10;
-- should fail
LET var1 = 20;
ERROR:  session variable "public.var1" is declared IMMUTABLE
DISCARD VARIABLES;
-- should be ok
SELECT var1;
 var1 
------
     
(1 row)

-- should be ok
LET var1 = NULL;
-- should fail
LET var1 = 20;
ERROR:  session variable "public.var1" is declared IMMUTABLE
DROP VARIABLE var1;
CREATE IMMUTABLE VARIABLE var1 AS int DEFAULT 10;
-- don't allow change when variable has DEFAULT value
-- should to fail
LET var1 = 20;
ERROR:  session variable "public.var1" is declared IMMUTABLE
DISCARD VARIABLES;
-- should be ok
SELECT var1;
 var1 
------
   10
(1 row)

-- should fail
LET var1 = 20;
ERROR:  session variable "public.var1" is declared IMMUTABLE
DROP VARIABLE var1;
-- should be ok
CREATE IMMUTABLE VARIABLE var1 AS INT NOT NULL DEFAULT 10;
-- should to fail
LET var1 = 10;
ERROR:  session variable "public.var1" is declared IMMUTABLE
LET var1 = 20;
ERROR:  session variable "public.var1" is declared IMMUTABLE
-- should be ok
SELECT var1;
 var1 
------
   10
(1 row)

-- should to fail
LET var1 = 30;
ERROR:  session variable "public.var1" is declared IMMUTABLE
DROP VARIABLE var1;
-- test session_variables_ambiguity_warning
CREATE SCHEMA xxtab;
CREATE VARIABLE xxtab.avar int;
CREATE TABLE public.xxtab(avar int);
INSERT INTO public.xxtab VALUES(1);
LET xxtab.avar = 20;
SET session_variables_ambiguity_warning TO on;
--- should to raise warning, show 1
SELECT xxtab.avar FROM public.xxtab;
WARNING:  session variable "xxtab.avar" is shadowed
LINE 1: SELECT xxtab.avar FROM public.xxtab;
               ^
DETAIL:  Session variables can be shadowed by columns, routine's variables and routine's arguments with the same name.
 avar 
------
    1
(1 row)

SET session_variables_ambiguity_warning TO off;
DROP TABLE public.xxtab;
DROP SCHEMA xxtab CASCADE;
NOTICE:  drop cascades to session variable xxtab.avar
-- test transactional variables
CREATE TRANSACTION VARIABLE tv AS int DEFAULT 0;
BEGIN;
  LET tv = 100;
  SELECT tv;
 tv  
-----
 100
(1 row)

ROLLBACK;
SELECT tv;
 tv 
----
  0
(1 row)

LET tv = 100;
BEGIN;
  LET tv = 1000;
COMMIT;
SELECT tv;
  tv  
------
 1000
(1 row)

BEGIN;
  LET tv = 0;
  SELECT tv;
 tv 
----
  0
(1 row)

ROLLBACK;
SELECT tv;
  tv  
------
 1000
(1 row)

-- test subtransactions
BEGIN;
  LET tv = 1;
SAVEPOINT x1;
  LET tv = 2;
SAVEPOINT x2;
  LET tv = 3;
ROLLBACK TO x2;
  SELECT tv;
 tv 
----
  2
(1 row)

  LET tv = 10;
ROLLBACK TO x1;
  SELECT tv;
 tv 
----
  1
(1 row)

ROLLBACK;
SELECT tv;
  tv  
------
 1000
(1 row)

BEGIN;
  LET tv = 1;
SAVEPOINT x1;
  LET tv = 2;
SAVEPOINT x2;
  LET tv = 3;
ROLLBACK TO x2;
  SELECT tv;
 tv 
----
  2
(1 row)

  LET tv = 10;
ROLLBACK TO x1;
  SELECT tv;
 tv 
----
  1
(1 row)

COMMIT;
SELECT tv;
 tv 
----
  1
(1 row)

DROP VARIABLE tv;
