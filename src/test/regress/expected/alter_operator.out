CREATE FUNCTION alter_op_test_fn(boolean, boolean)
RETURNS boolean AS $$ SELECT NULL::BOOLEAN; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION customcontsel(internal, oid, internal, integer)
RETURNS float8 AS 'contsel' LANGUAGE internal STABLE STRICT;
CREATE OPERATOR === (
    LEFTARG = boolean,
    RIGHTARG = boolean,
    PROCEDURE = alter_op_test_fn,
    COMMUTATOR = ===,
    NEGATOR = !==,
    RESTRICT = customcontsel,
    JOIN = contjoinsel,
    HASHES, MERGES
);
SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptype
FROM pg_depend
WHERE classid = 'pg_operator'::regclass AND
      objid = '===(bool,bool)'::regoperator
ORDER BY 1;
                          ref                          | deptype 
-------------------------------------------------------+---------
 function alter_op_test_fn(boolean,boolean)            | n
 function customcontsel(internal,oid,internal,integer) | n
 schema public                                         | n
(3 rows)

--
-- test reset and set restrict and join
--
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = NONE);
SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
 oprrest | oprjoin 
---------+---------
 -       | -
(1 row)

SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptype
FROM pg_depend
WHERE classid = 'pg_operator'::regclass AND
      objid = '===(bool,bool)'::regoperator
ORDER BY 1;
                    ref                     | deptype 
--------------------------------------------+---------
 function alter_op_test_fn(boolean,boolean) | n
 schema public                              | n
(2 rows)

ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = contsel);
ALTER OPERATOR === (boolean, boolean) SET (JOIN = contjoinsel);
SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
 oprrest |   oprjoin   
---------+-------------
 contsel | contjoinsel
(1 row)

SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptype
FROM pg_depend
WHERE classid = 'pg_operator'::regclass AND
      objid = '===(bool,bool)'::regoperator
ORDER BY 1;
                    ref                     | deptype 
--------------------------------------------+---------
 function alter_op_test_fn(boolean,boolean) | n
 schema public                              | n
(2 rows)

ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE, JOIN = NONE);
SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
 oprrest | oprjoin 
---------+---------
 -       | -
(1 row)

SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptype
FROM pg_depend
WHERE classid = 'pg_operator'::regclass AND
      objid = '===(bool,bool)'::regoperator
ORDER BY 1;
                    ref                     | deptype 
--------------------------------------------+---------
 function alter_op_test_fn(boolean,boolean) | n
 schema public                              | n
(2 rows)

ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = customcontsel, JOIN = contjoinsel);
SELECT oprrest, oprjoin FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
    oprrest    |   oprjoin   
---------------+-------------
 customcontsel | contjoinsel
(1 row)

SELECT pg_describe_object(refclassid,refobjid,refobjsubid) as ref, deptype
FROM pg_depend
WHERE classid = 'pg_operator'::regclass AND
      objid = '===(bool,bool)'::regoperator
ORDER BY 1;
                          ref                          | deptype 
-------------------------------------------------------+---------
 function alter_op_test_fn(boolean,boolean)            | n
 function customcontsel(internal,oid,internal,integer) | n
 schema public                                         | n
(3 rows)

-- test cannot set non existant function
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = non_existent_func);
ERROR:  function non_existent_func(internal, oid, internal, integer) does not exist
ALTER OPERATOR === (boolean, boolean) SET (JOIN = non_existent_func);
ERROR:  function non_existent_func(internal, oid, internal, smallint, internal) does not exist
-- test non-lowercase quoted identifiers invalid
ALTER OPERATOR & (bit, bit) SET ("Restrict" = _int_contsel, "Join" = _int_contjoinsel);
ERROR:  operator attribute "Restrict" not recognized
--
-- test must be owner of operator to ALTER OPERATOR.
--
CREATE USER regress_alter_op_user;
SET SESSION AUTHORIZATION regress_alter_op_user;
ALTER OPERATOR === (boolean, boolean) SET (RESTRICT = NONE);
ERROR:  must be owner of operator ===
RESET SESSION AUTHORIZATION;
--
-- test set commutator, negator, hashes, and merges which can only be set if not
-- already set
--
-- for these tests create operators with different left and right types so that
-- we can validate that function signatures are handled correctly
CREATE FUNCTION alter_op_test_fn_bool_real(boolean, real)
RETURNS boolean AS $$ SELECT NULL::BOOLEAN; $$ LANGUAGE sql IMMUTABLE;
CREATE FUNCTION alter_op_test_fn_real_bool(real, boolean)
RETURNS boolean AS $$ SELECT NULL::BOOLEAN; $$ LANGUAGE sql IMMUTABLE;
-- operator
CREATE OPERATOR === (
    LEFTARG = boolean,
    RIGHTARG = real,
    PROCEDURE = alter_op_test_fn_bool_real
);
-- commutator
CREATE OPERATOR ==== (
    LEFTARG = real,
    RIGHTARG = boolean,
    PROCEDURE = alter_op_test_fn_real_bool
);
-- negator
CREATE OPERATOR !==== (
    LEFTARG = boolean,
    RIGHTARG = real,
    PROCEDURE = alter_op_test_fn_bool_real
);
-- test no-op setting already false hashes and merges to false works
ALTER OPERATOR === (boolean, real) SET (HASHES = false);
ALTER OPERATOR === (boolean, real) SET (MERGES = false);
-- validate still false after no-op
SELECT oprcanhash, oprcanmerge FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcanhash | oprcanmerge 
------------+-------------
 f          | f
(1 row)

-- test cannot set commutator or negator without owning them
SET SESSION AUTHORIZATION regress_alter_op_user;
-- we need need a new operator owned by regress_alter_op_user so that we are
-- allowed to alter it. ==== and !==== are owned by the test user so we expect
-- the alters below to fail.
CREATE OPERATOR ===@@@ (
    LEFTARG = boolean,
    RIGHTARG = real,
    PROCEDURE = alter_op_test_fn_bool_real
);
ALTER OPERATOR ===@@@ (boolean, real) SET (COMMUTATOR= ====);
ERROR:  must be owner of operator ====
ALTER OPERATOR ===@@@ (boolean, real) SET (NEGATOR = !====);
ERROR:  must be owner of operator !====
-- validate operator is unchanged and commutator and negator are unset
SELECT oprcom, oprnegate FROM pg_operator WHERE oprname = '===@@@'
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcom | oprnegate 
--------+-----------
      0 |         0
(1 row)

DROP OPERATOR ===@@@ (boolean, real);
RESET SESSION AUTHORIZATION;
-- test cannot set self negator
ALTER OPERATOR === (boolean, real) SET (NEGATOR = ===);
ERROR:  operator cannot be its own negator
-- validate no changes made
SELECT oprcanmerge, oprcanhash, oprcom, oprnegate
FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcanmerge | oprcanhash | oprcom | oprnegate 
-------------+------------+--------+-----------
 f           | f          |      0 |         0
(1 row)

-- test set hashes
ALTER OPERATOR === (boolean, real) SET (HASHES);
SELECT oprcanhash FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcanhash 
------------
 t
(1 row)

-- test set merges
ALTER OPERATOR === (boolean, real) SET (MERGES);
SELECT oprcanmerge FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcanmerge 
-------------
 t
(1 row)

-- test set commutator
ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = ====);
-- validate that the commutator has been set on both the operator and commutator,
-- that they reference each other, and that the operator used is the existing
-- one we created and not a new shell operator
SELECT op.oprname AS operator_name, com.oprname AS commutator_name,
  com.oprcode AS commutator_func
  FROM pg_operator op
  INNER JOIN pg_operator com ON (op.oid = com.oprcom AND op.oprcom = com.oid)
  WHERE op.oprname = '==='
  AND op.oprleft = 'boolean'::regtype AND op.oprright = 'real'::regtype;
 operator_name | commutator_name |      commutator_func       
---------------+-----------------+----------------------------
 ===           | ====            | alter_op_test_fn_real_bool
(1 row)

-- test set negator
ALTER OPERATOR === (boolean, real) SET (NEGATOR = !====);
-- validate that the negator has been set on both the operator and negator, that
-- they reference each other, and that the operator used is the existing one we
-- created and not a new shell operator
SELECT op.oprname AS operator_name, neg.oprname AS negator_name,
  neg.oprcode AS negator_func
  FROM pg_operator op
  INNER JOIN pg_operator neg ON (op.oid = neg.oprnegate AND op.oprnegate = neg.oid)
  WHERE op.oprname = '==='
  AND op.oprleft = 'boolean'::regtype AND op.oprright = 'real'::regtype;
 operator_name | negator_name |        negator_func        
---------------+--------------+----------------------------
 ===           | !====        | alter_op_test_fn_bool_real
(1 row)

-- validate that the final state of the operator is as we expect
SELECT oprcanmerge, oprcanhash,
       pg_describe_object('pg_operator'::regclass, oprcom, 0) AS commutator,
       pg_describe_object('pg_operator'::regclass, oprnegate, 0) AS negator
  FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcanmerge | oprcanhash |         commutator          |           negator            
-------------+------------+-----------------------------+------------------------------
 t           | t          | operator ====(real,boolean) | operator !====(boolean,real)
(1 row)

-- test no-op set 'succeeds'
ALTER OPERATOR === (boolean, real) SET (NEGATOR = !====);
ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = ====);
ALTER OPERATOR === (boolean, real) SET (HASHES);
ALTER OPERATOR === (boolean, real) SET (MERGES);
-- test cannot change commutator, negator, hashes, and merges when already set
CREATE OPERATOR @= (
    LEFTARG = real,
    RIGHTARG = boolean,
    PROCEDURE = alter_op_test_fn_real_bool
);
CREATE OPERATOR @!= (
    LEFTARG = boolean,
    RIGHTARG = real,
    PROCEDURE = alter_op_test_fn_bool_real
);
ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = @=);
ERROR:  operator attribute "commutator" cannot be changed if it has already been set
ALTER OPERATOR === (boolean, real) SET (NEGATOR = @!=);
ERROR:  operator attribute "negator" cannot be changed if it has already been set
ALTER OPERATOR === (boolean, real) SET (HASHES = false);
ERROR:  operator attribute "hashes" cannot be disabled after it has been enabled
ALTER OPERATOR === (boolean, real) SET (MERGES = false);
ERROR:  operator attribute "merges" cannot be disabled after it has been enabled
-- test cannot set an operator that aleady has a commutator as the commutator
ALTER OPERATOR @=(real, boolean) SET (COMMUTATOR = ===);
ERROR:  commutator commutates another operator
SELECT oprcom FROM pg_operator WHERE oprname = '@=';
 oprcom 
--------
      0
(1 row)

-- test cannot set an operator that already has a negator as the negator
ALTER OPERATOR @!=(boolean, real) SET (NEGATOR = ===);
ERROR:  negator negates another operator
SELECT oprnegate FROM pg_operator WHERE oprname = '@!=';
 oprnegate 
-----------
         0
(1 row)

-- validate no changes made
SELECT oprcanmerge, oprcanhash,
       pg_describe_object('pg_operator'::regclass, oprcom, 0) AS commutator,
       pg_describe_object('pg_operator'::regclass, oprnegate, 0) AS negator
  FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcanmerge | oprcanhash |         commutator          |           negator            
-------------+------------+-----------------------------+------------------------------
 t           | t          | operator ====(real,boolean) | operator !====(boolean,real)
(1 row)

DROP OPERATOR @=(real, boolean);
DROP OPERATOR @!=(boolean, real);
--
-- test setting commutator and negator to undefined or shell operator fails
--
DROP OPERATOR === (boolean, real);
CREATE OPERATOR === (
    LEFTARG = boolean,
    RIGHTARG = real,
    PROCEDURE = alter_op_test_fn_bool_real
);
-- test cannot set undefined
ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = ===@@@);
ERROR:  operator ===@@@ does not exist
ALTER OPERATOR === (boolean, real) SET (NEGATOR = !===@@@);
ERROR:  operator !===@@@ does not exist
-- create shell operators for ===@@@ and !===@@@ 
CREATE OPERATOR ===@@ (
    LEFTARG = boolean,
    RIGHTARG = real,
    PROCEDURE = alter_op_test_fn_bool_real,
    COMMUTATOR = ===@@@,
    NEGATOR = !===@@@
);
-- test cannot set shell operators
ALTER OPERATOR === (boolean, real) SET (COMMUTATOR = ===@@@);
ERROR:  operator ===@@@ is undefined shell operator
ALTER OPERATOR === (boolean, real) SET (NEGATOR = !===@@@);
ERROR:  operator !===@@@ is undefined shell operator
-- validate no changes made
SELECT oprcanmerge, oprcanhash,
       pg_describe_object('pg_operator'::regclass, oprcom, 0) AS commutator,
       pg_describe_object('pg_operator'::regclass, oprnegate, 0) AS negator
  FROM pg_operator WHERE oprname = '==='
  AND oprleft = 'boolean'::regtype AND oprright = 'real'::regtype;
 oprcanmerge | oprcanhash | commutator | negator 
-------------+------------+------------+---------
 f           | f          |            | 
(1 row)

DROP OPERATOR ===@@(boolean, real);
DROP OPERATOR ===@@@(real, boolean);
DROP OPERATOR !===@@@(boolean, real);
--
-- test setting self commutator
--
DROP OPERATOR === (boolean, boolean);
CREATE OPERATOR === (
    LEFTARG = boolean,
    RIGHTARG = boolean,
    PROCEDURE = alter_op_test_fn
);
ALTER OPERATOR === (boolean, boolean) SET (COMMUTATOR = ===);
-- validate that the oprcom is the operator oid
SELECT oprname FROM pg_operator 
  WHERE oprname = '===' AND oid = oprcom
  AND oprleft = 'boolean'::regtype AND oprright = 'boolean'::regtype;
 oprname 
---------
 ===
(1 row)

--
-- Clean up
--
DROP USER regress_alter_op_user;
DROP OPERATOR === (boolean, boolean);
DROP OPERATOR === (boolean, real);
DROP OPERATOR ==== (real, boolean);
DROP OPERATOR !==== (boolean, real);
DROP FUNCTION customcontsel(internal, oid, internal, integer);
DROP FUNCTION alter_op_test_fn(boolean, boolean);
DROP FUNCTION alter_op_test_fn_bool_real(boolean, real);
DROP FUNCTION alter_op_test_fn_real_bool(real, boolean);
