#!/usr/bin/perl
#
# Generate sorted list of non-overlapping intervals of characters and
# and their display widths, using Unicode data files as input.
# The output is on stdout.
#
# Copyright (c) 2019-2021, PostgreSQL Global Development Group

use strict;
use warnings;

my $UD;
my $EAW;
my @ranges;

print
  "/* generated by src/common/unicode/generate-unicode_width_table.pl, do not edit */\n\n";

# First get the combining characters (width = 0)
my $range_start = undef;
my $codepoint;
my $prev_codepoint;

open($UD, '<', "UnicodeData.txt")
  or die "Could not open UnicodeData.txt: $!.";

foreach my $line (<$UD>)
{
	chomp $line;
	my @fields = split ';', $line;
	$codepoint = hex $fields[0];

	if ($fields[2] eq 'Me' || $fields[2] eq 'Mn')
	{
		# combining character, save for start of range
		if (!defined($range_start))
		{
			$range_start = $codepoint;
		}
	}
	else
	{
		# not a combining character, print out previous range if any
		if (defined($range_start))
		{
			push @ranges, {first => $range_start, last => $prev_codepoint, width => 0};
			$range_start = undef;
		}
	}
}
continue
{
	$prev_codepoint = $codepoint;
}

# Now get the East Asian Wide (W) and East Asian Fullwidth (F) characters (width = 2)
$range_start = undef;
my ($first, $last);
my $prev_last;

open($EAW, '<', "EastAsianWidth.txt")
  or die "Could not open EastAsianWidth.txt: $!.";

foreach my $line (<$EAW>)
{
	chomp $line;
	$line =~ s/\s*#.*$//;
	next if $line eq '';
	my ($codepoint, $width) = split ';', $line;

	if ($codepoint =~ /\.\./)
	{
		($first, $last) = split /\.\./, $codepoint;
	}
	else
	{
		$first = $last = $codepoint;
	}

	($first, $last) = map(hex, ($first, $last));

	if ($width eq 'F' || $width eq 'W')
	{
		# fullwidth/wide characters
		if (!defined($range_start))
		{
			# save for start of range if one hasn't been started yet
			$range_start = $first;
		}
		elsif ($first != $prev_last + 1)
		{
			# ranges aren't contiguous; emit the last and start a new one
			push @ranges, {first => $range_start, last => $prev_last, width => 2};
			$range_start = $first;
		}
	}
	else
	{
		# not wide characters, print out previous range if any
		if (defined($range_start))
		{
			push @ranges, {first => $range_start, last => $prev_last, width => 2};
			$range_start = undef;
		}
	}
}
continue
{
	$prev_last = $last;
}

# don't forget any ranges at the very end of the database (though there are none
# as of Unicode 13.0)
if (defined($range_start))
{
	push @ranges, {first => $range_start, last => $prev_last, width => 2};
}

close $UD;
close $EAW;

# emit the sorted ranges with their widths
print "static const struct mbinterval wcwidth[] = {\n";

foreach my $range (sort {$a->{first} <=> $b->{first}} @ranges)
{
	printf "\t{0x%04X, 0x%04X, %d},\n", $range->{first}, $range->{last}, $range->{width};
}

print "};\n";
