<!-- doc/src/sgml/limits.sgml -->

<appendix id="limits">
 <title><productname>PostgreSQL</productname> Limits</title>

 <para>
  <xref linkend="limits-table"/> describes various hard limits of
  <productname>PostgreSQL</productname>.  However, practical limits, such as
  performance limitations or available disk space may apply before absolute
  hard limits are reached.
 </para>

 <table id="limits-table">
  <title><productname>PostgreSQL</productname> Limitations</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Item</entry>
     <entry>Upper Limit</entry>
     <entry>Comment</entry>
    </row>
   </thead>

   <tbody>
    <row>
     <entry>database size</entry>
     <entry>unlimited</entry>
     <entry></entry>
    </row>

    <row>
     <entry>number of databases</entry>
     <!-- 2^32 - FirstNormalObjectId - 1 -->
     <entry>4,294,950,911</entry>
     <entry></entry>
    </row>

    <row>
     <entry>relations per database</entry>
     <!-- (2^32 - FirstNormalObjectId - 1) / 3 (3 because of the table and the
          two types that are created to go with it) -->
     <entry>1,431,650,303</entry>
     <entry></entry>
    </row>

    <row>
     <entry>relation size</entry>
     <entry>32 TB</entry>
     <entry>with the default <symbol>BLCKSZ</symbol> of 8192 bytes</entry>
    </row>

    <row>
     <entry>rows per table</entry>
     <entry>limited by the number of rows that can fit onto 4,294,967,295 pages</entry>
     <entry></entry>
    </row>

    <row>
     <entry>columns per table</entry>
     <entry>1600</entry>
     <entry>further limited by row size fitting on a single page; see note
     below</entry>
    </row>

    <row>
     <entry>columns in a result set</entry>
     <entry>1664</entry>
     <entry></entry>
    </row>

    <row>
     <entry>field size</entry>
     <entry>1 GB</entry>
     <entry></entry>
    </row>

    <row>
     <entry>identifier length</entry>
     <entry>63 bytes</entry>
     <entry>can be increased by recompiling <productname>PostgreSQL</productname></entry>
    </row>

    <row>
     <entry>indexes per table</entry>
     <entry>unlimited</entry>
     <entry>constrained by maximum relations per database</entry>
    </row>

    <row>
     <entry>columns per index</entry>
     <entry>32</entry>
     <entry>can be increased by recompiling <productname>PostgreSQL</productname></entry>
    </row>

   <row>
    <entry>partition keys</entry>
    <entry>32</entry>
    <entry>can be increased by recompiling <productname>PostgreSQL</productname></entry>
   </row>
   </tbody>
  </tgroup>
 </table>

 <para>
  Tables and indexes, both, are referred to as relations in Postgres code.
 </para>

 <para>
  The maximum number of columns for a table is further reduced as the row
  being stored must fit in a single database block (usually 8192-bytes).  For example,
  excluding the row-header, a row made up of 1600 <type>int</type> columns
  would consume 6400 bytes and could be stored in a database block, but a row of
  1600 <type>bigint</type> columns would consume 12800 bytes and would
  therefore not fit inside a database block.
  Variable-length columns of
  types such as <type>text</type>, <type>varchar</type>, and <type>char</type>
  can have their values stored out of line in the table's <link linkend="storage-toast"><acronym>TOAST</acronym></link> table when the
  values are large enough to require it.  Only an 18-byte pointer must remain
  inside the row in the table's storage.  For shorter length variable-length
  columns, either a 4-byte or 1-byte column header is used and the value is
  stored inside the row.
 </para>

 <para>
  Columns that have been dropped from the table also contribute to the maximum
  column limit.  Moreover, although the dropped column values for newly
  created rows are internally marked as null in the rows's null bitmap, the
  null bitmap also occupies space.
 </para>
</appendix>
