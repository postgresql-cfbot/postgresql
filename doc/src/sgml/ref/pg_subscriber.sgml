<!--
doc/src/sgml/ref/pg_subscriber.sgml
PostgreSQL documentation
-->

<refentry id="app-pgsubscriber">
 <indexterm zone="app-pgsubscriber">
  <primary>pg_subscriber</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pg_subscriber</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pg_subscriber</refname>
  <refpurpose>create a new logical replica from a standby server</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_subscriber</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <para>
   <application>pg_subscriber</application> takes the publisher and subscriber
   connection strings, a cluster directory from a standby server and a list of
   database names and it sets up a new logical replica using the physical
   recovery process.
  </para>

  <para>
   The <application>pg_subscriber</application> should be run at the target
   server. The source server (known as publisher server) should accept logical
   replication connections from the target server (known as subscriber server).
   The target server should accept local logical replication connection.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

   <para>
    <application>pg_subscriber</application> accepts the following
    command-line arguments:

    <variablelist>
     <varlistentry>
      <term><option>-D <replaceable class="parameter">directory</replaceable></option></term>
      <term><option>--pgdata=<replaceable class="parameter">directory</replaceable></option></term>
      <listitem>
       <para>
        The target directory that contains a cluster directory from a standby
        server.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>-P  <replaceable class="parameter">conninfo</replaceable></option></term>
      <term><option>--publisher-conninfo=<replaceable class="parameter">conninfo</replaceable></option></term>
      <listitem>
       <para>
        The connection string to the publisher. For details see <xref linkend="libpq-connstring"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>-S <replaceable class="parameter">conninfo</replaceable></option></term>
      <term><option>--subscriber-conninfo=<replaceable class="parameter">conninfo</replaceable></option></term>
      <listitem>
       <para>
        The connection string to the subscriber. For details see <xref linkend="libpq-connstring"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>-d <replaceable class="parameter">dbname</replaceable></option></term>
      <term><option>--database=<replaceable class="parameter">dbname</replaceable></option></term>
      <listitem>
       <para>
        The database name to create the subscription. Multiple databases can be
        selected by writing multiple <option>-d</option> switches.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--verbose</option></term>
      <listitem>
       <para>
        Enables verbose mode. This will cause
        <application>pg_subscriber</application> to output progress messages
        and detailed information about each step.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Other options are also available:

    <variablelist>
     <varlistentry>
       <term><option>-V</option></term>
       <term><option>--version</option></term>
       <listitem>
       <para>
       Print the <application>pg_subscriber</application> version and exit.
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term><option>-?</option></term>
       <term><option>--help</option></term>
       <listitem>
       <para>
       Show help about <application>pg_subscriber</application> command
       line arguments, and exit.
       </para>
       </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect1>

 <refsect1>
  <title>Notes</title>

  <para>
   The transformation proceeds in the following steps:
  </para>

  <procedure>
   <step>
    <para>
     <application>pg_subscriber</application> checks if the given target data
     directory has the same system identifier than the source data directory.
     Since it uses the recovery process as one of the steps, it starts the
     target server as a replica from the source server. If the system
     identifier is not the same, <application>pg_subscriber</application> will
     terminate with an error.
    </para>
   </step>

   <step>
    <para>
     <application>pg_subscriber</application> checks if the target data
     directory is used by a standby server. Stop the standby server if it is
     running. One of the next steps is to add some recovery parameters that
     requires a server start. This step avoids an error.
    </para>
   </step>

   <step>
    <para>
     <application>pg_subscriber</application> creates one replication slot for
     each specified database on the source server. The replication slot name
     contains a <literal>pg_subscriber</literal> prefix. These replication
     slots will be used by the subscriptions in a future step.  Another
     replication slot is used to get a consistent start location. This
     consistent LSN will be used as a stopping point in the <xref
     linkend="guc-recovery-target-lsn"/> parameter and by the
     subscriptions as a replication starting point. It guarantees that no
     transaction will be lost.
    </para>
   </step>

   <step>
    <para>
     <application>pg_subscriber</application> writes recovery parameters into
     the target data directory and start the target server. It specifies a LSN
     (consistent LSN that was obtained in the previous step) of write-ahead
     log location up to which recovery will proceed. It also specifies
     <literal>promote</literal> as the action that the server should take once
     the recovery target is reached. This step finishes once the server ends
     standby mode and is accepting read-write operations.
    </para>
   </step>

   <step>
    <para>
     Next, <application>pg_subscriber</application> creates one publication
     for each specified database on the source server. Each publication
     replicates changes for all tables in the database. The publication name
     contains a <literal>pg_subscriber</literal> prefix. These publication
     will be used by a corresponding subscription in a next step.
    </para>
   </step>

   <step>
    <para>
     <application>pg_subscriber</application> creates one subscription for
     each specified database on the target server. Each subscription name
     contains a <literal>pg_subscriber</literal> prefix. The replication slot
     name is identical to the subscription name. It does not copy existing data
     from the source server. It does not create a replication slot. Instead, it
     uses the replication slot that was created in a previous step. The
     subscription is created but it is not enabled yet. The reason is the
     replication progress must be set to the consistent LSN but replication
     origin name contains the subscription oid in its name. Hence, the
     subscription will be enabled in a separate step.
    </para>
   </step>

   <step>
    <para>
     <application>pg_subscriber</application> sets the replication progress to
     the consistent LSN that was obtained in a previous step. When the target
     server started the recovery process, it caught up to the consistent LSN.
     This is the exact LSN to be used as a initial location for each
     subscription.
    </para>
   </step>

   <step>
    <para>
     Finally, <application>pg_subscriber</application> enables the subscription
     for each specified database on the target server. The subscription starts
     streaming from the consistent LSN.
    </para>
   </step>

   <step>
    <para>
     <application>pg_subscriber</application> removes the additional replication
     slot that was used to get the consistent LSN on the source server.
    </para>
   </step>

   <step>
    <para>
     <application>pg_subscriber</application> stops the target server to change
     its system identifier.
    </para>
   </step>
  </procedure>
 </refsect1>

 <refsect1>
  <title>Examples</title>

  <para>
   To create a logical replica for databases <literal>hr</literal> and
   <literal>finance</literal> from a standby server at <literal>foo</literal>:
<screen>
<prompt>$</prompt> <userinput>pg_subscriber -D /usr/local/pgsql/data -P "host=foo" -S "host=localhost" -d hr -d finance</userinput>
</screen>
  </para>

 </refsect1>

 <refsect1>
  <title>See Also</title>

  <simplelist type="inline">
   <member><xref linkend="app-pgbasebackup"/></member>
  </simplelist>
 </refsect1>

</refentry>
