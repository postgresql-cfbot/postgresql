--
-- Test the pg_wait_for_lockers() function
--
-- directory paths and dlsuffix are passed to us in environment variables
\getenv libdir PG_LIBDIR
\getenv dlsuffix PG_DLSUFFIX
\set regresslib :libdir '/regress' :dlsuffix
-- Setup
CREATE TABLE wfl_tbl1 (a BIGINT);
-- Try all valid options
BEGIN TRANSACTION;
select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessShareLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'RowShareLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'RowExclusiveLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ShareUpdateExclusiveLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ShareLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ShareRowExclusiveLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ExclusiveLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessExclusiveLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessShareLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'RowShareLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'RowExclusiveLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ShareUpdateExclusiveLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ShareLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ShareRowExclusiveLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'ExclusiveLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessExclusiveLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

ROLLBACK;
-- pg_wait_for_lockers() does nothing if the transaction itself is the only locker
BEGIN TRANSACTION;
LOCK TABLE wfl_tbl1 IN ACCESS EXCLUSIVE MODE;
select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessExclusiveLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

ROLLBACK;
-- pg_wait_for_lockers() is allowed outside a transaction
select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessExclusiveLock', FALSE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessExclusiveLock', TRUE);
 pg_wait_for_lockers 
---------------------
 
(1 row)

-- fail gracefully with bogus arguments
BEGIN;
-- invalid oid
select pg_wait_for_lockers('{0}'::oid[]::regclass[], 'AccessShareLock', FALSE);
ERROR:  relation oid 0 is invalid
ROLLBACK;
BEGIN;
-- nonexistent oid
select pg_wait_for_lockers('{987654321}'::oid[]::regclass[], 'AccessShareLock', FALSE);
ERROR:  relation oid 987654321 does not exist
ROLLBACK;
BEGIN;
-- views are not supported
select pg_wait_for_lockers('{pg_locks}'::regclass[], 'AccessShareLock', FALSE);
ERROR:  cannot wait for lockers of pg_locks
DETAIL:  This operation is not supported for views.
ROLLBACK;
BEGIN;
-- bogus lock mode
select pg_wait_for_lockers('{wfl_tbl1}'::regclass[], 'AccessRowShareUpdateExclusiveLock', TRUE);
ERROR:  invalid lock mode name AccessRowShareUpdateExclusiveLock
ROLLBACK;
--
-- Clean up
--
DROP TABLE wfl_tbl1;
