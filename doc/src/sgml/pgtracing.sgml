<!-- doc/src/sgml/pgtracing.sgml -->

<sect1 id="pgtracing" xreflabel="pg_tracing">
 <title>pg_tracing &mdash; generate server-side spans for distributed tracing</title>

 <indexterm zone="pgtracing">
  <primary>pg_tracing</primary>
 </indexterm>

 <para>
  The <filename>pg_tracing</filename> module provides a way to
  generate server-side spans for distributed tracing.
 </para>

 <para>
  The module must be loaded by adding <literal>pg_tracing</literal> to
  <xref linkend="guc-shared-preload-libraries"/> in
  <filename>postgresql.conf</filename> because it requires additional shared memory.
  This means that a server restart is needed to add or remove the module.
 </para>

 <para>
   When <filename>pg_tracing</filename> is active, it generates spans
   on sampled queries. To access these spans, the module provides two views:
   <structname>pg_tracing_consume_spans</structname> and
   <structname>pg_tracing_peek_spans</structname>.
   The utility functions <function>pg_tracing_reset</function> and
   <function>pg_tracing_info</function> provide ways to read and reset
   module's statistics. These are not available globally but
   can be enabled for a specific database with
   <command>CREATE EXTENSION pg_tracing</command>.
 </para>

 <sect2 id="pgtracing-pg-tracing-consume-spans">
  <title>The <structname>pg_tracing_consume_spans</structname>/<structname>pg_tracing_peek_spans</structname> Views</title>

  <para>
   The spans generated by the module are made available via a
   view named <structname>pg_tracing_consume_spans</structname>.
   This view contains one row for each generated span.
   The columns of the view are shown in <xref linkend="pgtracing-consume-spans-columns"/>.
   The <structname>pg_tracing_peek_spans</structname> view
   provides the same output as <structname>pg_tracing_consume_spans</structname>.
   <structname>pg_tracing_peek_spans</structname> doesn't delete read spans.
  </para>

  <table id="pgtracing-consume-spans-columns">
   <title><structname>pg_tracing_consume_spans</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>traceid</structfield> <type>bigint</type>
      </para>
      <para>
       Trace identifier of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parent_id</structfield> <type>bigint</type>
      </para>
      <para>
       Identifier of the span's parent
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_id</structfield> <type>bigint</type>
      </para>
      <para>
       Identifier of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>queryid</structfield> <type>bigint</type>
      </para>
      <para>
       Hash code to identify identical normalized queries, 0 if query_id is disabled
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_type</structfield> <type>text</type>
      </para>
      <para>
       Type of span (Parse, Planner, Executor...)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_operation</structfield> <type>text</type>
      </para>
      <para>
       Name of the span's operation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Start time of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_start_ns</structfield> <type>smallint</type>
      </para>
      <para>
       Nanoseconds part of start time
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>duration</structfield> <type>bigint</type>
      </para>
      <para>
       Duration of the span in nanoseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sql_error_code</structfield> <type>bpchar</type>
      </para>
      <para>
       Error code of the query. 00000 for a succesful query
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Pid of the backend process that processed the query
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subxact_count</structfield> <type>smallint</type>
      </para>
      <para>
       Active count of backend's subtransaction when the span was created
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_startup_cost</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated cost before fetching any tuples by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_total_cost</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated total cost by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_rows</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated number of row plan is expected to emit
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_width</structfield> <type>integer</type>
      </para>
      <para>
       Estimated row width in bytes by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>rows</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples processed
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>nloops</structfield> <type>bigint</type>
      </para>
      <para>
       Number of cycles for this node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared block cache hits by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_dirtied</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks dirtied by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local block cache hits by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_dirtied</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks dirtied by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_read_time</structfield> <type>bigint</type>
      </para>
      <para>
       Time spent reading blocks in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_write_time</structfield> <type>bigint</type>
      </para>
      <para>
       Time spent writing blocks in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of temp blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of temp blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blk_read_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time the node spent reading temporary file blocks, in
       milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blk_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time the node spent writing temporary file blocks, in
       milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL records generated by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL full page images generated by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       Total amount of WAL generated by the node in bytes
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_functions</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of functions JIT-compiled by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_generation_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on generating JIT code, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_inlining_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on inlining functions, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_optimization_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on optimizing, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>startup</structfield> <type>bigint</type>
      </para>
      <para>
       Time to the first tuple in nanoseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parameters</structfield> <type>text</type>
      </para>
      <para>
       Value of the query's parameters
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>deparse_info</structfield> <type>text</type>
      </para>
      <para>
       Informations extracted from deparsing a plan node
      </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   For security reasons, only superusers and roles with privileges of the
   <literal>pg_read_all_stats</literal> role are allowed to access the
   <structname>pg_tracing_peek_spans</structname> and
   <structname>pg_tracing_consume_spans</structname>.
  </para>

 </sect2>

 <sect2 id="pgtracing-pg-tracing-info">
  <title>The <structname>pg_tracing_info</structname> View</title>

  <indexterm>
   <primary>pg_tracing_info</primary>
  </indexterm>

  <para>
   The statistics of the <filename>pg_tracing</filename> module
   itself are tracked and made available via a view named
   <structname>pg_tracing_info</structname>.  This view contains
   only a single row.  The columns of the view are shown in
   <xref linkend="pgtracinginfo-columns"/>.
  </para>

  <table id="pgtracinginfo-columns">
   <title><structname>pg_tracing_info</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>traces</structfield> <type>bigint</type>
      </para>
      <para>
       Total number traces captured by the module
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>spans</structfield> <type>bigint</type>
      </para>
      <para>
       Total number spans captured by the module
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dropped_spans</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of spans dropped because more than
       <varname>pg_tracing.max_span</varname> were stored
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>failed_truncates</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of times the module couldn't truncate the
       query file due to a conflicting lock
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_consume</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which spans were consumed
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which all statistics in the
       <structname>pg_tracing_info</structname> view were last reset.
      </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="pgtracing-funcs">
  <title>Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>pg_tracing_reset() returns void</function>
     <indexterm>
      <primary>pg_tracing_reset</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>pg_tracing_reset</function> discards all statistics
      gathered so far by <filename>pg_tracing</filename>.
      Span buffer is not emptied by this function.
      By default, this function can only be executed by superusers.
      Access may be granted to others using <command>GRANT</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>pg_tracing_spans(consume boolean) returns setof record</function>
     <indexterm>
      <primary>pg_tracing</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>

    <listitem>
     <para>
      The <structname>pg_tracing_consume_spans</structname> and
      <structname>pg_tracing_peek_spans</structname> views are defined in
      terms of a function named <function>pg_tracing_spans</function>.
      It is possible for clients to call the
      <function>pg_tracing_spans</function> function directly. By
      specifying <literal>consume := false</literal>, spans won't be removed
      from the span buffer. With <literal>consume := true</literal>,
      read spans will be deleted.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="pgtracing-config-params">
  <title>Configuration Parameters</title>

  <variablelist>
   <varlistentry>
    <term>
     <varname>pg_tracing.max_span</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_tracing.max_span</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.max_span</varname> is the maximum number of
      spans stored by the module (i.e., the maximum number of rows
      returned by the <structname>pg_tracing_spans</structname> function).
      If more spans are observed, the span buffer will be emptied if
      <varname>pg_tracing.drop_on_full_buffer</varname> is true. If
      <varname>pg_tracing.drop_on_full_buffer</varname> if false, the spans
      will be dropped and tracing will be aborted.
      The default value is 5000. This parameter can only be set at server start.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.drop_on_full_buffer</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.drop_on_full_buffer</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.drop_on_full_buffer</varname> controls whether
      span buffer should be emptied when <varname>pg_tracing.max_span</varname>
      spans is reached. If <literal>off</literal>, new spans are dropped.
      The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.max_parameter_size</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_tracing.max_parameter_size</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.max_parameter_size</varname> controls the maximum
      size of the parameter string.
      The default value is <literal>1024</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.instrument_buffers</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.instrument_buffers</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.instrument_buffers</varname> controls whether
      buffer instrumentation should be enable and exported in span metadata.
      The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.instrument_wal</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.instrument_wal</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.instrument_wal</varname> controls whether
      WAL instrumentation should be enable and exported in span metadata.
      The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.max_traced_parallel_workers</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_tracing.max_traced_parallel_workers</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.max_traced_parallel_workers</varname> controls the maximum
      number of simultaneous parallel workers that can be traced.
      The default value is <literal>100</literal>.
      Only superusers can change this setting.
      This parameter can only be set at server start.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.initial_allocated_spans</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_tracing.initial_allocated_spans</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.initial_allocated_spans</varname> controls the number
      of allocated spans at the start of a trace.
      The default value is <literal>25</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.track</varname> (<type>enum</type>)
     <indexterm>
      <primary><varname>pg_tracing.track</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.track</varname> controls which statements
      should spans should be generated.
      Specify <literal>top</literal> to only generate span for top-level
      statements (those issued directly by clients), <literal>all</literal>
      to also generate spans for nested statements (such as statements invoked
      within functions), or <literal>none</literal> to disable span generation.
      The default value is <literal>all</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.track_utility</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.track_utility</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.track_utility</varname> controls whether spans
      should be generated for utility statements. Utility commands are
      all those other than <command>SELECT</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command>, and <command>MERGE</command>.
      The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.sample_rate</varname> (<type>real</type>)
     <indexterm>
      <primary><varname>pg_tracing.sample_rate</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.sample_rate</varname> controls the fraction of
      statements that generate spans. Statements with tracecontext propagated
      with SQLCommenter and sampled flag enabled are not impacted by this parameter.
      In case of nested statements, either all will be explained or none.
      The default value is <literal>0</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.caller_sample_rate</varname> (<type>real</type>)
     <indexterm>
      <primary><varname>pg_tracing.caller_sample_rate</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.caller_sample_rate</varname> controls the fraction of
      statements with with tracecontext propagated with SQLCommenter and an
      enabled sampled flag that will generate spans.
      The default value is <literal>1</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.export_parameters</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.export_parameters</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.export_parameters</varname> controls whether
      query's parameters should be exported in spans metadata.
      The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.deparse_plan</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.deparse_plan</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.deparse_plan</varname> controls whether
      the query plan should be deparsed. Deparsing plan allows to
      add more details in span's name. A
      <literal>BitmapHeapScan on pg_tracing_test</literal> node will
      become <literal>BitmapHeapScan on pg_tracing_test|Recheck Cond: (a = 1)</literal>
      with deparsing information.
      The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.notify_channel</varname> (<type>text</type>)
     <indexterm>
      <primary><varname>pg_tracing.notify_channel</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.notify_channel</varname> defines a channel
      that will receive a notification when the span buffer exceeds
      the <varname>pg_tracing.notify_threshold</varname> threshold.
      No channel is defined by default.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.notify_threshold</varname> (<type>real</type>)
     <indexterm>
      <primary><varname>pg_tracing.notify_threshold</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.notify_threshold</varname> defines the
      threhold for sending notification to the <varname>pg_tracing.notify_channel</varname>
      channel.
      The default value is <literal>0.8</literal>: a notification will be sent when span buffer
      crosses the 80% of usage.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   The module requires additional shared memory proportional to
   <varname>pg_tracing.max_span</varname>.  Note that this
   memory is consumed whenever the module is loaded, even if
   no spans are generated.
  </para>

  <para>
   These parameters must be set in <filename>postgresql.conf</filename>.
   Typical usage might be:

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_tracing'

compute_query_id = on
pg_tracing.span_max = 10000
pg_tracing.track = all
</programlisting>
  </para>
 </sect2>

 <sect2 id="pgtracing-implementation-details">
  <title>Implementation Details</title>

 <sect3 id="pgtracing-sqlcommenter">
  <title>SQLCommenter</title>
  <para>
   A query with <ulink url="https://google.github.io/sqlcommenter/">SQLcommenter</ulink> can propagate a trace context to the database. It will have the following format: <literal>/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000009-0000000000000005-01'*/ select 1;</literal>. The traceparent fields are detailed in <ulink url="https://www.w3.org/TR/trace-context/#traceparent-header-field-values">w3c's trace-context</ulink>
   <itemizedlist spacing="compact">
    <listitem>
     <para>
      <literal>00000000000000000000000000000009</literal>: trace id
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>0000000000000005</literal>: parent id
     </para>
    </listitem>
    <listitem>
     <para>
     <literal>01</literal>: trace flags (<literal>01 == sampled</literal>)
     </para>
    </listitem>
   </itemizedlist>
   When a query with SQLCommenter is detected, the trace context is extracted and used by <literal>pg_tracing</literal>.
  </para>
 </sect3>

 <sect3 id="pgtracing-sampling-decision">
  <title>Sampling Decision</title>
  <para>
  Spans will only be generated for sampled queries. A query is sampled if:
  <itemizedlist spacing="compact">
   <listitem>
    <para>
     It has a trace context propagated throught SQLCommenter with the sampled flag enabled and it passes the <varname>pg_tracing.caller_sample_rate</varname>
    </para>
   </listitem>
   <listitem>
    <para>
    It has no SQLCommenter but the query randomly passes the global <varname>pg_tracing.sample_rate</varname>
    </para>
   </listitem>
  </itemizedlist>
   By default, <literal>pg_tracing.caller_sample_rate = 1</literal> and <literal>pg_tracing.sample_rate = 0</literal>.
   Only queries with a trace context and a <literal>sampled := 01</literal> will be sampled, effectively leaving sampling decision to the callers.
  </para>
 </sect3>

 <sect3 id="pgtracing-parse-span">
  <title>Parse Span</title>
  <para>
   Parse spans generated by <filename>pg_tracing</filename> are an approximation.
   There's no parse hook available, only post parse hook is available.
   The end of the parse is estimated at the start of the post parse.
   For statement at the root level, the statement start is used as parse's start.
   For nested statements, the start of the new nested level is used.
  </para>
 </sect3>

 <sect3 id="pgtracing-span-time-precision">
  <title>Span Time Precision</title>
  <para>
   The start time of a span has two parts: <literal>span_start</literal> and
   <literal>span_start_ns</literal>. <literal>span_start</literal> is a Timestamp
   with time zone providing up a microsecond precision. <literal>span_start_ns</literal>
   provides the nanosecond part of the span start. <literal>span_start + span_start_ns</literal>
   can be used to get the start with nanosecond precision.
  </para>
 </sect3>

 <sect3 id="pgtracing-query-error">
  <title>Query error</title>
  <para>
   On query error (statement timeout reached, query canceled...), a sampled
   query will still generate spans. The planstate will be partial so
   the generated spans only reflect nodes that were executed and it's
   possible that some part of the plan will be missing.
  </para>
 </sect3>

 <sect3 id="pgtracing-overhead">
  <title>Overhead</title>
  <para>
   Sampling a query will enable the same type of query instrumentation as
   <command>EXPLAIN ANALYZE</command> and will have the same measurement overhead.
   Machines with slow <function>gettimeofday()</function> operating-system calls
   will have higher overhead. You can use the <xref linkend="pgtesttiming"/> tool
   to measure the overhead of timing on your system.
  </para>
 </sect3>

 </sect2>

 <sect2 id="pgtracing-sample-output">
  <title>Sample Output</title>

<screen>
=# SET pg_tracing.sample_rate = 1.0;

=# SELECT 1;

=# select trace_id, parent_id, span_id, span_start, duration, span_type, span_operation from pg_tracing_consume_spans;
       trace_id       |      parent_id       |       span_id        |          span_start           | duration |   span_type    |          span_operation
----------------------+----------------------+----------------------+-------------------------------+----------+----------------+-----------------------------------
   479062278978111363 |   479062278978111363 |   479062278978111363 | 2023-10-12 07:41:13.938561+00 |   555583 | Select         | select $1;
   479062278978111363 |   479062278978111363 |   479062278978111363 | 2023-10-12 07:41:13.938036+00 |   525875 | Parse          | Parse
   479062278978111363 |   479062278978111363 | -7732425595282414585 | 2023-10-12 07:41:13.938561+00 |    20083 | Post Parse     | Post Parse
   479062278978111363 |   479062278978111363 |  3166770036980751499 | 2023-10-12 07:41:13.938592+00 |   397250 | Planner        | Planner
   479062278978111363 |   479062278978111363 |  -672650609503721668 | 2023-10-12 07:41:13.939001+00 |    59541 | Executor       | ExecutorStart
   479062278978111363 |   479062278978111363 | -7168301816080933795 | 2023-10-12 07:41:13.939064+00 |    21750 | Executor       | ExecutorRun
   479062278978111363 |   479062278978111363 |  2947496540612753771 | 2023-10-12 07:41:13.939087+00 |     1333 | Executor       | ExecutorFinish
   479062278978111363 |   479062278978111363 | -4760927743519507589 | 2023-10-12 07:41:13.939089+00 |    28333 | Executor       | ExecutorEnd
   479062278978111363 | -7168301816080933795 |  2075274914194306348 | 2023-10-12 07:41:13.939071+00 |     5332 | Result         | Result
(9 rows)

=# select trace_id, parent_id, span_id, span_start, duration, name, resource from pg_tracing_consume_spans;
 trace_id | parent_id | span_id | span_start | duration | name | resource
----------+-----------+---------+------------+----------+------+----------
(0 rows)

</screen>
 </sect2>

 <sect2 id="pgtracing-authors">
  <title>Authors</title>

  <para>
   Anthonin Bonnefoy <email>anthonin.bonnefoy@datadoghq.com</email>.
  </para>
 </sect2>

</sect1>
