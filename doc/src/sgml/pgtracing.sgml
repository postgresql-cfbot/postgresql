<!-- doc/src/sgml/pgtracing.sgml -->

<sect1 id="pgtracing" xreflabel="pg_tracing">
 <title>pg_tracing &mdash; generate server-side spans for distributed tracing</title>

 <indexterm zone="pgtracing">
  <primary>pg_tracing</primary>
 </indexterm>

 <para>
  The <filename>pg_tracing</filename> module provides a way to
  generate server-side spans for distributed tracing.
 </para>

 <para>
  The module must be loaded by adding <literal>pg_tracing</literal> to
  <xref linkend="guc-shared-preload-libraries"/> in
  <filename>postgresql.conf</filename> because it requires additional shared memory.
  This means that a server restart is needed to add or remove the module.
 </para>

 <para>
   When <filename>pg_tracing</filename> is active, it generates spans
   on sampled queries. To access these spans, the module provides two views:
   <structname>pg_tracing_consume_spans</structname> and
   <structname>pg_tracing_peek_spans</structname>.
   The utility functions <function>pg_tracing_reset</function> and
   <function>pg_tracing_info</function> provide ways to read and reset
   module's statistics. These are not available globally but
   can be enabled for a specific database with
   <command>CREATE EXTENSION pg_tracing</command>.
 </para>

 <sect2 id="pgtracing-pg-tracing-consume-spans">
  <title>The <structname>pg_tracing_consume_spans</structname>/<structname>pg_tracing_peek_spans</structname> Views</title>

  <para>
   The spans generated by the module are made available via a
   view named <structname>pg_tracing_consume_spans</structname>.
   This view contains one row for each generated span.
   The columns of the view are shown in <xref linkend="pgtracing-consume-spans-columns"/>.
   The <structname>pg_tracing_peek_spans</structname> view
   provides the same output as <structname>pg_tracing_consume_spans</structname>.
   <structname>pg_tracing_peek_spans</structname> doesn't delete read spans.
  </para>

  <table id="pgtracing-consume-spans-columns">
   <title><structname>pg_tracing_consume_spans</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>traceid</structfield> <type>char(32)</type>
      </para>
      <para>
       Trace identifier of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parent_id</structfield> <type>char(16)</type>
      </para>
      <para>
       Identifier of the span's parent
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_id</structfield> <type>char(16)</type>
      </para>
      <para>
       Identifier of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>queryid</structfield> <type>bigint</type>
      </para>
      <para>
       Hash code to identify identical normalized queries, 0 if query_id is disabled
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_type</structfield> <type>text</type>
      </para>
      <para>
       Type of span (Planner, Executor...)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_operation</structfield> <type>text</type>
      </para>
      <para>
       Name of the span's operation
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Start time of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>span_end</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       End time of the span
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sql_error_code</structfield> <type>bpchar</type>
      </para>
      <para>
       Error code of the query. 00000 for a succesful query
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Pid of the backend process that processed the query
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subxact_count</structfield> <type>smallint</type>
      </para>
      <para>
       Active count of backend's subtransaction when the span was created
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_startup_cost</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated cost before fetching any tuples by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_total_cost</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated total cost by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_rows</structfield> <type>double precision</type>
      </para>
      <para>
       Estimated number of row plan is expected to emit
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>plan_width</structfield> <type>integer</type>
      </para>
      <para>
       Estimated row width in bytes by the query planner
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>rows</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples processed
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>nloops</structfield> <type>bigint</type>
      </para>
      <para>
       Number of cycles for this node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared block cache hits by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_dirtied</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks dirtied by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>shared_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of shared blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local block cache hits by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_dirtied</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks dirtied by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>local_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of local blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_read_time</structfield> <type>bigint</type>
      </para>
      <para>
       Time spent reading blocks in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_write_time</structfield> <type>bigint</type>
      </para>
      <para>
       Time spent writing blocks in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of temp blocks read by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of temp blocks written by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blk_read_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time the node spent reading temporary file blocks, in
       milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_blk_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time the node spent writing temporary file blocks, in
       milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL records generated by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL full page images generated by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       Total amount of WAL generated by the node in bytes
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_functions</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of functions JIT-compiled by the node
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_generation_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on generating JIT code, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_inlining_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on inlining functions, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>jit_optimization_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent by the node on optimizing, in milliseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>startup</structfield> <type>bigint</type>
      </para>
      <para>
       Time to the first tuple in nanoseconds
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>parameters</structfield> <type>text</type>
      </para>
      <para>
       Value of the query's parameters
      </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   For security reasons, only superusers and roles with privileges of the
   <literal>pg_read_all_stats</literal> role are allowed to access the
   <structname>pg_tracing_peek_spans</structname> and
   <structname>pg_tracing_consume_spans</structname>.
  </para>

 </sect2>

 <sect2 id="pgtracing-pg-tracing-info">
  <title>The <structname>pg_tracing_info</structname> View</title>

  <indexterm>
   <primary>pg_tracing_info</primary>
  </indexterm>

  <para>
   The statistics of the <filename>pg_tracing</filename> module
   itself are tracked and made available via a view named
   <structname>pg_tracing_info</structname>.  This view contains
   only a single row.  The columns of the view are shown in
   <xref linkend="pgtracinginfo-columns"/>.
  </para>

  <table id="pgtracinginfo-columns">
   <title><structname>pg_tracing_info</structname> Columns</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>processed_traces</structfield> <type>bigint</type>
      </para>
      <para>
       Total number traces captured by the module
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>processed_spans</structfield> <type>bigint</type>
      </para>
      <para>
       Total number spans captured by the module
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dropped_traces</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of sampled queries dropped because shared buffer
       was full
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>dropped_spans</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of spans dropped because more than
       <varname>pg_tracing.max_span</varname> were stored
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_consume</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which spans were consumed
      </para></entry>
     </row>

     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which all statistics in the
       <structname>pg_tracing_info</structname> view were last reset.
      </para></entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="pgtracing-funcs">
  <title>Functions</title>

  <variablelist>
   <varlistentry>
    <term>
     <function>pg_tracing_reset() returns void</function>
     <indexterm>
      <primary>pg_tracing_reset</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <function>pg_tracing_reset</function> discards all statistics
      gathered so far by <filename>pg_tracing</filename>.
      Span buffer is not emptied by this function.
      By default, this function can only be executed by superusers.
      Access may be granted to others using <command>GRANT</command>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <function>pg_tracing_spans(consume boolean) returns setof record</function>
     <indexterm>
      <primary>pg_tracing</primary>
      <secondary>function</secondary>
     </indexterm>
    </term>

    <listitem>
     <para>
      The <structname>pg_tracing_consume_spans</structname> and
      <structname>pg_tracing_peek_spans</structname> views are defined in
      terms of a function named <function>pg_tracing_spans</function>.
      It is possible for clients to call the
      <function>pg_tracing_spans</function> function directly. By
      specifying <literal>consume := false</literal>, spans won't be removed
      from the span buffer. With <literal>consume := true</literal>,
      read spans will be deleted.
      By default, this function can only be executed by superusers.
      Access may be granted to others using <command>GRANT</command>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect2>

 <sect2 id="pgtracing-config-params">
  <title>Configuration Parameters</title>

  <variablelist>
   <varlistentry>
    <term>
     <varname>pg_tracing.max_span</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_tracing.max_span</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.max_span</varname> is the maximum number of
      spans stored by the module (i.e., the maximum number of rows
      returned by the <structname>pg_tracing_spans</structname> function).
      If more spans are observed, the span buffer will be emptied if
      <varname>pg_tracing.buffer_mode</varname> is <literal>drop_on_full</literal>. If
      <varname>pg_tracing.buffer_mode</varname> is <literal>keep_on_full</literal>,
      the new spans will be dropped and tracing will be aborted. The default value
      is 5000. This parameter can only be set at server start.

     <note>

       <para>
        A span takes around 370 bytes of memory so 5000 spans will use
        1.7MB while 10000 spans will use 3.5MB. You can use the following query
        to get the exact size used by the pg_tracing's spans:
       </para>

<programlisting>
SELECT
    (SELECT setting from pg_settings where name='pg_tracing.max_span') as max_span,
    pg_size_pretty(size) as total_span_size,
    pg_size_pretty(size/(SELECT setting from pg_settings where name='pg_tracing.max_span')::int) as size_per_span
FROM pg_shmem_allocations
WHERE name ='PgTracing Spans';
</programlisting>

     </note>

     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.buffer_mode</varname> (<type>enum</type>)
     <indexterm>
      <primary><varname>pg_tracing.buffer_mode</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.buffer_mode</varname> controls span buffer's
      behaviour when <varname>pg_tracing.max_span</varname> spans is reached.
      If <literal>keep_on_full</literal>, existing buffer is kept while new spans are dropped.
      If <literal>drop_on_full</literal>, existing buffer is dropped and new spans are added.
      The default value is <literal>keep_on_full</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.max_parameter_size</varname> (<type>integer</type>)
     <indexterm>
      <primary><varname>pg_tracing.max_parameter_size</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.max_parameter_size</varname> controls the maximum
      size of the parameter string.
      The default value is <literal>1024</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.track</varname> (<type>enum</type>)
     <indexterm>
      <primary><varname>pg_tracing.track</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.track</varname> controls which statements
      should spans should be generated.
      Specify <literal>top</literal> to only generate span for top-level
      statements (those issued directly by clients), <literal>all</literal>
      to also generate spans for nested statements (such as statements invoked
      within functions), or <literal>none</literal> to disable span generation.
      The default value is <literal>all</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.track_utility</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.track_utility</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.track_utility</varname> controls whether spans
      should be generated for utility statements. Utility commands are
      all those other than <command>SELECT</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command>, <command>TABLE</command>,
      and <command>MERGE</command>. The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.sample_rate</varname> (<type>real</type>)
     <indexterm>
      <primary><varname>pg_tracing.sample_rate</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.sample_rate</varname> controls the fraction of
      statements that generate spans. Statements with tracecontext propagated
      with SQLCommenter and sampled flag enabled are not impacted by this parameter.
      In case of nested statements, either all will be explained or none.
      The default value is <literal>0</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.caller_sample_rate</varname> (<type>real</type>)
     <indexterm>
      <primary><varname>pg_tracing.caller_sample_rate</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.caller_sample_rate</varname> controls the fraction of
      statements with SQLCommenter tracecontext and an enabled sampled flag that
      will generate spans. The default value is <literal>1</literal>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <varname>pg_tracing.export_parameters</varname> (<type>boolean</type>)
     <indexterm>
      <primary><varname>pg_tracing.export_parameters</varname> configuration parameter</primary>
     </indexterm>
    </term>

    <listitem>
     <para>
      <varname>pg_tracing.export_parameters</varname> controls whether
      query's parameters should be exported in spans metadata.
      The default value is <literal>on</literal>.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>

  <para>
   The module requires additional shared memory proportional to
   <varname>pg_tracing.max_span</varname>.  Note that this
   memory is consumed whenever the module is loaded, even if
   no spans are generated.
  </para>

  <para>
   These parameters must be set in <filename>postgresql.conf</filename>.
   Typical usage might be:

<programlisting>
# postgresql.conf
shared_preload_libraries = 'pg_tracing'

compute_query_id = on
pg_tracing.span_max = 10000
pg_tracing.track = all
</programlisting>
  </para>
 </sect2>

 <sect2 id="pgtracing-implementation-details">
  <title>Implementation Details</title>

 <sect3 id="pgtracing-sqlcommenter">
  <title>SQLCommenter</title>
  <para>
   A query with <ulink url="https://google.github.io/sqlcommenter/">SQLcommenter</ulink> can propagate a trace context to the database. It will have the following format: <literal>/*dddbs='postgres.db',traceparent='00-00000000000000000000000000000009-0000000000000005-01'*/ select 1;</literal>. The traceparent fields are detailed in <ulink url="https://www.w3.org/TR/trace-context/#traceparent-header-field-values">w3c's trace-context</ulink>
   <itemizedlist spacing="compact">
    <listitem>
     <para>
      <literal>00000000000000000000000000000009</literal>: trace id
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>0000000000000005</literal>: parent id
     </para>
    </listitem>
    <listitem>
     <para>
     <literal>01</literal>: trace flags (<literal>01 == sampled</literal>)
     </para>
    </listitem>
   </itemizedlist>
   When a query with SQLCommenter is detected, the trace context is extracted and used by <literal>pg_tracing</literal>.
  </para>
 </sect3>

 <sect3 id="pgtracing-sampling-decision">
  <title>Sampling Decision</title>
  <para>
  Spans will only be generated for sampled queries. A query is sampled if:
  <itemizedlist spacing="compact">
   <listitem>
    <para>
     It has a trace context propagated throught SQLCommenter with the sampled flag enabled and it passes the <varname>pg_tracing.caller_sample_rate</varname>
    </para>
   </listitem>
   <listitem>
    <para>
    It has no SQLCommenter but the query randomly passes the global <varname>pg_tracing.sample_rate</varname>
    </para>
   </listitem>
  </itemizedlist>
   By default, <literal>pg_tracing.caller_sample_rate = 1</literal> and <literal>pg_tracing.sample_rate = 0</literal>.
   Only queries with a trace context and a <literal>sampled := 01</literal> will be sampled, effectively leaving sampling decision to the callers.
  </para>
 </sect3>

 <sect3 id="pgtracing-query-error">
  <title>Query error</title>
  <para>
   On query error (statement timeout reached, query canceled...), a sampled
   query will still generate spans. The planstate will be partial so
   the generated spans only reflect nodes that were executed and it's
   possible that some part of the plan will be missing.
  </para>
 </sect3>

 </sect2>

 <sect2 id="pgtracing-sample-output">
  <title>Sample Output</title>

<screen>
=# SET pg_tracing.sample_rate = 1.0;

=# SELECT 1;

=# select trace_id, parent_id, span_id, span_start, span_end, span_type, span_operation from pg_tracing_consume_spans order by span_start;
             trace_id             |    parent_id     |     span_id      |          span_start           |           span_end            |  span_type   | span_operation
----------------------------------+------------------+------------------+-------------------------------+-------------------------------+--------------+----------------
 458fbefd7034e670eb3d9c930862c378 | eb3d9c930862c378 | bdecb6e35d429f3d | 2024-01-10 09:54:16.321253+00 | 2024-01-10 09:54:16.321587+00 | Select query | SELECT $1;
 458fbefd7034e670eb3d9c930862c378 | bdecb6e35d429f3d | ad49f27543b0175d | 2024-01-10 09:54:16.3213+00   | 2024-01-10 09:54:16.321412+00 | Planner      | Planner
 458fbefd7034e670eb3d9c930862c378 | bdecb6e35d429f3d | 8805f7749249536b | 2024-01-10 09:54:16.321485+00 | 2024-01-10 09:54:16.321529+00 | Executor     | ExecutorRun

=# select trace_id, parent_id, span_id, span_start, span_end, span_type, span_operation from pg_tracing_consume_spans order by span_start;
 trace_id | parent_id | span_id | span_start | duration | name | resource
----------+-----------+---------+------------+----------+------+----------
(0 rows)

</screen>
 </sect2>

 <sect2 id="pgtracing-authors">
  <title>Authors</title>

  <para>
   Anthonin Bonnefoy <email>anthonin.bonnefoy@datadoghq.com</email>.
  </para>
 </sect2>

</sect1>
