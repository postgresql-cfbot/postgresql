CREATE TABLE agg_pushdown_parent (
	i int primary key,
	x int);
CREATE TABLE agg_pushdown_child1 (
	j int,
	parent int references agg_pushdown_parent,
	v double precision,
	PRIMARY KEY (j, parent));
CREATE INDEX ON agg_pushdown_child1(parent);
CREATE TABLE agg_pushdown_child2 (
	k int,
	parent int references agg_pushdown_parent,
	v double precision,
	PRIMARY KEY (k, parent));;
INSERT INTO agg_pushdown_parent(i, x)
SELECT n, n
FROM generate_series(0, 7) AS s(n);
INSERT INTO agg_pushdown_child1(j, parent, v)
SELECT 128 * i + n, i, random()
FROM generate_series(0, 127) AS s(n), agg_pushdown_parent;
INSERT INTO agg_pushdown_child2(k, parent, v)
SELECT 128 * i + n, i, random()
FROM generate_series(0, 127) AS s(n), agg_pushdown_parent;
ANALYZE;
SET enable_agg_pushdown TO on;
SET enable_nestloop TO on;
SET enable_hashjoin TO off;
SET enable_mergejoin TO off;
-- Perform scan of a table, aggregate the result, join it to the other table
-- and finalize the aggregation.
--
-- In addition, check that functionally dependent column "c.x" can be
-- referenced by SELECT although GROUP BY references "p.i".
EXPLAIN (COSTS off)
SELECT p.x, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.i GROUP BY p.i;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Sort
         Sort Key: p.i
         ->  Nested Loop
               ->  Partial HashAggregate
                     Group Key: c1.parent
                     ->  Seq Scan on agg_pushdown_child1 c1
               ->  Index Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
                     Index Cond: (i = c1.parent)
(10 rows)

-- The same for hash join.
SET enable_nestloop TO off;
SET enable_hashjoin TO on;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.i GROUP BY p.i;
                            QUERY PLAN                            
------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Sort
         Sort Key: p.i
         ->  Hash Join
               Hash Cond: (p.i = c1.parent)
               ->  Seq Scan on agg_pushdown_parent p
               ->  Hash
                     ->  Partial HashAggregate
                           Group Key: c1.parent
                           ->  Seq Scan on agg_pushdown_child1 c1
(11 rows)

-- The same for merge join.
SET enable_hashjoin TO off;
SET enable_mergejoin TO on;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.i GROUP BY p.i;
                         QUERY PLAN                         
------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Merge Join
         Merge Cond: (p.i = c1.parent)
         ->  Sort
               Sort Key: p.i
               ->  Seq Scan on agg_pushdown_parent p
         ->  Sort
               Sort Key: c1.parent
               ->  Partial HashAggregate
                     Group Key: c1.parent
                     ->  Seq Scan on agg_pushdown_child1 c1
(12 rows)

-- Restore the default values.
SET enable_nestloop TO on;
SET enable_hashjoin TO on;
-- Scan index on agg_pushdown_child1(parent) column and aggregate the result
-- using AGG_SORTED strategy.
SET enable_seqscan TO off;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.i GROUP BY p.i;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Nested Loop
         ->  Partial GroupAggregate
               Group Key: c1.parent
               ->  Index Scan using agg_pushdown_child1_parent_idx on agg_pushdown_child1 c1
         ->  Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
               Index Cond: (i = c1.parent)
(8 rows)

SET enable_seqscan TO on;
-- Join "c1" to "p.x" column, i.e. one that is not in the GROUP BY clause. The
-- planner should still use "c1.parent" as grouping expression for partial
-- aggregation, although it's not in the same equivalence class as the GROUP
-- BY expression ("p.i"). The reason to use "c1.parent" for partial
-- aggregation is that this is the only way for "c1" to provide the join
-- expression with input data.
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.x GROUP BY p.i;
                            QUERY PLAN                            
------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Sort
         Sort Key: p.i
         ->  Hash Join
               Hash Cond: (p.x = c1.parent)
               ->  Seq Scan on agg_pushdown_parent p
               ->  Hash
                     ->  Partial HashAggregate
                           Group Key: c1.parent
                           ->  Seq Scan on agg_pushdown_child1 c1
(11 rows)

-- Perform nestloop join between agg_pushdown_child1 and agg_pushdown_child2
-- and aggregate the result.
SET enable_nestloop TO on;
SET enable_hashjoin TO off;
SET enable_mergejoin TO off;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v + c2.v) FROM agg_pushdown_parent AS p JOIN
agg_pushdown_child1 AS c1 ON c1.parent = p.i JOIN agg_pushdown_child2 AS c2 ON
c2.parent = p.i WHERE c1.j = c2.k GROUP BY p.i;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Sort
         Sort Key: p.i
         ->  Nested Loop
               ->  Partial HashAggregate
                     Group Key: c1.parent
                     ->  Nested Loop
                           ->  Seq Scan on agg_pushdown_child1 c1
                           ->  Index Scan using agg_pushdown_child2_pkey on agg_pushdown_child2 c2
                                 Index Cond: ((k = c1.j) AND (parent = c1.parent))
               ->  Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
                     Index Cond: (i = c1.parent)
(13 rows)

-- The same for hash join.
SET enable_nestloop TO off;
SET enable_hashjoin TO on;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v + c2.v) FROM agg_pushdown_parent AS p JOIN
agg_pushdown_child1 AS c1 ON c1.parent = p.i JOIN agg_pushdown_child2 AS c2 ON
c2.parent = p.i WHERE c1.j = c2.k GROUP BY p.i;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Sort
         Sort Key: p.i
         ->  Hash Join
               Hash Cond: (p.i = c1.parent)
               ->  Seq Scan on agg_pushdown_parent p
               ->  Hash
                     ->  Partial HashAggregate
                           Group Key: c1.parent
                           ->  Hash Join
                                 Hash Cond: ((c1.parent = c2.parent) AND (c1.j = c2.k))
                                 ->  Seq Scan on agg_pushdown_child1 c1
                                 ->  Hash
                                       ->  Seq Scan on agg_pushdown_child2 c2
(15 rows)

-- The same for merge join.
SET enable_hashjoin TO off;
SET enable_mergejoin TO on;
SET enable_seqscan TO off;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v + c2.v) FROM agg_pushdown_parent AS p JOIN
agg_pushdown_child1 AS c1 ON c1.parent = p.i JOIN agg_pushdown_child2 AS c2 ON
c2.parent = p.i WHERE c1.j = c2.k GROUP BY p.i;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Merge Join
         Merge Cond: (c1.parent = p.i)
         ->  Sort
               Sort Key: c1.parent
               ->  Partial HashAggregate
                     Group Key: c1.parent
                     ->  Merge Join
                           Merge Cond: ((c1.j = c2.k) AND (c1.parent = c2.parent))
                           ->  Index Scan using agg_pushdown_child1_pkey on agg_pushdown_child1 c1
                           ->  Index Scan using agg_pushdown_child2_pkey on agg_pushdown_child2 c2
         ->  Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
(13 rows)

-- Most of the tests above with parallel query processing enforced.
SET min_parallel_index_scan_size = 0;
SET min_parallel_table_scan_size = 0;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
-- Partially aggregate a single relation.
--
-- Nestloop join.
SET enable_nestloop TO on;
SET enable_hashjoin TO off;
SET enable_mergejoin TO off;
EXPLAIN (COSTS off)
SELECT p.x, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.i GROUP BY p.i;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Gather Merge
         Workers Planned: 1
         ->  Nested Loop
               ->  Partial GroupAggregate
                     Group Key: c1.parent
                     ->  Parallel Index Scan using agg_pushdown_child1_parent_idx on agg_pushdown_child1 c1
               ->  Index Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
                     Index Cond: (i = c1.parent)
(10 rows)

-- Hash join.
SET enable_nestloop TO off;
SET enable_hashjoin TO on;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.i GROUP BY p.i;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Sort
         Sort Key: p.i
         ->  Gather
               Workers Planned: 1
               ->  Parallel Hash Join
                     Hash Cond: (c1.parent = p.i)
                     ->  Partial GroupAggregate
                           Group Key: c1.parent
                           ->  Parallel Index Scan using agg_pushdown_child1_parent_idx on agg_pushdown_child1 c1
                     ->  Parallel Hash
                           ->  Parallel Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
(13 rows)

-- Merge join.
SET enable_hashjoin TO off;
SET enable_mergejoin TO on;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v) FROM agg_pushdown_parent AS p JOIN agg_pushdown_child1
AS c1 ON c1.parent = p.i GROUP BY p.i;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Gather Merge
         Workers Planned: 1
         ->  Merge Join
               Merge Cond: (c1.parent = p.i)
               ->  Partial GroupAggregate
                     Group Key: c1.parent
                     ->  Parallel Index Scan using agg_pushdown_child1_parent_idx on agg_pushdown_child1 c1
               ->  Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
(10 rows)

SET enable_nestloop TO on;
SET enable_hashjoin TO on;
-- Perform nestloop join between agg_pushdown_child1 and agg_pushdown_child2
-- and aggregate the result.
SET enable_nestloop TO on;
SET enable_hashjoin TO off;
SET enable_mergejoin TO off;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v + c2.v) FROM agg_pushdown_parent AS p JOIN
agg_pushdown_child1 AS c1 ON c1.parent = p.i JOIN agg_pushdown_child2 AS c2 ON
c2.parent = p.i WHERE c1.j = c2.k GROUP BY p.i;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Gather Merge
         Workers Planned: 2
         ->  Sort
               Sort Key: p.i
               ->  Nested Loop
                     ->  Partial HashAggregate
                           Group Key: c1.parent
                           ->  Nested Loop
                                 ->  Parallel Index Scan using agg_pushdown_child1_pkey on agg_pushdown_child1 c1
                                 ->  Index Scan using agg_pushdown_child2_pkey on agg_pushdown_child2 c2
                                       Index Cond: ((k = c1.j) AND (parent = c1.parent))
                     ->  Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
                           Index Cond: (i = c1.parent)
(15 rows)

-- The same for hash join.
SET enable_nestloop TO off;
SET enable_hashjoin TO on;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v + c2.v) FROM agg_pushdown_parent AS p JOIN
agg_pushdown_child1 AS c1 ON c1.parent = p.i JOIN agg_pushdown_child2 AS c2 ON
c2.parent = p.i WHERE c1.j = c2.k GROUP BY p.i;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Gather Merge
         Workers Planned: 1
         ->  Sort
               Sort Key: p.i
               ->  Parallel Hash Join
                     Hash Cond: (c1.parent = p.i)
                     ->  Partial HashAggregate
                           Group Key: c1.parent
                           ->  Parallel Hash Join
                                 Hash Cond: ((c1.parent = c2.parent) AND (c1.j = c2.k))
                                 ->  Parallel Index Scan using agg_pushdown_child1_parent_idx on agg_pushdown_child1 c1
                                 ->  Parallel Hash
                                       ->  Parallel Index Scan using agg_pushdown_child2_pkey on agg_pushdown_child2 c2
                     ->  Parallel Hash
                           ->  Parallel Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
(17 rows)

-- The same for merge join.
SET enable_hashjoin TO off;
SET enable_mergejoin TO on;
SET enable_seqscan TO off;
EXPLAIN (COSTS off)
SELECT p.i, avg(c1.v + c2.v) FROM agg_pushdown_parent AS p JOIN
agg_pushdown_child1 AS c1 ON c1.parent = p.i JOIN agg_pushdown_child2 AS c2 ON
c2.parent = p.i WHERE c1.j = c2.k GROUP BY p.i;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Finalize GroupAggregate
   Group Key: p.i
   ->  Gather Merge
         Workers Planned: 2
         ->  Merge Join
               Merge Cond: (c1.parent = p.i)
               ->  Sort
                     Sort Key: c1.parent
                     ->  Partial HashAggregate
                           Group Key: c1.parent
                           ->  Merge Join
                                 Merge Cond: ((c1.j = c2.k) AND (c1.parent = c2.parent))
                                 ->  Parallel Index Scan using agg_pushdown_child1_pkey on agg_pushdown_child1 c1
                                 ->  Index Scan using agg_pushdown_child2_pkey on agg_pushdown_child2 c2
               ->  Index Only Scan using agg_pushdown_parent_pkey on agg_pushdown_parent p
(15 rows)

