src/backend/access/undo/README

Undo Logs
=========

The undo log subsystem provides a way to store data that is needed for a
limited time.  Undo-aware access methods and subsystems can generate undo
records, and they are eventually either executed at rollback time to reverse
the effects of a transaction, or discarded after commit and after no snapshot
could be interested in accessing them.  The storage format is optimized for
efficient recycling of space, and buffered random access.

Like redo data (the WAL), undo data consists of records identified by their
location within a 64 bit address space.  Unlike redo data, the addressing
space is internally divided up unto multiple numbered logs.  The first 24 bits
of an UndoRecPtr identify the undo log number, and the remaining 40 bits
address the space within that undo log.  Using multiple undo logs instead of a
single uniform space avoids the contention that would result from a single
insertion point, since each session can be given sole access to write data
into a given undo log.

Like redo data, undo data is stored on disk in numbered segment files that are
recycled as required.  Unlike redo data, undo data is accessed through the
buffer pool.  In this respect it is similar to regular relation data.  Buffer
content is written out to disk during checkpoints and whenever it is evicted
to make space for another page.  However, unlike regular relation data, undo
data has a chance of never being written to disk at all: if a page is
allocated and and then later discarded without an intervening checkpoint and
without an eviction caused by memory pressure, then no disk I/O is generated.

Undo Log Meta-Data
==================

At any given time the set of undo logs that exists is tracked in shared memory
and can be inspected with the pg_stat_undo_logs view.  For each undo log, a
set of meta-data properties is tracked: tracked, including:

* the tablespace that holds its segment files
* the category (permanent, unlogged, temporary)
* the "discard" pointer: data before this point has been discarded
* the "insert" pointer: new data will be written here
* the "end" pointer: a new undo segment file will be needed at this point

The three pointers move strictly forwards until the whole undo log has been
exhausted.  At all times discard <= insert <= end.  When discard == insert,
the undo log is empty (everything that has ever been inserted has since been
discarded).

The insert pointer advances when regular backends allocate new space, and the
discard pointer usually advances when an undo worker process determines that
no session could need the data either for rollback.  In some special cases
including single-user mode and temporary undo logs the discard pointer might
also be advanced synchronously by a foreground session.

UndoLogSlot objects corresponding to the current set of active undo logs are
held in a fixed-sized pool in shared memory.  The size of the array is a
multiple of max_connections.  This effectively limits the total size of an
active transaction, since the undo data it generates must by able to be
tracked by the number of slots in the pool, though the number of slots and
size per slot (1TB) are large enough that it should never in practice be
reached.

The meta-data for all undo logs is written to disk at every checkpoint.  It is
stored in files under PGDATA/pg_undo/, using the checkpoint's redo point (a
WAL LSN) as its filename.  At startup time, the redo point's file can be used
to restore all undo logs' meta-data as of the moment of the redo point into
shared memory.  Changes to the discard pointer are WAL-logged by undolog.c and
will bring the in-memory meta-data up to date in the event of recovery after a
crash.  Changes to insert pointers are implied by other WAL records (see
below) to minimize WAL traffic.

Responsibility for creating, deleting and recycling undo log segment files and
WAL logging the associated meta-data changes lies with
src/backend/storage/undo/undolog.c.

Persistence Levels and Tablespaces
==================================

When new undo log space is requested by client code, the persistence level of
the corresponding relation being modified and the current value of the GUC
"undo_tablespaces" controls which undo log is selected.  If the session is
already attached to a suitable undo log and it hasn't run out of address
space, it can be used immediately.  Otherwise a suitable undo log must be
either found or created.  The system should stabilize on one undo log per
active writing backend (or more if different tablespaces and persistence
levels are used).

When an unlogged relation is modified, undo data generated by the operation
must be stored in an unlogged undo log.  This causes the undo data to be
deleted along with all unlogged relations during recovery from a non-shutdown
checkpoint.  Likewise, temporary relations require special treatment: their
buffers are backend-local and they cannot be accessed by other backend
including undo workers.

Non-empty undo logs in a tablespace prevent the tablespace from being dropped.

Undo Log Contents
=================

Undo log contents are written into 1MB segment files under PGDATA/base/undo/
or PGDATA/pg_tblspc/VERSION/undo/ using filenames that encode the address
(UndoRecPtr) of their first byte.  A period '.'  separates the undo log number
part from the offset part, for the benefit of humans.

Undo logs are page-oriented and use regular PosgreSQL page headers including
checksums (if enabled) and LSNs.  An UndoRecPtr can be used to obtain a buffer
and an offset within the buffer, and then regular buffer locking and page LSN
rules apply.  While space is allocated by asking for a given number of usable
bytes (not including page headers), client code is responsible for stepping
over the page headers and advancing to the next page.

Undo Record Set (URS)
=====================

TODO: Elaborate more in detail and incorporate xactundo.c

Undo Record Set (URS) is an interface between the client code and
undolog.c. It manages undo log insertion per persistence level (permanent,
temporary, unlogged) for the current transaction. The client only needs to
create and URS object (UndoRecordSet), allocate space for each record
(UndoPrepareToInsert) and insert the record(s) (UndoInsert - this should be
called inside a critical section). Eventually the client needs to close the
UndoRecordSet object, typically at commit time.

The URS layer allows a single transaction to span multiple logs, but this fact
is hidden from the client. A single undo record must not exceed the maximum
log size (1 TB).

undorecordset.c WAL-logs all meta-data changes except discard pointer changes
(the discard pointer is managed by undolog.c). Instead of issuing special WAL
records, undorecordset.c attaches the meta-data to the undo buffers
(XLogRegisterBufData). Besides eliminating the need for new kinds of WAL
records, this approach ensures that during recovery we have the meta-data
always consistent with the most recently replayed WAL record.

For example, the information needed to close the current URS is attached to
the corresponding undo log buffers and these buffers are associated
(XLogRegisterBuffer) with a commit record. Thus, during recovery, the URS is
closed atomically with replaying the commit record, and so the transaction
status is immediately usable for decision whether the undo log of this URS can
be discarded. In contrast, if we used additional WAL record to close the URS,
we'd need to handle race conditions like commit record written but the "URS
close" record missing (because the server crashed right after it wrote the
commit record).

Responsibility for WAL-logging the contents of undo logs lies with client code
(ie undo-aware access managers). Client code is responsible for generating
exactly the same undo log data at recovery time so that the metadata
WAL-logged by undorecordset.c do match the contents.

See the header comment in src/backend/storage/undo/undorecordset.c for more
details.
