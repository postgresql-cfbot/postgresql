Parsed test spec with 2 sessions

starting permutation: s1prep s2lock s1exec s2dropi s2unlock
step s1prep: SET plan_cache_mode = force_generic_plan;
		  PREPARE q AS SELECT * FROM foov WHERE a = $1 FOR UPDATE;
		  EXPLAIN (COSTS OFF) EXECUTE q (1);
QUERY PLAN                                      
------------------------------------------------
LockRows                                        
  ->  Append                                    
        Subplans Removed: 2                     
        ->  Bitmap Heap Scan on foo12_1 foo_1   
              Recheck Cond: (a = $1)            
              ->  Bitmap Index Scan on foo12_1_a
                    Index Cond: (a = $1)        
(7 rows)

step s2lock: SELECT pg_advisory_lock(12345);
pg_advisory_lock
----------------
                
(1 row)

step s1exec: LOAD 'delay_execution';
		  SET delay_execution.executor_start_lock_id = 12345;
		  EXPLAIN (COSTS OFF) EXECUTE q (1); <waiting ...>
step s2dropi: DROP INDEX foo12_1_a;
step s2unlock: SELECT pg_advisory_unlock(12345);
pg_advisory_unlock
------------------
t                 
(1 row)

step s1exec: <... completed>
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                           
-------------------------------------
LockRows                             
  ->  Append                         
        Subplans Removed: 2          
        ->  Seq Scan on foo12_1 foo_1
              Filter: (a = $1)       
(5 rows)


starting permutation: s1prep2 s2lock s1exec2 s2dropi s2unlock
step s1prep2: SET plan_cache_mode = force_generic_plan;
		  PREPARE q2 AS SELECT * FROM foov WHERE a = one() or a = two();
		  EXPLAIN (COSTS OFF) EXECUTE q2;
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                        
--------------------------------------------------
Append                                            
  Subplans Removed: 1                             
  ->  Bitmap Heap Scan on foo12_1 foo_1           
        Recheck Cond: ((a = one()) OR (a = two()))
        ->  BitmapOr                              
              ->  Bitmap Index Scan on foo12_1_a  
                    Index Cond: (a = one())       
              ->  Bitmap Index Scan on foo12_1_a  
                    Index Cond: (a = two())       
  ->  Seq Scan on foo12_2 foo_2                   
        Filter: ((a = one()) OR (a = two()))      
(11 rows)

step s2lock: SELECT pg_advisory_lock(12345);
pg_advisory_lock
----------------
                
(1 row)

step s1exec2: LOAD 'delay_execution';
		  SET delay_execution.executor_start_lock_id = 12345;
		  EXPLAIN (COSTS OFF) EXECUTE q2; <waiting ...>
step s2dropi: DROP INDEX foo12_1_a;
step s2unlock: SELECT pg_advisory_unlock(12345);
pg_advisory_unlock
------------------
t                 
(1 row)

step s1exec2: <... completed>
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                  
--------------------------------------------
Append                                      
  Subplans Removed: 1                       
  ->  Seq Scan on foo12_1 foo_1             
        Filter: ((a = one()) OR (a = two()))
  ->  Seq Scan on foo12_2 foo_2             
        Filter: ((a = one()) OR (a = two()))
(6 rows)


starting permutation: s1prep3 s2lock s1exec3 s2dropi s2unlock
step s1prep3: SET plan_cache_mode = force_generic_plan;
		  PREPARE q3 AS UPDATE foov SET a = a WHERE a = one() or a = two();
		  EXPLAIN (COSTS OFF) EXECUTE q3;
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                              
--------------------------------------------------------
Append                                                  
  Subplans Removed: 1                                   
  ->  Bitmap Heap Scan on foo12_1 foo_1                 
        Recheck Cond: ((a = one()) OR (a = two()))      
        ->  BitmapOr                                    
              ->  Bitmap Index Scan on foo12_1_a        
                    Index Cond: (a = one())             
              ->  Bitmap Index Scan on foo12_1_a        
                    Index Cond: (a = two())             
  ->  Seq Scan on foo12_2 foo_2                         
        Filter: ((a = one()) OR (a = two()))            
                                                        
Update on foo                                           
  Update on foo12_1 foo_1                               
  Update on foo12_2 foo_2                               
  ->  Append                                            
        Subplans Removed: 1                             
        ->  Bitmap Heap Scan on foo12_1 foo_1           
              Recheck Cond: ((a = one()) OR (a = two()))
              ->  BitmapOr                              
                    ->  Bitmap Index Scan on foo12_1_a  
                          Index Cond: (a = one())       
                    ->  Bitmap Index Scan on foo12_1_a  
                          Index Cond: (a = two())       
        ->  Seq Scan on foo12_2 foo_2                   
              Filter: ((a = one()) OR (a = two()))      
(26 rows)

step s2lock: SELECT pg_advisory_lock(12345);
pg_advisory_lock
----------------
                
(1 row)

step s1exec3: LOAD 'delay_execution';
		  SET delay_execution.executor_start_lock_id = 12345;
		  EXPLAIN (COSTS OFF) EXECUTE q3; <waiting ...>
step s2dropi: DROP INDEX foo12_1_a;
step s2unlock: SELECT pg_advisory_unlock(12345);
pg_advisory_unlock
------------------
t                 
(1 row)

step s1exec3: <... completed>
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                        
--------------------------------------------------
Append                                            
  Subplans Removed: 1                             
  ->  Seq Scan on foo12_1 foo_1                   
        Filter: ((a = one()) OR (a = two()))      
  ->  Seq Scan on foo12_2 foo_2                   
        Filter: ((a = one()) OR (a = two()))      
                                                  
Update on foo                                     
  Update on foo12_1 foo_1                         
  Update on foo12_2 foo_2                         
  ->  Append                                      
        Subplans Removed: 1                       
        ->  Seq Scan on foo12_1 foo_1             
              Filter: ((a = one()) OR (a = two()))
        ->  Seq Scan on foo12_2 foo_2             
              Filter: ((a = one()) OR (a = two()))
(16 rows)


starting permutation: s1prep4 s2lock s1exec4 s2dropi s2unlock
step s1prep4: SET plan_cache_mode = force_generic_plan;
		  SET enable_seqscan TO off;
		  PREPARE q4 AS SELECT * FROM generate_series(1, 1) WHERE EXISTS (SELECT * FROM foov WHERE a = $1 FOR UPDATE);
		  EXPLAIN (COSTS OFF) EXECUTE q4 (1);
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                                     
---------------------------------------------------------------
Result                                                         
  One-Time Filter: (InitPlan 1).col1                           
  InitPlan 1                                                   
    ->  LockRows                                               
          Disabled Nodes: 2                                    
          ->  Append                                           
                Disabled Nodes: 2                              
                Subplans Removed: 2                            
                ->  Index Scan using foo12_1_a on foo12_1 foo_1
                      Index Cond: (a = $1)                     
  ->  Function Scan on generate_series                         
(11 rows)

step s2lock: SELECT pg_advisory_lock(12345);
pg_advisory_lock
----------------
                
(1 row)

step s1exec4: LOAD 'delay_execution';
		  SET delay_execution.executor_start_lock_id = 12345;
		  EXPLAIN (COSTS OFF) EXECUTE q4 (1); <waiting ...>
step s2dropi: DROP INDEX foo12_1_a;
step s2unlock: SELECT pg_advisory_unlock(12345);
pg_advisory_unlock
------------------
t                 
(1 row)

step s1exec4: <... completed>
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                   
---------------------------------------------
Result                                       
  One-Time Filter: (InitPlan 1).col1         
  InitPlan 1                                 
    ->  LockRows                             
          Disabled Nodes: 3                  
          ->  Append                         
                Disabled Nodes: 3            
                Subplans Removed: 2          
                ->  Seq Scan on foo12_1 foo_1
                      Disabled Nodes: 1      
                      Filter: (a = $1)       
  ->  Function Scan on generate_series       
(12 rows)

