Parsed test spec with 2 sessions

starting permutation: s1prep s2lock s1exec s2dropi s2unlock
step s1prep: SET plan_cache_mode = force_generic_plan;
		  PREPARE q AS SELECT * FROM foov WHERE a = $1 FOR UPDATE;
		  EXPLAIN (COSTS OFF) EXECUTE q (1);
QUERY PLAN                                    
----------------------------------------------
LockRows                                      
  ->  Append                                  
        Subplans Removed: 1                   
        ->  Bitmap Heap Scan on foo11 foo_1   
              Recheck Cond: (a = $1)          
              ->  Bitmap Index Scan on foo11_a
                    Index Cond: (a = $1)      
(7 rows)

step s2lock: SELECT pg_advisory_lock(12345);
pg_advisory_lock
----------------
                
(1 row)

step s1exec: LOAD 'delay_execution';
		  SET delay_execution.executor_start_lock_id = 12345;
		  EXPLAIN (COSTS OFF) EXECUTE q (1); <waiting ...>
step s2dropi: DROP INDEX foo11_a;
step s2unlock: SELECT pg_advisory_unlock(12345);
pg_advisory_unlock
------------------
t                 
(1 row)

step s1exec: <... completed>
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                         
-----------------------------------
LockRows                           
  ->  Append                       
        Subplans Removed: 1        
        ->  Seq Scan on foo11 foo_1
              Filter: (a = $1)     
(5 rows)


starting permutation: s1prep2 s2lock s1exec2 s2dropi s2unlock
step s1prep2: SET plan_cache_mode = force_generic_plan;
		  PREPARE q2 AS SELECT * FROM foov WHERE a = 1;
		  EXPLAIN (COSTS OFF) EXECUTE q2;
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                        
----------------------------------
Bitmap Heap Scan on foo11 foo     
  Recheck Cond: (a = 1)           
  ->  Bitmap Index Scan on foo11_a
        Index Cond: (a = 1)       
(4 rows)

step s2lock: SELECT pg_advisory_lock(12345);
pg_advisory_lock
----------------
                
(1 row)

step s1exec2: LOAD 'delay_execution';
		  SET delay_execution.executor_start_lock_id = 12345;
		  EXPLAIN (COSTS OFF) EXECUTE q2; <waiting ...>
step s2dropi: DROP INDEX foo11_a;
step s2unlock: SELECT pg_advisory_unlock(12345);
pg_advisory_unlock
------------------
t                 
(1 row)

step s1exec2: <... completed>
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN           
---------------------
Seq Scan on foo11 foo
  Filter: (a = 1)    
(2 rows)


starting permutation: s1prep3 s2lock s1exec3 s2dropi s2unlock
step s1prep3: SET plan_cache_mode = force_generic_plan;
		  SET enable_partitionwise_aggregate = on;
		  SET enable_partitionwise_join = on;
		  PREPARE q3 AS SELECT t1.a, count(t2.b) FROM foo t1, foo t2 WHERE t1.a = t2.a GROUP BY 1;
		  EXPLAIN (COSTS OFF) EXECUTE q3;
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                                  
------------------------------------------------------------
Append                                                      
  ->  GroupAggregate                                        
        Group Key: t1.a                                     
        ->  Merge Join                                      
              Merge Cond: (t1.a = t2.a)                     
              ->  Index Only Scan using foo11_a on foo11 t1 
              ->  Materialize                               
                    ->  Index Scan using foo11_a on foo11 t2
  ->  GroupAggregate                                        
        Group Key: t1_1.a                                   
        ->  Merge Join                                      
              Merge Cond: (t1_1.a = t2_1.a)                 
              ->  Sort                                      
                    Sort Key: t1_1.a                        
                    ->  Seq Scan on foo2 t1_1               
              ->  Sort                                      
                    Sort Key: t2_1.a                        
                    ->  Seq Scan on foo2 t2_1               
(18 rows)

step s2lock: SELECT pg_advisory_lock(12345);
pg_advisory_lock
----------------
                
(1 row)

step s1exec3: LOAD 'delay_execution';
		  SET delay_execution.executor_start_lock_id = 12345;
		  EXPLAIN (COSTS OFF) EXECUTE q3; <waiting ...>
step s2dropi: DROP INDEX foo11_a;
step s2unlock: SELECT pg_advisory_unlock(12345);
pg_advisory_unlock
------------------
t                 
(1 row)

step s1exec3: <... completed>
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is not valid
s1: NOTICE:  Finished ExecutorStart(): CachedPlan is valid
QUERY PLAN                                   
---------------------------------------------
Append                                       
  ->  GroupAggregate                         
        Group Key: t1.a                      
        ->  Merge Join                       
              Merge Cond: (t1.a = t2.a)      
              ->  Sort                       
                    Sort Key: t1.a           
                    ->  Seq Scan on foo11 t1 
              ->  Sort                       
                    Sort Key: t2.a           
                    ->  Seq Scan on foo11 t2 
  ->  GroupAggregate                         
        Group Key: t1_1.a                    
        ->  Merge Join                       
              Merge Cond: (t1_1.a = t2_1.a)  
              ->  Sort                       
                    Sort Key: t1_1.a         
                    ->  Seq Scan on foo2 t1_1
              ->  Sort                       
                    Sort Key: t2_1.a         
                    ->  Seq Scan on foo2 t2_1
(21 rows)

