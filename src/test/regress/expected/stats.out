--
-- Test cumulative stats system
--
-- Must be run after tenk2 has been created (by create_table),
-- populated (by create_misc) and indexed (by create_index).
--
-- conditio sine qua non
SHOW track_counts;  -- must be on
 track_counts 
--------------
 on
(1 row)

-- ensure that both seqscan and indexscan plans are allowed
SET enable_seqscan TO on;
SET enable_indexscan TO on;
-- for the moment, we don't want index-only scans here
SET enable_indexonlyscan TO off;
-- not enabled by default, but we want to test it...
SET track_functions TO 'all';
-- record dboid for later use
SELECT oid AS dboid from pg_database where datname = current_database() \gset
-- save counters
BEGIN;
SET LOCAL stats_fetch_consistency = snapshot;
CREATE TABLE prevstats AS
SELECT t.seq_scan, t.seq_tup_read, t.idx_scan, t.idx_tup_fetch,
       (b.heap_blks_read + b.heap_blks_hit) AS heap_blks,
       (b.idx_blks_read + b.idx_blks_hit) AS idx_blks,
       pg_stat_get_snapshot_timestamp() as snap_ts
  FROM pg_catalog.pg_stat_user_tables AS t,
       pg_catalog.pg_statio_user_tables AS b
 WHERE t.relname='tenk2' AND b.relname='tenk2';
COMMIT;
-- test effects of TRUNCATE on n_live_tup/n_dead_tup counters
CREATE TABLE trunc_stats_test(id serial);
CREATE TABLE trunc_stats_test1(id serial, stuff text);
CREATE TABLE trunc_stats_test2(id serial);
CREATE TABLE trunc_stats_test3(id serial, stuff text);
CREATE TABLE trunc_stats_test4(id serial);
-- check that n_live_tup is reset to 0 after truncate
INSERT INTO trunc_stats_test DEFAULT VALUES;
INSERT INTO trunc_stats_test DEFAULT VALUES;
INSERT INTO trunc_stats_test DEFAULT VALUES;
TRUNCATE trunc_stats_test;
-- test involving a truncate in a transaction; 4 ins but only 1 live
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
UPDATE trunc_stats_test1 SET id = id + 10 WHERE id IN (1, 2);
DELETE FROM trunc_stats_test1 WHERE id = 3;
BEGIN;
UPDATE trunc_stats_test1 SET id = id + 100;
TRUNCATE trunc_stats_test1;
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
COMMIT;
-- use a savepoint: 1 insert, 1 live
BEGIN;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
SAVEPOINT p1;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
TRUNCATE trunc_stats_test2;
INSERT INTO trunc_stats_test2 DEFAULT VALUES;
RELEASE SAVEPOINT p1;
COMMIT;
-- rollback a savepoint: this should count 4 inserts and have 2
-- live tuples after commit (and 2 dead ones due to aborted subxact)
BEGIN;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
SAVEPOINT p1;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
TRUNCATE trunc_stats_test3;
INSERT INTO trunc_stats_test3 DEFAULT VALUES;
ROLLBACK TO SAVEPOINT p1;
COMMIT;
-- rollback a truncate: this should count 2 inserts and produce 2 dead tuples
BEGIN;
INSERT INTO trunc_stats_test4 DEFAULT VALUES;
INSERT INTO trunc_stats_test4 DEFAULT VALUES;
TRUNCATE trunc_stats_test4;
INSERT INTO trunc_stats_test4 DEFAULT VALUES;
ROLLBACK;
-- do a seqscan
SELECT count(*) FROM tenk2;
 count 
-------
 10000
(1 row)

-- do an indexscan
-- make sure it is not a bitmap scan, which might skip fetching heap tuples
SET enable_bitmapscan TO off;
SELECT count(*) FROM tenk2 WHERE unique1 = 1;
 count 
-------
     1
(1 row)

RESET enable_bitmapscan;
-- ensure pending stats are flushed
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

-- check effects
BEGIN;
SET LOCAL stats_fetch_consistency = snapshot;
SELECT relname, n_tup_ins, n_tup_upd, n_tup_del, n_live_tup, n_dead_tup
  FROM pg_stat_user_tables
 WHERE relname like 'trunc_stats_test%' order by relname;
      relname      | n_tup_ins | n_tup_upd | n_tup_del | n_live_tup | n_dead_tup 
-------------------+-----------+-----------+-----------+------------+------------
 trunc_stats_test  |         3 |         0 |         0 |          0 |          0
 trunc_stats_test1 |         4 |         2 |         1 |          1 |          0
 trunc_stats_test2 |         1 |         0 |         0 |          1 |          0
 trunc_stats_test3 |         4 |         0 |         0 |          2 |          2
 trunc_stats_test4 |         2 |         0 |         0 |          0 |          2
(5 rows)

SELECT st.seq_scan >= pr.seq_scan + 1,
       st.seq_tup_read >= pr.seq_tup_read + cl.reltuples,
       st.idx_scan >= pr.idx_scan + 1,
       st.idx_tup_fetch >= pr.idx_tup_fetch + 1
  FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
 WHERE st.relname='tenk2' AND cl.relname='tenk2';
 ?column? | ?column? | ?column? | ?column? 
----------+----------+----------+----------
 t        | t        | t        | t
(1 row)

SELECT st.heap_blks_read + st.heap_blks_hit >= pr.heap_blks + cl.relpages,
       st.idx_blks_read + st.idx_blks_hit >= pr.idx_blks + 1
  FROM pg_statio_user_tables AS st, pg_class AS cl, prevstats AS pr
 WHERE st.relname='tenk2' AND cl.relname='tenk2';
 ?column? | ?column? 
----------+----------
 t        | t
(1 row)

SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newer
FROM prevstats AS pr;
 snapshot_newer 
----------------
 t
(1 row)

COMMIT;
----
-- Basic tests for track_functions
---
CREATE FUNCTION stats_test_func1() RETURNS VOID LANGUAGE plpgsql AS $$BEGIN END;$$;
SELECT 'stats_test_func1()'::regprocedure::oid AS stats_test_func1_oid \gset
CREATE FUNCTION stats_test_func2() RETURNS VOID LANGUAGE plpgsql AS $$BEGIN END;$$;
SELECT 'stats_test_func2()'::regprocedure::oid AS stats_test_func2_oid \gset
-- test that stats are accumulated
BEGIN;
SET LOCAL stats_fetch_consistency = none;
SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
 pg_stat_get_function_calls 
----------------------------
                           
(1 row)

SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid);
 pg_stat_get_xact_function_calls 
---------------------------------
                                
(1 row)

SELECT stats_test_func1();
 stats_test_func1 
------------------
 
(1 row)

SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid);
 pg_stat_get_xact_function_calls 
---------------------------------
                               1
(1 row)

SELECT stats_test_func1();
 stats_test_func1 
------------------
 
(1 row)

SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid);
 pg_stat_get_xact_function_calls 
---------------------------------
                               2
(1 row)

SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
 pg_stat_get_function_calls 
----------------------------
                          0
(1 row)

COMMIT;
-- Verify that function stats are not transactional
-- rolled back savepoint in committing transaction
BEGIN;
SELECT stats_test_func2();
 stats_test_func2 
------------------
 
(1 row)

SAVEPOINT foo;
SELECT stats_test_func2();
 stats_test_func2 
------------------
 
(1 row)

ROLLBACK TO SAVEPOINT foo;
SELECT pg_stat_get_xact_function_calls(:stats_test_func2_oid);
 pg_stat_get_xact_function_calls 
---------------------------------
                               2
(1 row)

SELECT stats_test_func2();
 stats_test_func2 
------------------
 
(1 row)

COMMIT;
-- rolled back transaction
BEGIN;
SELECT stats_test_func2();
 stats_test_func2 
------------------
 
(1 row)

ROLLBACK;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

-- check collected stats
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
     funcname     | calls 
------------------+-------
 stats_test_func1 |     2
(1 row)

SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func2_oid;
     funcname     | calls 
------------------+-------
 stats_test_func2 |     4
(1 row)

-- check that a rolled back drop function stats leaves stats alive
BEGIN;
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
     funcname     | calls 
------------------+-------
 stats_test_func1 |     2
(1 row)

DROP FUNCTION stats_test_func1();
-- shouldn't be visible via view
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
 funcname | calls 
----------+-------
(0 rows)

-- but still via oid access
SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
 pg_stat_get_function_calls 
----------------------------
                          2
(1 row)

ROLLBACK;
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
     funcname     | calls 
------------------+-------
 stats_test_func1 |     2
(1 row)

SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
 pg_stat_get_function_calls 
----------------------------
                          2
(1 row)

-- check that function dropped in main transaction leaves no stats behind
BEGIN;
DROP FUNCTION stats_test_func1();
COMMIT;
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
 funcname | calls 
----------+-------
(0 rows)

SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
 pg_stat_get_function_calls 
----------------------------
                           
(1 row)

-- check that function dropped in a subtransaction leaves no stats behind
BEGIN;
SELECT stats_test_func2();
 stats_test_func2 
------------------
 
(1 row)

SAVEPOINT a;
SELECT stats_test_func2();
 stats_test_func2 
------------------
 
(1 row)

SAVEPOINT b;
DROP FUNCTION stats_test_func2();
COMMIT;
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func2_oid;
 funcname | calls 
----------+-------
(0 rows)

SELECT pg_stat_get_function_calls(:stats_test_func2_oid);
 pg_stat_get_function_calls 
----------------------------
                           
(1 row)

-- Check that stats for relations are dropped. For that we need to access stats
-- by oid after the DROP TABLE. Save oids.
CREATE TABLE drop_stats_test();
INSERT INTO drop_stats_test DEFAULT VALUES;
SELECT 'drop_stats_test'::regclass::oid AS drop_stats_test_oid \gset
CREATE TABLE drop_stats_test_xact();
INSERT INTO drop_stats_test_xact DEFAULT VALUES;
SELECT 'drop_stats_test_xact'::regclass::oid AS drop_stats_test_xact_oid \gset
CREATE TABLE drop_stats_test_subxact();
INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
SELECT 'drop_stats_test_subxact'::regclass::oid AS drop_stats_test_subxact_oid \gset
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT pg_stat_get_live_tuples(:drop_stats_test_oid);
 pg_stat_get_live_tuples 
-------------------------
                       1
(1 row)

DROP TABLE drop_stats_test;
SELECT pg_stat_get_live_tuples(:drop_stats_test_oid);
 pg_stat_get_live_tuples 
-------------------------
                       0
(1 row)

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                0
(1 row)

-- check that rollback protects against having stats dropped and that local
-- modifications don't pose a problem
SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       1
(1 row)

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_tuples_inserted 
-----------------------------
                           1
(1 row)

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                0
(1 row)

BEGIN;
INSERT INTO drop_stats_test_xact DEFAULT VALUES;
SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                1
(1 row)

DROP TABLE drop_stats_test_xact;
SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                0
(1 row)

ROLLBACK;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       1
(1 row)

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_tuples_inserted 
-----------------------------
                           2
(1 row)

-- transactional drop
SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       1
(1 row)

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_tuples_inserted 
-----------------------------
                           2
(1 row)

BEGIN;
INSERT INTO drop_stats_test_xact DEFAULT VALUES;
SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                1
(1 row)

DROP TABLE drop_stats_test_xact;
SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                0
(1 row)

COMMIT;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       0
(1 row)

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
 pg_stat_get_tuples_inserted 
-----------------------------
                           0
(1 row)

-- savepoint rollback (2 levels)
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       1
(1 row)

BEGIN;
INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
SAVEPOINT sp1;
INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_subxact_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                2
(1 row)

SAVEPOINT sp2;
DROP TABLE drop_stats_test_subxact;
ROLLBACK TO SAVEPOINT sp2;
SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_subxact_oid);
 pg_stat_get_xact_tuples_inserted 
----------------------------------
                                2
(1 row)

COMMIT;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       3
(1 row)

-- savepoint rolback (1 level)
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       3
(1 row)

BEGIN;
SAVEPOINT sp1;
DROP TABLE drop_stats_test_subxact;
SAVEPOINT sp2;
ROLLBACK TO SAVEPOINT sp1;
COMMIT;
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       3
(1 row)

-- and now actually drop
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       3
(1 row)

BEGIN;
SAVEPOINT sp1;
DROP TABLE drop_stats_test_subxact;
SAVEPOINT sp2;
RELEASE SAVEPOINT sp1;
COMMIT;
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
 pg_stat_get_live_tuples 
-------------------------
                       0
(1 row)

DROP TABLE trunc_stats_test, trunc_stats_test1, trunc_stats_test2, trunc_stats_test3, trunc_stats_test4;
DROP TABLE prevstats;
-----
-- Test that various stats views are being properly populated
-----
-- Test that sessions is incremented when a new session is started in pg_stat_database
SELECT sessions AS db_stat_sessions FROM pg_stat_database WHERE datname = (SELECT current_database()) \gset
\c
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT sessions > :db_stat_sessions FROM pg_stat_database WHERE datname = (SELECT current_database());
 ?column? 
----------
 t
(1 row)

-- Test pg_stat_bgwriter checkpointer-related stats, together with pg_stat_wal
SELECT checkpoints_req AS rqst_ckpts_before FROM pg_stat_bgwriter \gset
-- Test pg_stat_wal (and make a temp table so our temp schema exists)
SELECT wal_bytes AS wal_bytes_before FROM pg_stat_wal \gset
CREATE TEMP TABLE test_stats_temp AS SELECT 17;
DROP TABLE test_stats_temp;
-- Checkpoint twice: The checkpointer reports stats after reporting completion
-- of the checkpoint. But after a second checkpoint we'll see at least the
-- results of the first.
CHECKPOINT;
CHECKPOINT;
SELECT checkpoints_req > :rqst_ckpts_before FROM pg_stat_bgwriter;
 ?column? 
----------
 t
(1 row)

SELECT wal_bytes > :wal_bytes_before FROM pg_stat_wal;
 ?column? 
----------
 t
(1 row)

-- Test pg_stat_get_backend_idset() and some allied functions.
-- In particular, verify that their notion of backend ID matches
-- our temp schema index.
SELECT (current_schemas(true))[1] = ('pg_temp_' || beid::text) AS match
FROM pg_stat_get_backend_idset() beid
WHERE pg_stat_get_backend_pid(beid) = pg_backend_pid();
 match 
-------
 t
(1 row)

-----
-- Test that resetting stats works for reset timestamp
-----
-- Test that reset_slru with a specified SLRU works.
SELECT stats_reset AS slru_commit_ts_reset_ts FROM pg_stat_slru WHERE name = 'CommitTs' \gset
SELECT stats_reset AS slru_notify_reset_ts FROM pg_stat_slru WHERE name = 'Notify' \gset
SELECT pg_stat_reset_slru('CommitTs');
 pg_stat_reset_slru 
--------------------
 
(1 row)

SELECT stats_reset > :'slru_commit_ts_reset_ts'::timestamptz FROM pg_stat_slru WHERE name = 'CommitTs';
 ?column? 
----------
 t
(1 row)

SELECT stats_reset AS slru_commit_ts_reset_ts FROM pg_stat_slru WHERE name = 'CommitTs' \gset
-- Test that multiple SLRUs are reset when no specific SLRU provided to reset function
SELECT pg_stat_reset_slru(NULL);
 pg_stat_reset_slru 
--------------------
 
(1 row)

SELECT stats_reset > :'slru_commit_ts_reset_ts'::timestamptz FROM pg_stat_slru WHERE name = 'CommitTs';
 ?column? 
----------
 t
(1 row)

SELECT stats_reset > :'slru_notify_reset_ts'::timestamptz FROM pg_stat_slru WHERE name = 'Notify';
 ?column? 
----------
 t
(1 row)

-- Test that reset_shared with archiver specified as the stats type works
SELECT stats_reset AS archiver_reset_ts FROM pg_stat_archiver \gset
SELECT pg_stat_reset_shared('archiver');
 pg_stat_reset_shared 
----------------------
 
(1 row)

SELECT stats_reset > :'archiver_reset_ts'::timestamptz FROM pg_stat_archiver;
 ?column? 
----------
 t
(1 row)

SELECT stats_reset AS archiver_reset_ts FROM pg_stat_archiver \gset
-- Test that reset_shared with bgwriter specified as the stats type works
SELECT stats_reset AS bgwriter_reset_ts FROM pg_stat_bgwriter \gset
SELECT pg_stat_reset_shared('bgwriter');
 pg_stat_reset_shared 
----------------------
 
(1 row)

SELECT stats_reset > :'bgwriter_reset_ts'::timestamptz FROM pg_stat_bgwriter;
 ?column? 
----------
 t
(1 row)

SELECT stats_reset AS bgwriter_reset_ts FROM pg_stat_bgwriter \gset
-- Test that reset_shared with wal specified as the stats type works
SELECT stats_reset AS wal_reset_ts FROM pg_stat_wal \gset
SELECT pg_stat_reset_shared('wal');
 pg_stat_reset_shared 
----------------------
 
(1 row)

SELECT stats_reset > :'wal_reset_ts'::timestamptz FROM pg_stat_wal;
 ?column? 
----------
 t
(1 row)

SELECT stats_reset AS wal_reset_ts FROM pg_stat_wal \gset
-- Test that reset_shared with no specified stats type doesn't reset anything
SELECT pg_stat_reset_shared(NULL);
 pg_stat_reset_shared 
----------------------
 
(1 row)

SELECT stats_reset = :'archiver_reset_ts'::timestamptz FROM pg_stat_archiver;
 ?column? 
----------
 t
(1 row)

SELECT stats_reset = :'bgwriter_reset_ts'::timestamptz FROM pg_stat_bgwriter;
 ?column? 
----------
 t
(1 row)

SELECT stats_reset = :'wal_reset_ts'::timestamptz FROM pg_stat_wal;
 ?column? 
----------
 t
(1 row)

-- Test that reset works for pg_stat_database
-- Since pg_stat_database stats_reset starts out as NULL, reset it once first so we have something to compare it to
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT stats_reset AS db_reset_ts FROM pg_stat_database WHERE datname = (SELECT current_database()) \gset
SELECT pg_stat_reset();
 pg_stat_reset 
---------------
 
(1 row)

SELECT stats_reset > :'db_reset_ts'::timestamptz FROM pg_stat_database WHERE datname = (SELECT current_database());
 ?column? 
----------
 t
(1 row)

----
-- pg_stat_get_snapshot_timestamp behavior
----
BEGIN;
SET LOCAL stats_fetch_consistency = snapshot;
-- no snapshot yet, return NULL
SELECT pg_stat_get_snapshot_timestamp();
 pg_stat_get_snapshot_timestamp 
--------------------------------
 
(1 row)

-- any attempt at accessing stats will build snapshot
SELECT pg_stat_get_function_calls(0);
 pg_stat_get_function_calls 
----------------------------
                           
(1 row)

SELECT pg_stat_get_snapshot_timestamp() >= NOW();
 ?column? 
----------
 t
(1 row)

-- shows NULL again after clearing
SELECT pg_stat_clear_snapshot();
 pg_stat_clear_snapshot 
------------------------
 
(1 row)

SELECT pg_stat_get_snapshot_timestamp();
 pg_stat_get_snapshot_timestamp 
--------------------------------
 
(1 row)

COMMIT;
----
-- pg_stat_have_stats behavior
----
-- fixed-numbered stats exist
SELECT pg_stat_have_stats('bgwriter', 0, 0);
 pg_stat_have_stats 
--------------------
 t
(1 row)

-- unknown stats kinds error out
SELECT pg_stat_have_stats('zaphod', 0, 0);
ERROR:  invalid statistics kind: "zaphod"
-- db stats have objoid 0
SELECT pg_stat_have_stats('database', :dboid, 1);
 pg_stat_have_stats 
--------------------
 f
(1 row)

SELECT pg_stat_have_stats('database', :dboid, 0);
 pg_stat_have_stats 
--------------------
 t
(1 row)

-- pg_stat_have_stats returns true for committed index creation
CREATE table stats_test_tab1 as select generate_series(1,10) a;
CREATE index stats_test_idx1 on stats_test_tab1(a);
SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
SET enable_seqscan TO off;
select a from stats_test_tab1 where a = 3;
 a 
---
 3
(1 row)

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 t
(1 row)

-- pg_stat_have_stats returns false for dropped index with stats
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 t
(1 row)

DROP index stats_test_idx1;
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 f
(1 row)

-- pg_stat_have_stats returns false for rolled back index creation
BEGIN;
CREATE index stats_test_idx1 on stats_test_tab1(a);
SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
select a from stats_test_tab1 where a = 3;
 a 
---
 3
(1 row)

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 t
(1 row)

ROLLBACK;
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 f
(1 row)

-- pg_stat_have_stats returns true for reindex CONCURRENTLY
CREATE index stats_test_idx1 on stats_test_tab1(a);
SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
select a from stats_test_tab1 where a = 3;
 a 
---
 3
(1 row)

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 t
(1 row)

REINDEX index CONCURRENTLY stats_test_idx1;
-- false for previous oid
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 f
(1 row)

-- true for new oid
SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 t
(1 row)

-- pg_stat_have_stats returns true for a rolled back drop index with stats
BEGIN;
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 t
(1 row)

DROP index stats_test_idx1;
ROLLBACK;
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
 pg_stat_have_stats 
--------------------
 t
(1 row)

-- put enable_seqscan back to on
SET enable_seqscan TO on;
-- ensure that stats accessors handle NULL input correctly
SELECT pg_stat_get_replication_slot(NULL);
 pg_stat_get_replication_slot 
------------------------------
 
(1 row)

SELECT pg_stat_get_subscription_stats(NULL);
 pg_stat_get_subscription_stats 
--------------------------------
 
(1 row)

-- Test that the following operations are tracked in pg_stat_io:
-- - clocksweeps of shared buffers
-- - reads of target blocks into shared buffers
-- - shared buffer cache hits when target blocks reside in shared buffers
-- - writes of shared buffers
-- - extends of relations using shared buffers
-- - fsyncs done to ensure the durability of data dirtying shared buffers
SELECT sum(clocksweeps) AS io_sum_shared_clocksweeps_before FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(hit) AS io_sum_shared_hits_before FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(read) AS io_sum_shared_reads_before FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(written) AS io_sum_shared_writes_before FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(extended) AS io_sum_shared_extends_before FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(files_synced) AS io_sum_shared_fsyncs_before FROM pg_stat_io WHERE io_context = 'shared' \gset
-- Create a regular table and insert some data to generate IOCONTEXT_SHARED
-- clocksweeps and extends.
CREATE TABLE test_io_shared(a int);
INSERT INTO test_io_shared SELECT i FROM generate_series(1,100)i;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

-- After a checkpoint, there should be some additional IOCONTEXT_SHARED writes
-- and fsyncs.
-- The second checkpoint ensures that stats from the first checkpoint have been
-- reported and protects against any potential races amongst the table
-- creation, a possible timing-triggered checkpoint, and the explicit
-- checkpoint in the test.
CHECKPOINT;
CHECKPOINT;
SELECT sum(clocksweeps) AS io_sum_shared_clocksweeps_after FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(written) AS io_sum_shared_writes_after FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(extended) AS io_sum_shared_extends_after FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT sum(files_synced) AS io_sum_shared_fsyncs_after FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT :io_sum_shared_clocksweeps_after > :io_sum_shared_clocksweeps_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_shared_writes_after > :io_sum_shared_writes_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_shared_extends_after > :io_sum_shared_extends_before;
 ?column? 
----------
 t
(1 row)

SELECT current_setting('fsync') = 'off' OR :io_sum_shared_fsyncs_after > :io_sum_shared_fsyncs_before;
 ?column? 
----------
 t
(1 row)

-- Change the tablespace so that the table is rewritten directly, then SELECT
-- from it to cause it to be read back into shared buffers.
SET allow_in_place_tablespaces = true;
CREATE TABLESPACE test_io_shared_stats_tblspc LOCATION '';
ALTER TABLE test_io_shared SET TABLESPACE test_io_shared_stats_tblspc;
SELECT COUNT(*) FROM test_io_shared;
 count 
-------
   100
(1 row)

SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT sum(read) AS io_sum_shared_reads_after FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT :io_sum_shared_reads_after > :io_sum_shared_reads_before;
 ?column? 
----------
 t
(1 row)

-- Select from the table again once it is in shared buffers. There should be
-- some hits recorded in pg_stat_io.
SELECT sum(hit) AS io_sum_shared_hits_after FROM pg_stat_io WHERE io_context = 'shared' \gset
SELECT :io_sum_shared_hits_after > :io_sum_shared_hits_before;
 ?column? 
----------
 t
(1 row)

DROP TABLE test_io_shared;
DROP TABLESPACE test_io_shared_stats_tblspc;
-- Test that clocksweeps of local buffers, reads of temporary table blocks
-- into local buffers, temporary table block cache hits in local buffers,
-- writes of local buffers, and extends of temporary tables are tracked in
-- pg_stat_io.
-- Set temp_buffers to a low value so that we can trigger writes with fewer
-- inserted tuples. Do so in a new session in case temporary tables have been
-- accessed by previous tests in this session.
\c
SET temp_buffers TO '1MB';
CREATE TEMPORARY TABLE test_io_local(a int, b TEXT);
SELECT sum(clocksweeps) AS io_sum_local_clocksweeps_before FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(hit) AS io_sum_local_hits_before FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(read) AS io_sum_local_reads_before FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(written) AS io_sum_local_writes_before FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(extended) AS io_sum_local_extends_before FROM pg_stat_io WHERE io_context = 'local' \gset
-- Insert enough values that we need to reuse and write out dirty local
-- buffers.
INSERT INTO test_io_local SELECT generate_series(1, 8000) as id, repeat('a', 100);
-- Read in evicted buffers.
SELECT COUNT(*) FROM test_io_local;
 count 
-------
  8000
(1 row)

-- Query tuples in local buffers to ensure new local buffer cache hits.
SELECT COUNT(*) FROM test_io_local;
 count 
-------
  8000
(1 row)

SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT sum(clocksweeps) AS io_sum_local_clocksweeps_after FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(hit) AS io_sum_local_hits_after FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(read) AS io_sum_local_reads_after FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(written) AS io_sum_local_writes_after FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT sum(extended) AS io_sum_local_extends_after FROM pg_stat_io WHERE io_context = 'local' \gset
SELECT :io_sum_local_clocksweeps_after > :io_sum_local_clocksweeps_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_local_reads_after > :io_sum_local_reads_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_local_hits_after > :io_sum_local_hits_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_local_writes_after > :io_sum_local_writes_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_local_extends_after > :io_sum_local_extends_before;
 ?column? 
----------
 t
(1 row)

RESET temp_buffers;
-- Test that reuse of strategy buffers and reads of blocks into these reused
-- buffers while VACUUMing are tracked in pg_stat_io.
-- Set wal_skip_threshold smaller than the expected size of
-- test_io_vac_strategy so that, even if wal_level is minimal, VACUUM FULL will
-- fsync the newly rewritten test_io_vac_strategy instead of writing it to WAL.
-- Writing it to WAL will result in the newly written relation pages being in
-- shared buffers -- preventing us from testing BAS_VACUUM BufferAccessStrategy
-- clocksweeps and reads.
SET wal_skip_threshold = '1 kB';
SELECT sum(clocksweeps) AS io_sum_vac_strategy_clocksweeps_before FROM pg_stat_io WHERE io_context = 'vacuum' \gset
SELECT sum(reused) AS io_sum_vac_strategy_reuses_before FROM pg_stat_io WHERE io_context = 'vacuum' \gset
SELECT sum(read) AS io_sum_vac_strategy_reads_before FROM pg_stat_io WHERE io_context = 'vacuum' \gset
CREATE TABLE test_io_vac_strategy(a int, b int) WITH (autovacuum_enabled = 'false');
INSERT INTO test_io_vac_strategy SELECT i, i from generate_series(1, 8000)i;
-- Ensure that the next VACUUM will need to perform IO by rewriting the table
-- first with VACUUM (FULL).
VACUUM (FULL) test_io_vac_strategy;
VACUUM (PARALLEL 0) test_io_vac_strategy;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT sum(clocksweeps) AS io_sum_vac_strategy_clocksweeps_after FROM pg_stat_io WHERE io_context = 'vacuum' \gset
SELECT sum(reused) AS io_sum_vac_strategy_reuses_after FROM pg_stat_io WHERE io_context = 'vacuum' \gset
SELECT sum(read) AS io_sum_vac_strategy_reads_after FROM pg_stat_io WHERE io_context = 'vacuum' \gset
SELECT :io_sum_vac_strategy_clocksweeps_after > :io_sum_vac_strategy_clocksweeps_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_vac_strategy_reads_after > :io_sum_vac_strategy_reads_before;
 ?column? 
----------
 t
(1 row)

SELECT :io_sum_vac_strategy_reuses_after > :io_sum_vac_strategy_reuses_before;
 ?column? 
----------
 t
(1 row)

RESET wal_skip_threshold;
-- Test that extends done by a CTAS, which uses a BAS_BULKWRITE
-- BufferAccessStrategy, are tracked in pg_stat_io.
SELECT sum(extended) AS io_sum_bulkwrite_strategy_extends_before FROM pg_stat_io WHERE io_context = 'bulkwrite' \gset
CREATE TABLE test_io_bulkwrite_strategy AS SELECT i FROM generate_series(1,100)i;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT sum(extended) AS io_sum_bulkwrite_strategy_extends_after FROM pg_stat_io WHERE io_context = 'bulkwrite' \gset
SELECT :io_sum_bulkwrite_strategy_extends_after > :io_sum_bulkwrite_strategy_extends_before;
 ?column? 
----------
 t
(1 row)

-- Test that reads of blocks into reused strategy buffers during database
-- creation, which uses a BAS_BULKREAD BufferAccessStrategy, are tracked in
-- pg_stat_io.
SELECT sum(read) AS io_sum_bulkread_strategy_reads_before FROM pg_stat_io WHERE io_context = 'bulkread' \gset
CREATE DATABASE test_io_bulkread_strategy_db;
SELECT pg_stat_force_next_flush();
 pg_stat_force_next_flush 
--------------------------
 
(1 row)

SELECT sum(read) AS io_sum_bulkread_strategy_reads_after FROM pg_stat_io WHERE io_context = 'bulkread' \gset
SELECT :io_sum_bulkread_strategy_reads_after > :io_sum_bulkread_strategy_reads_before;
 ?column? 
----------
 t
(1 row)

-- Test IO stats reset
SELECT sum(clocksweeps) + sum(reused) + sum(extended) + sum(files_synced) + sum(read) + sum(written) AS io_stats_pre_reset FROM pg_stat_io \gset
SELECT pg_stat_reset_shared('io');
 pg_stat_reset_shared 
----------------------
 
(1 row)

SELECT sum(clocksweeps) + sum(reused) + sum(extended) + sum(files_synced) + sum(read) + sum(written) AS io_stats_post_reset FROM pg_stat_io \gset
SELECT :io_stats_post_reset < :io_stats_pre_reset;
 ?column? 
----------
 t
(1 row)

-- End of Stats Test
