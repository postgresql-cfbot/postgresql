<!--
doc/src/sgml/ref/pg_subscriber.sgml
PostgreSQL documentation
-->

<refentry id="app-pgsubscriber">
 <indexterm zone="app-pgsubscriber">
  <primary>pg_subscriber</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pg_subscriber</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pg_subscriber</refname>
  <refpurpose>create a new logical replica from a base backup of a
  <productname>PostgreSQL</productname> cluster or a standby
  server</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pg_subscriber</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
  <para>
   <application>pg_subscriber</application> takes the publisher and subscriber
   connection strings, a base backup directory and a list of database names and
   it sets up a new logical replica using the physical recovery process. A
   standby server can also be used.
  </para>

  <para>
   The <application>pg_subscriber</application> should be run at the target
   server. The source server (known as publisher server) should accept logical
   replication connections from the target server (known as subscriber server).
   The target server should accept local logical replication connection.
  </para>

  <para>
   The transformation proceeds in eight steps. First,
   <application>pg_subscriber</application> checks if the given target data
   directory has the same system identifier than the source data directory.
   Since it uses the recovery process as one of the steps, it starts the target
   server as a replica from the source server. If the system identifier is not
   the same, <application>pg_subscriber</application> will terminate with an
   error.
  </para>

  <para>
   Second, <application>pg_subscriber</application> checks if the target data
   directory is used by a standby server. Stop the standby server if it is
   running. One of the next steps is to add some recovery parameters that
   requires a server start. This step avoids an error.
  </para>

  <para>
   Next, <application>pg_subscriber</application> creates one replication slot
   for each specified database on the source server. The replication slot name
   contains a <literal>pg_subscriber</literal> prefix. These replication slots
   will be used by the subscriptions in a future step.  Another replication
   slot is used to get a consistent start location. This consistent LSN will be
   used (a) as a stopping point in the <xref
   linkend="guc-recovery-target-lsn"/> parameter and (b) by the subscriptions
   as a replication starting point. It guarantees that no transaction will be
   lost.
  </para>

  <para>
   Next, write recovery parameters into the target data directory and start the
   target server. It specifies a LSN (consistent LSN that was obtained in the
   previous step) of write-ahead log location up to which recovery will
   proceed. It also specifies <literal>promote</literal> as the action that the
   server should take once the recovery target is reached. This step finishes
   once the server ends standby mode and is accepting read-write operations.
  </para>

  <para>
   Next, <application>pg_subscriber</application> creates one publication for
   each specified database on the source server. Each publication replicates
   changes for all tables in the database. The publication name contains a
   <literal>pg_subscriber</literal> prefix. These publication will be used by a
   corresponding subscription in a next step.
  </para>

  <para>
   Next, <application>pg_subscriber</application> creates one subscription for
   each specified database on the target server. Each subscription name
   contains a <literal>pg_subscriber</literal> prefix. The replication slot
   name is identical to the subscription name. It also does not copy existing
   data from the source server. It does not create a replication slot. Instead,
   it uses the replication slot that was created in a previous step. The
   subscription is created but it is not enabled yet. The reason is the
   replication progress must be set to the consistent LSN but replication
   origin name contains the subscription oid in its name. Hence, the
   subscription will be enabled in a separate step.
  </para>

  <para>
   Next, <application>pg_subscriber</application> sets the replication progress
   to the consistent LSN that was obtained in a previous step. When the target
   server started the recovery process, it caught up to the consistent LSN.
   This is the exact LSN to be used as a initial location for the logical
   replication.
  </para>

  <para>
   Finally, <application>pg_subscriber</application> enables the subscription
   for each specified database on the target server. The subscription starts
   streaming from the consistent LSN.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

   <para>
    <application>pg_subscriber</application> accepts the following
    command-line arguments:

    <variablelist>
     <varlistentry>
      <term><option>-D <replaceable class="parameter">directory</replaceable></option></term>
      <term><option>--pgdata=<replaceable class="parameter">directory</replaceable></option></term>
      <listitem>
       <para>
        The target directory that contains a base backup. It can also be a
        cluster directory from a standby server.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>-P  <replaceable class="parameter">conninfo</replaceable></option></term>
      <term><option>--publisher-conninfo=<replaceable class="parameter">conninfo</replaceable></option></term>
      <listitem>
       <para>
        The connection string to the publisher. For details see <xref linkend="libpq-connstring"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>-S <replaceable class="parameter">conninfo</replaceable></option></term>
      <term><option>--subscriber-conninfo=<replaceable class="parameter">conninfo</replaceable></option></term>
      <listitem>
       <para>
        The connection string to the subscriber. For details see <xref linkend="libpq-connstring"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>-d <replaceable class="parameter">dbname</replaceable></option></term>
      <term><option>--database=<replaceable class="parameter">dbname</replaceable></option></term>
      <listitem>
       <para>
        The database name to create the subscription. Multiple databases can be
        selected by writing multiple <option>-d</option> switches.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--verbose</option></term>
      <listitem>
       <para>
        Enables verbose mode. This will cause
        <application>pg_subscriber</application> to output progress messages
        and detailed information about each step.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Other options are also available:

    <variablelist>
     <varlistentry>
       <term><option>-V</option></term>
       <term><option>--version</option></term>
       <listitem>
       <para>
       Print the <application>pg_subscriber</application> version and exit.
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
       <term><option>-?</option></term>
       <term><option>--help</option></term>
       <listitem>
       <para>
       Show help about <application>pg_subscriber</application> command
       line arguments, and exit.
       </para>
       </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect1>

 <refsect1>
  <title>Examples</title>

  <para>
   To create a logical replica for database <literal>bar</literal> from a base
   backup of the server at <literal>foo</literal>:
<screen>
<prompt>$</prompt> <userinput>pg_basebackup -h foo -D /usr/local/pgsql/data</userinput>
<prompt>$</prompt> <userinput>pg_subscriber -D /usr/local/pgsql/data -P "host=foo" -S "host=localhost" -d bar</userinput>
</screen>
  </para>

  <para>
   To create a logical replica for databases <literal>hr</literal> and
   <literal>finance</literal> from a standby server at <literal>foo</literal>:
<screen>
<prompt>$</prompt> <userinput>pg_subscriber -D /usr/local/pgsql/data -P "host=foo" -S "host=localhost" -d hr -d finance</userinput>
</screen>
  </para>

 </refsect1>

 <refsect1>
  <title>See Also</title>

  <simplelist type="inline">
   <member><xref linkend="app-pgbasebackup"/></member>
  </simplelist>
 </refsect1>

</refentry>
